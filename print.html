<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Practice( Rust ç»ƒä¹ å®è·µ )</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Learning Rust By Practice, narrowing the gap between beginner and skilled-dev with challenging examples, exercises and projects.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style1.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="why-exercise.html"><strong aria-hidden="true">1.</strong> å…³äº practice.rs</a></li><li class="chapter-item expanded "><a href="elegant-code-base.html"><strong aria-hidden="true">2.</strong> å€¼å¾—å­¦ä¹ çš„å°å‹é¡¹ç›®</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">3.</strong> å˜é‡ç»‘å®šä¸è§£æ„</a></li><li class="chapter-item expanded "><a href="basic-types/intro.html"><strong aria-hidden="true">4.</strong> åŸºæœ¬ç±»å‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-types/numbers.html"><strong aria-hidden="true">4.1.</strong> æ•°å€¼ç±»å‹</a></li><li class="chapter-item "><a href="basic-types/char-bool-unit.html"><strong aria-hidden="true">4.2.</strong> å­—ç¬¦ã€å¸ƒå°”ã€å•å…ƒç±»å‹</a></li><li class="chapter-item "><a href="basic-types/statements-expressions.html"><strong aria-hidden="true">4.3.</strong> è¯­å¥ä¸è¡¨è¾¾å¼</a></li><li class="chapter-item "><a href="basic-types/functions.html"><strong aria-hidden="true">4.4.</strong> å‡½æ•°</a></li></ol></li><li class="chapter-item expanded "><a href="ownership/intro.html"><strong aria-hidden="true">5.</strong> æ‰€æœ‰æƒå’Œå€Ÿç”¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/ownership.html"><strong aria-hidden="true">5.1.</strong> æ‰€æœ‰æƒ</a></li><li class="chapter-item "><a href="ownership/borrowing.html"><strong aria-hidden="true">5.2.</strong> å¼•ç”¨å’Œå€Ÿç”¨</a></li></ol></li><li class="chapter-item expanded "><a href="compound-types/intro.html"><strong aria-hidden="true">6.</strong> å¤åˆç±»å‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compound-types/string.html"><strong aria-hidden="true">6.1.</strong> å­—ç¬¦ä¸²</a></li><li class="chapter-item "><a href="compound-types/array.html"><strong aria-hidden="true">6.2.</strong> æ•°ç»„</a></li><li class="chapter-item "><a href="compound-types/slice.html"><strong aria-hidden="true">6.3.</strong> åˆ‡ç‰‡</a></li><li class="chapter-item "><a href="compound-types/tuple.html"><strong aria-hidden="true">6.4.</strong> å…ƒç»„</a></li><li class="chapter-item "><a href="compound-types/struct.html"><strong aria-hidden="true">6.5.</strong> ç»“æ„ä½“</a></li><li class="chapter-item "><a href="compound-types/enum.html"><strong aria-hidden="true">6.6.</strong> æšä¸¾</a></li></ol></li><li class="chapter-item expanded "><a href="flow-control.html"><strong aria-hidden="true">7.</strong> æµç¨‹æ§åˆ¶</a></li><li class="chapter-item expanded "><a href="pattern-match/intro.html"><strong aria-hidden="true">8.</strong> æ¨¡å¼åŒ¹é…</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-match/match-iflet.html"><strong aria-hidden="true">8.1.</strong> match, matches! å’Œ if let</a></li><li class="chapter-item "><a href="pattern-match/patterns.html"><strong aria-hidden="true">8.2.</strong> æ¨¡å¼</a></li></ol></li><li class="chapter-item expanded "><a href="method.html"><strong aria-hidden="true">9.</strong> æ–¹æ³•å’Œå…³è”å‡½æ•°</a></li><li class="chapter-item expanded "><a href="generics-traits/intro.html"><strong aria-hidden="true">10.</strong> æ³›å‹å’Œç‰¹å¾</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics-traits/generics.html"><strong aria-hidden="true">10.1.</strong> æ³›å‹</a></li><li class="chapter-item "><a href="generics-traits/const-generics.html"><strong aria-hidden="true">10.2.</strong> Const æ³›å‹</a></li><li class="chapter-item "><a href="generics-traits/traits.html"><strong aria-hidden="true">10.3.</strong> ç‰¹å¾ Traits</a></li><li class="chapter-item "><a href="generics-traits/trait-object.html"><strong aria-hidden="true">10.4.</strong> ç‰¹å¾å¯¹è±¡</a></li><li class="chapter-item "><a href="generics-traits/advanced-traits.html"><strong aria-hidden="true">10.5.</strong> è¿›ä¸€æ­¥æ·±å…¥ç‰¹å¾</a></li></ol></li><li class="chapter-item expanded "><a href="collections/intro.html"><strong aria-hidden="true">11.</strong> é›†åˆç±»å‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="collections/string.html"><strong aria-hidden="true">11.1.</strong> åŠ¨æ€å­—ç¬¦ä¸² String</a></li><li class="chapter-item "><a href="collections/vector.html"><strong aria-hidden="true">11.2.</strong> åŠ¨æ€æ•°ç»„ Vector</a></li><li class="chapter-item "><a href="collections/hashmap.html"><strong aria-hidden="true">11.3.</strong> KV å­˜å‚¨ HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="type-conversions/intro.html"><strong aria-hidden="true">12.</strong> ç±»å‹è½¬æ¢</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="type-conversions/as.html"><strong aria-hidden="true">12.1.</strong> as</a></li><li class="chapter-item "><a href="type-conversions/from-into.html"><strong aria-hidden="true">12.2.</strong> From/Into</a></li><li class="chapter-item "><a href="type-conversions/others.html"><strong aria-hidden="true">12.3.</strong> å…¶å®ƒè½¬æ¢</a></li></ol></li><li class="chapter-item expanded "><a href="result-panic/intro.html"><strong aria-hidden="true">13.</strong> è¿”å›å€¼å’Œ panic!</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="result-panic/panic.html"><strong aria-hidden="true">13.1.</strong> panic! æ·±å…¥å‰–æ</a></li><li class="chapter-item "><a href="result-panic/result.html"><strong aria-hidden="true">13.2.</strong> è¿”å›å€¼result å’Œ ?</a></li></ol></li><li class="chapter-item expanded "><a href="crate-module/intro.html"><strong aria-hidden="true">14.</strong> åŒ…å’Œæ¨¡å—</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crate-module/crate.html"><strong aria-hidden="true">14.1.</strong> åŒ… Crate</a></li><li class="chapter-item "><a href="crate-module/module.html"><strong aria-hidden="true">14.2.</strong> æ¨¡å— Module</a></li><li class="chapter-item "><a href="crate-module/use-pub.html"><strong aria-hidden="true">14.3.</strong> ä½¿ç”¨useå¼•å…¥æ¨¡å—åŠå—é™å¯è§æ€§</a></li></ol></li><li class="chapter-item expanded "><a href="comments-docs.html"><strong aria-hidden="true">15.</strong> æ³¨é‡Šå’Œæ–‡æ¡£</a></li><li class="chapter-item expanded "><a href="formatted-output.html"><strong aria-hidden="true">16.</strong> æ ¼å¼åŒ–è¾“å‡º</a></li><li class="chapter-item expanded "><a href="lifetime/intro.html"><strong aria-hidden="true">17.</strong> ç”Ÿå‘½å‘¨æœŸ</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lifetime/basic.html"><strong aria-hidden="true">17.1.</strong> ç”Ÿå‘½å‘¨æœŸåŸºç¡€</a></li><li class="chapter-item "><a href="lifetime/static.html"><strong aria-hidden="true">17.2.</strong> &'static å’Œ T: 'static</a></li><li class="chapter-item "><a href="lifetime/advance.html"><strong aria-hidden="true">17.3.</strong> æ·±å…¥ç”Ÿå‘½å‘¨æœŸ</a></li></ol></li><li class="chapter-item expanded "><a href="functional-programing/intro.html"><strong aria-hidden="true">18.</strong> å‡½æ•°å¼ç¼–ç¨‹: é—­åŒ…ã€è¿­ä»£å™¨ todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="functional-programing/closure.html"><strong aria-hidden="true">18.1.</strong> é—­åŒ… Closure</a></li><li class="chapter-item "><a href="functional-programing/iterator.html"><strong aria-hidden="true">18.2.</strong> è¿­ä»£å™¨ Iterator</a></li></ol></li><li class="chapter-item expanded "><a href="newtype-sized.html"><strong aria-hidden="true">19.</strong> newtype å’Œ Sized todo</a></li><li class="chapter-item expanded "><a href="smart-pointers/intro.html"><strong aria-hidden="true">20.</strong> æ™ºèƒ½æŒ‡é’ˆ todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="smart-pointers/box.html"><strong aria-hidden="true">20.1.</strong> Box</a></li><li class="chapter-item "><a href="smart-pointers/deref.html"><strong aria-hidden="true">20.2.</strong> Deref</a></li><li class="chapter-item "><a href="smart-pointers/drop.html"><strong aria-hidden="true">20.3.</strong> Drop</a></li><li class="chapter-item "><a href="smart-pointers/rc-arc.html"><strong aria-hidden="true">20.4.</strong> Rc and Arc</a></li><li class="chapter-item "><a href="smart-pointers/cell-refcell.html"><strong aria-hidden="true">20.5.</strong> Cell and RefCell</a></li></ol></li><li class="chapter-item expanded "><a href="weak.html"><strong aria-hidden="true">21.</strong> Weak å’Œå¾ªç¯å¼•ç”¨todo</a></li><li class="chapter-item expanded "><a href="self-referential.html"><strong aria-hidden="true">22.</strong> è‡ªå¼•ç”¨ todo</a></li><li class="chapter-item expanded "><a href="threads/intro.html"><strong aria-hidden="true">23.</strong> å¤šçº¿ç¨‹ todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="threads/basic-using.html"><strong aria-hidden="true">23.1.</strong> å¤šçº¿ç¨‹åŸºç¡€</a></li><li class="chapter-item "><a href="threads/message-passing.html"><strong aria-hidden="true">23.2.</strong> æ¶ˆæ¯ä¼ é€’</a></li><li class="chapter-item "><a href="threads/sync.html"><strong aria-hidden="true">23.3.</strong> çº¿ç¨‹åŒæ­¥ï¼šé”ã€Condvarå’Œä¿¡å·é‡</a></li><li class="chapter-item "><a href="threads/atomic.html"><strong aria-hidden="true">23.4.</strong> çº¿ç¨‹åŒæ­¥ï¼šAtomic</a></li><li class="chapter-item "><a href="threads/send-sync.html"><strong aria-hidden="true">23.5.</strong> Send å’Œ Sync</a></li></ol></li><li class="chapter-item expanded "><a href="global-variables.html"><strong aria-hidden="true">24.</strong> å…¨å±€å˜é‡ todo</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">25.</strong> é”™è¯¯å¤„ç† todo</a></li><li class="chapter-item expanded "><a href="unsafe/intro.html"><strong aria-hidden="true">26.</strong> Unsafe doing</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/inline-asm.html"><strong aria-hidden="true">26.1.</strong> å†…è”æ±‡ç¼–</a></li></ol></li><li class="chapter-item expanded "><a href="macro.html"><strong aria-hidden="true">27.</strong> macro å® todo</a></li><li class="chapter-item expanded "><a href="tests/intro.html"><strong aria-hidden="true">28.</strong> æµ‹è¯• todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/write-tests.html"><strong aria-hidden="true">28.1.</strong> ç¼–å†™æµ‹è¯•åŠæ§åˆ¶æ‰§è¡Œ</a></li><li class="chapter-item "><a href="tests/benchmark.html"><strong aria-hidden="true">28.2.</strong> åŸºå‡†æ€§èƒ½æµ‹è¯• Benchmark</a></li><li class="chapter-item "><a href="tests/unit-integration.html"><strong aria-hidden="true">28.3.</strong> å•å…ƒæµ‹è¯•åŠé›†æˆæµ‹è¯•</a></li><li class="chapter-item "><a href="tests/assertions.html"><strong aria-hidden="true">28.4.</strong> æ–­è¨€ Assertions</a></li></ol></li><li class="chapter-item expanded "><a href="async/intro.html"><strong aria-hidden="true">29.</strong> Async/Await å¼‚æ­¥ç¼–ç¨‹ todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/async-await.html"><strong aria-hidden="true">29.1.</strong> async å’Œ await!</a></li><li class="chapter-item "><a href="async/future.html"><strong aria-hidden="true">29.2.</strong> Future</a></li><li class="chapter-item "><a href="async/pin-unpin.html"><strong aria-hidden="true">29.3.</strong> Pin å’Œ Unpin</a></li><li class="chapter-item "><a href="async/stream.html"><strong aria-hidden="true">29.4.</strong> Stream æµå¤„ç†</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>
        
        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust By Practice( Rust ç»ƒä¹ å®è·µ )</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-by-practice" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 align="center">Rustè¯­è¨€å®æˆ˜</h1>
<div align="center">
    <img height="150" src="https://github.com/sunface/rust-by-practice/blob/master/en/assets/logo.png?raw=true">
</div>
<p align="center">é€šè¿‡æœ‰æŒ‘æˆ˜æ€§çš„ç¤ºä¾‹ã€ç»ƒä¹ é¢˜ã€å®è·µé¡¹ç›®æ¥æå‡ Rust æ°´å¹³ï¼Œå»ºç«‹ä»å…¥é—¨å­¦ä¹ åˆ°ä¸Šæ‰‹å®æˆ˜çš„ç›´é€šæ¡¥æ¢</p>
<div align="center">
<p><a href="https://github.com/sunface/rust-by-practice/stargazers"><img src="https://img.shields.io/github/stars/sunface/rust-by-practice?style=flat" alt="Stars Count" /></a> <a href="https://github.com/naaive/orange/network/members"><img src="https://img.shields.io/github/forks/sunface/rust-by-practice.svg?style=flat" alt="Forks Count" /></a>
<a href="https://github.com/sunface/rust-by-practice/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-mit-green?style=flat" alt="LICENSE" /></a></p>
</div>
<p><em>Rustè¯­è¨€å®æˆ˜</em> çš„ç›®æ ‡æ˜¯é€šè¿‡å¤§é‡çš„å®æˆ˜ç»ƒä¹ å¸®åŠ©å¤§å®¶æ›´å¥½çš„å­¦ä¹ å’Œä¸Šæ‰‹ä½¿ç”¨ Rust è¯­è¨€ã€‚ä¹¦ä¸­çš„ç»ƒä¹ é¢˜éå¸¸æ˜“äºä½¿ç”¨ï¼šä½ æ‰€éœ€çš„å°±æ˜¯åœ¨çº¿å®Œæˆç»ƒä¹ ï¼Œå¹¶è®©å®ƒé€šè¿‡ç¼–è¯‘ã€‚</p>
<h2 id="åœ¨çº¿é˜…è¯»"><a class="header" href="#åœ¨çº¿é˜…è¯»">åœ¨çº¿é˜…è¯»</a></h2>
<ul>
<li><a href="https://zh.practice.rs">https://zh.practice.rs</a></li>
</ul>
<h2 id="æœ¬åœ°è¿è¡Œ"><a class="header" href="#æœ¬åœ°è¿è¡Œ">æœ¬åœ°è¿è¡Œ</a></h2>
<p>æˆ‘ä»¬ä½¿ç”¨ <a href="https://rust-lang.github.io/mdBook/">mdbook</a> æ„å»ºåœ¨çº¿ç»ƒä¹ é¢˜ï¼Œä½ ä¹Ÿå¯ä»¥ä¸‹è½½åˆ°æœ¬åœ°è¿è¡Œï¼š</p>
<pre><code class="language-shell">$ git clone git@github.com:sunface/rust-by-practice.git
$ cargo install mdbook
$ cd rust-by-practice &amp;&amp; mdbook serve zh-CN/
</code></pre>
<p>åœ¨æœ¬åœ°win 10æˆ–è€…linuxæœåŠ¡å™¨ä¸Šè¿è¡Œæ—¶ï¼Œåº”å½“ä½¿ç”¨ -n å‚æ•°æŒ‡å®šmdbookæœåŠ¡æ‰€ç›‘å¬çš„IPåœ°å€ï¼ˆ-p å‚æ•°æŒ‡å®šæœåŠ¡ç›‘å¬çš„ç«¯å£ï¼Œä¸æŒ‡å®šåˆ™ä¸ºé»˜è®¤çš„3000ï¼‰ï¼Œä»¥win 10æœ¬åœ°è¿è¡Œä¸ºä¾‹ï¼š</p>
<pre><code class="language-shell">$ mdbook serve -p 8888 -n 127.0.0.1 zh-CN/
</code></pre>
<h2 id="ç‰¹æ€§"><a class="header" href="#ç‰¹æ€§">ç‰¹æ€§</a></h2>
<p>éƒ¨åˆ†ç¤ºä¾‹å’Œä¹ é¢˜å€Ÿé‰´äº† <a href="https://github.com/rust-lang/rust-by-example">Rust By Example</a>, ä¹¦ä¸­çš„ç¤ºä¾‹çœŸçš„éå¸¸æ£’ï¼</p>
<p>å°½ç®¡å®ƒä»¬éå¸¸ä¼˜ç§€ï¼Œæˆ‘ä»¬è¿™æœ¬ä¹¦ä¹Ÿæœ‰è‡ªå·±çš„ç§˜å¯†æ­¦å™¨ :)</p>
<ul>
<li>
<p>æ¯ä¸ªç« èŠ‚åˆ†ä¸ºä¸‰ä¸ªå¯é€‰éƒ¨åˆ†ï¼šç¤ºä¾‹ã€ç»ƒä¹ å’Œå®è·µé¡¹ç›®</p>
</li>
<li>
<p>é™¤äº†ç¤ºä¾‹å¤–ï¼Œæˆ‘ä»¬è¿˜æœ‰å¤§é‡çš„é«˜è´¨é‡ç»ƒä¹ é¢˜ï¼Œä½ å¯ä»¥åœ¨çº¿é˜…è¯»ã€ä¿®æ”¹å’Œç¼–è¯‘å®ƒä»¬</p>
</li>
<li>
<p>è¦†ç›–äº† Rust è¯­è¨€çš„å‡ ä¹æ‰€æœ‰æ–¹é¢ï¼šåŸºç¡€è¯­è¨€ç‰¹æ€§ã€é«˜çº§è¯­è¨€ç‰¹æ€§ã€async/await å¼‚æ­¥ç¼–ç¨‹ã€å¤šçº¿ç¨‹ã€å¹¶å‘åŸè¯­ã€æ€§èƒ½ä¼˜åŒ–ã€å·¥å…·é“¾ä½¿ç”¨ã€æ ‡å‡†åº“ã€æ•°æ®ç»“æ„å’Œç®—æ³•ç­‰</p>
</li>
<li>
<p>æ¯ä¸€é“ç»ƒä¹ é¢˜éƒ½æä¾›äº†è§£ç­”</p>
</li>
<li>
<p>æ•´ä½“éš¾åº¦ç›¸å¯¹æ›´é«˜ï¼Œæ›´åŠ è´´è¿‘äºå®æˆ˜éš¾åº¦: ç®€å• ğŸŒŸ , ä¸­ç­‰ ğŸŒŸğŸŒŸ , å›°éš¾ ğŸŒŸğŸŒŸğŸŒŸ  , åœ°ç‹± ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ</p>
</li>
</ul>
<p><strong>æ€»ä¹‹ï¼Œæˆ‘ä»¬æƒ³åšçš„å°±æ˜¯è§£å†³å…¥é—¨å­¦ä¹ åï¼Œä¸çŸ¥é“è¯¥å¦‚ä½•è¿ç”¨çš„é—®é¢˜ï¼Œæ¯•ç«Ÿå¯¹äº Rust æ¥è¯´ï¼Œä»å­¦ä¹ åˆ°å®æˆ˜ï¼Œä¸­é—´è¿˜éš”ç€æ•°ä¸ª Goè¯­è¨€ çš„éš¾åº¦</strong></p>
<h2 id="å…³äºæˆ‘ä»¬"><a class="header" href="#å…³äºæˆ‘ä»¬">å…³äºæˆ‘ä»¬</a></h2>
<p><em>Rustè¯­è¨€å®æˆ˜</em> ç”± Rust ç¼–ç¨‹å­¦é™¢å€¾æƒ…æ‰“é€ ã€‚</p>
<p>åŒæ—¶æˆ‘ä»¬è¿˜æä¾›äº†ä¸€æœ¬ç›®å‰æœ€å¥½ä¹Ÿæ˜¯æœ€ç”¨å¿ƒçš„å¼€æº Rust ä¹¦ç± - <a href="https://github.com/sunface/rust-course">Rustè¯­è¨€åœ£ç»</a>ï¼Œ é€‚åˆä»å…¥é—¨åˆ°ç²¾é€šæ‰€æœ‰é˜¶æ®µçš„å­¦ä¹ ï¼Œæ¬¢è¿å¤§å®¶é˜…è¯»ä½¿ç”¨ã€‚</p>
<p>å¯¹æˆ‘ä»¬æ¥è¯´ï¼Œæ¥è‡ªè¯»è€…å¤§å¤§çš„è‚¯å®šæ¯”ä»€ä¹ˆéƒ½é‡è¦ï¼Œå› æ­¤ä¸€ä¸ª <a href="https://github.com/sunface/rust-by-practice">Github star</a> è¦æ¯”ä¸€æ¯å’–å•¡æ›´è®©æˆ‘ä»¬å¼€å¿ƒï¼Œè€Œä¸”ç°åœ¨å®ƒåœ¨è·³æ¥¼æ‰“æŠ˜ï¼Œæ— éœ€ 998 ï¼Œ ä»…éœ€ 0 å…ƒé’± :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å€¼å¾—å­¦ä¹ çš„å°å‹é¡¹ç›®"><a class="header" href="#å€¼å¾—å­¦ä¹ çš„å°å‹é¡¹ç›®">å€¼å¾—å­¦ä¹ çš„å°å‹é¡¹ç›®</a></h1>
<p>åœ¨å›½å†…å¤–çš„å„å¤§ Rust è®ºå›ä¸Šï¼Œä»¥ä¸‹é—®é¢˜éå¸¸å¸¸è§: </p>
<ul>
<li>ä½œä¸º Rust æ–°æ‰‹ï¼Œæœ‰å“ªäº›é¡¹ç›®å€¼å¾—æ¨èå­¦ä¹ ?</li>
<li>æ±‚æ¨èä»£ç ä¼˜é›…çš„å°å‹é¡¹ç›®</li>
<li>æœ‰å“ªäº›å€¼å¾—æ¨èçš„ç®€å•ã€æ˜“è¯»çš„é¡¹ç›®</li>
</ul>
<p>è¿™äº›é—®é¢˜çš„ç­”æ¡ˆå¾€å¾€åªæœ‰ä¸€ä¸ªï¼Œé‚£å°±æ˜¯å®è·µï¼šåšä¸€äº›ä¼˜ç§€çš„ç»ƒä¹ é¢˜ï¼Œç„¶åé˜…è¯»ä¸€äº›å°è€Œç¾çš„ Rust é¡¹ç›®ã€‚</p>
<p>è¿™ä¸ªæ°æ°è·Ÿæœ¬ä¹¦çš„ç›®æ ‡å»åˆï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å†³å®šæ”¶é›†ä¸€äº›ä¼˜ç§€çš„èµ„æºï¼Œå¹¶åœ¨ <em>Rustè¯­è¨€å®æˆ˜</em> ä¸­å‘ˆç°ç»™å¤§å®¶ã€‚</p>
<h3 id="1-ripgrep"><a class="header" href="#1-ripgrep">1. Ripgrep</a></h3>
<p>ä»¥ä¸Šçš„é—®é¢˜é€šå¸¸éƒ½ä¼šä¼´éšç€ <a href="https://github.com/BurntSushi/ripgrep"><code>ripgrep</code></a> çš„æ¨è, è™½ç„¶æˆ‘ä¸è®¤ä¸ºå®ƒæ˜¯ä¸€ä¸ªå°å‹é¡¹ç›®ï¼Œä½†æ˜¯ä¾ç„¶éå¸¸æ¨èå¤§å®¶å­¦ä¹ ï¼Œå½“ç„¶ï¼Œé¦–å…ˆä½ å¾—åšå¥½æ·±æŒ–çš„å‡†å¤‡å’Œè€å¿ƒã€‚</p>
<h3 id="2-æ•™ç¨‹æ„å»ºä¸€ä¸ªæ–‡æœ¬ç¼–è¾‘å™¨"><a class="header" href="#2-æ•™ç¨‹æ„å»ºä¸€ä¸ªæ–‡æœ¬ç¼–è¾‘å™¨">2. æ•™ç¨‹ï¼šæ„å»ºä¸€ä¸ªæ–‡æœ¬ç¼–è¾‘å™¨</a></h3>
<p>è¯¥æ•™ç¨‹ <a href="https://www.flenker.blog/hecto/"><code>https://www.flenker.blog/hecto/</code></a> å°†å¸¦é¢†æˆ‘ä»¬ä»é›¶å¼€å§‹æ„å»ºä¸€ä¸ªæ–‡æœ¬ç¼–è¾‘å™¨.</p>
<h3 id="3-ncspot"><a class="header" href="#3-ncspot">3. Ncspot</a></h3>
<p><a href="https://github.com/hrkfdn/ncspot">Ncspot</a> æ˜¯ä¸€ä¸ªç»ˆç«¯è®¿é—®çš„ Spotify å®¢æˆ·ç«¯ï¼Œå°å·§ã€ç®€å•ã€è‰¯å¥½çš„ä»£ç ç»„ç»‡ä»¥åŠå¼‚æ­¥ç¼–ç¨‹ï¼Œå€¼å¾—å­¦ä¹ .</p>
<h3 id="4-å‘½ä»¤è¡Œ-rust"><a class="header" href="#4-å‘½ä»¤è¡Œ-rust">4. å‘½ä»¤è¡Œ Rust</a></h3>
<p><a href="https://github.com/kyclark/command-line-rust">è¿™ä¸ªé¡¹ç›®</a> æ˜¯ä¹¦æœ¬ <code>Command-Line Rust(O'Reily)</code> çš„é…å¥—é¡¹ç›®ï¼Œå¯ä»¥å¸®åŠ©å¤§å®¶ç†è§£è¯¥å¦‚ä½•æ›´å¥½çš„ç¼–å†™å‘½ä»¤è¡Œç¨‹åºï¼Œä¾‹å¦‚ <code>head</code>, <code>cat</code>, <code>ls</code>ã€‚</p>
<h3 id="5-åœ¨-png-ä¸­éšè—ä½ çš„ç§˜å¯†"><a class="header" href="#5-åœ¨-png-ä¸­éšè—ä½ çš„ç§˜å¯†">5. åœ¨ PNG ä¸­éšè—ä½ çš„ç§˜å¯†</a></h3>
<p><a href="https://jrdngr.github.io/pngme_book/">è¿™æœ¬ä¹¦</a> å°†å¸¦é¢†å¤§å®¶ç¼–å†™ä¸€ä¸ªå‘½ä»¤è¡Œç¨‹åºï¼ŒåŠŸèƒ½æ˜¯åœ¨ PNG æ–‡ä»¶ä¸­éšè—ä¸€äº›ç§˜å¯†ä¿¡æ¯ï¼Œé¦–è¦ç›®æ ‡æ˜¯è®©æˆ‘ä»¬ç†Ÿæ‚‰ Rust ä»£ç ã€‚</p>
<h3 id="6-ä½¿ç”¨-rust-å†™ä¸€ä¸ªå°å‹-os"><a class="header" href="#6-ä½¿ç”¨-rust-å†™ä¸€ä¸ªå°å‹-os">6. ä½¿ç”¨ Rust å†™ä¸€ä¸ªå°å‹ OS</a></h3>
<p><a href="https://os.phil-opp.com">è¿™ä¸ªåšå®¢ç³»åˆ—</a> ä¼šå¸¦é¢†å¤§å®¶ä½¿ç”¨ Rust è¯­è¨€åˆ›å»ºä¸€ä¸ªå°å‹çš„æ“ä½œç³»ç»Ÿã€‚å…¶ä¸­æ¯ä¸€ç¯‡æ–‡ç« éƒ½æ˜¯ä¸€ä¸ªå°çš„æ•™ç¨‹å¹¶åŒ…å«å®Œæ•´çš„ä»£ç ã€‚</p>
<p>ä½ ä¹Ÿå¯ä»¥åœ¨<a href="https://github.com/phil-opp/blog_os">ä»¥ä¸‹åœ°å€</a>æ‰¾åˆ°å®Œæ•´çš„æºä»£ç ã€‚</p>
<h3 id="7-codecraftersio-å†™ä¸€ä¸ªä½ è‡ªå·±çš„-git-dockersqlite-æˆ–-redis"><a class="header" href="#7-codecraftersio-å†™ä¸€ä¸ªä½ è‡ªå·±çš„-git-dockersqlite-æˆ–-redis">7. CodeCrafters.io: å†™ä¸€ä¸ªä½ è‡ªå·±çš„ Gitï¼Œ Dockerï¼ŒSQLite æˆ– Redis</a></h3>
<p>åœ¨ <a href="https://codecrafters.io/for/rust">CodeCrafters</a> ä¸Šï¼Œä½ å¯ä»¥ä»å¤´å¼€å§‹é‡æ–°åˆ›å»ºæ‚¨æœ€å–œæ¬¢çš„å¼€å‘äººå‘˜å·¥å…·ã€‚è¿™æ˜¯ä¸€ç§æŒæ¡ Rust çš„å®è·µã€æœ€ä½é™åº¦æŒ‡å¯¼çš„æ–¹æ³•ï¼ŒåŒæ—¶æ¬£èµæˆ‘ä»¬æ¯å¤©ä½¿ç”¨çš„æµè¡ŒæŠ€æœ¯çš„å†…éƒ¨ç»“æ„å’Œæ–‡æ¡£ã€‚</p>
<h3 id="8-mini-redis"><a class="header" href="#8-mini-redis">8. mini-redis</a></h3>
<p><a href="https://github.com/tokio-rs/mini-redis">mini-redis</a> æ˜¯ä¸€ä¸ªä¸å®Œæ•´çš„ Redis å®¢æˆ·ç«¯ã€æœåŠ¡å™¨å®ç°ï¼Œç”± tokio å®˜æ–¹å‡ºå“ï¼Œä»£ç è´¨é‡éå¸¸é«˜ï¼Œè€Œä¸”æœ‰è¯¦ç»†çš„æ³¨é‡Šï¼Œéå¸¸é€‚åˆå­¦ä¹  Rust å’Œå¼‚æ­¥ç¼–ç¨‹ã€‚</p>
<h3 id="9-ä½¿ç”¨-rust-å†™ä¸€ä¸ªè§£æå™¨"><a class="header" href="#9-ä½¿ç”¨-rust-å†™ä¸€ä¸ªè§£æå™¨">9. ä½¿ç”¨ Rust å†™ä¸€ä¸ªè§£æå™¨</a></h3>
<p><a href="https://rust-hosted-langs.github.io/book/">è¿™æœ¬å¼€æºä¹¦</a> æ˜¯ä¸€ä¸ªä½¿ç”¨ Rust è¯­è¨€å®ç°ç¼–è¯‘å‹è¯­è¨€çš„æ•™ç¨‹ã€‚</p>
<h3 id="10-rustç¼–å†™æ¨ç®±å­æ¸¸æˆæ•™ç¨‹"><a class="header" href="#10-rustç¼–å†™æ¨ç®±å­æ¸¸æˆæ•™ç¨‹">10. Rustç¼–å†™æ¨ç®±å­æ¸¸æˆæ•™ç¨‹</a></h3>
<p><a href="https://sokoban.iolivia.me/zh_cn/c01-00-intro">sokoban</a> æ˜¯ä¸€ä¸ªä½¿ç”¨ Rust è¯­è¨€å®ç° sokoban æ¸¸æˆçš„æ•™ç¨‹ã€‚è™½ç„¶ç¤¾åŒºå·²åœæ­¢æ´»è·ƒï¼ˆ Initial Commits on Sep 3, 2019ï¼ŒGitHub ä»“åº“æœ€åä¸€æ¡ commit æ˜¯ last year ï¼‰ï¼Œä½†æ˜¯é¡¹ç›®æ˜¯å®Œå–„çš„ release v0.1.0ï¼Œæ‹¿æ¥ç»ƒæ‰‹æ˜¯ä¸ªä¸é”™çš„é€‰æ‹©ã€‚</p>
<p><strong>To be continued...</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å˜é‡ç»‘å®šä¸è§£æ„"><a class="header" href="#å˜é‡ç»‘å®šä¸è§£æ„">å˜é‡ç»‘å®šä¸è§£æ„</a></h1>
<h3 id="ç»‘å®šå’Œå¯å˜æ€§"><a class="header" href="#ç»‘å®šå’Œå¯å˜æ€§">ç»‘å®šå’Œå¯å˜æ€§</a></h3>
<ol>
<li>ğŸŒŸ å˜é‡åªæœ‰åœ¨åˆå§‹åŒ–åæ‰èƒ½è¢«ä½¿ç”¨</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤ä¸‹é¢ä»£ç çš„é”™è¯¯å¹¶å°½å¯èƒ½å°‘çš„ä¿®æ”¹
fn main() {
    let x: i32; // æœªåˆå§‹åŒ–ï¼Œä½†è¢«ä½¿ç”¨
    let y: i32; // æœªåˆå§‹åŒ–ï¼Œä¹Ÿæœªè¢«ä½¿ç”¨
    println!(&quot;x is equal to {}&quot;, x); 
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ å¯ä»¥ä½¿ç”¨ <code>mut</code> å°†å˜é‡æ ‡è®°ä¸ºå¯å˜</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å®Œå½¢å¡«ç©ºï¼Œè®©ä»£ç ç¼–è¯‘
fn main() {
    let __ = 1;
    __ += 2; 
    
    println!(&quot;x = {}&quot;, x); 
}</code></pre></pre>
<h3 id="å˜é‡ä½œç”¨åŸŸ"><a class="header" href="#å˜é‡ä½œç”¨åŸŸ">å˜é‡ä½œç”¨åŸŸ</a></h3>
<ol start="3">
<li>ğŸŒŸ ä½œç”¨åŸŸæ˜¯ä¸€ä¸ªå˜é‡åœ¨ç¨‹åºä¸­èƒ½å¤Ÿä¿æŒåˆæ³•çš„èŒƒå›´</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤ä¸‹é¢ä»£ç çš„é”™è¯¯å¹¶ä½¿ç”¨å°½å¯èƒ½å°‘çš„æ”¹å˜
fn main() {
    let x: i32 = 10;
    {
        let y: i32 = 5;
        println!(&quot;x çš„å€¼æ˜¯ {}, y çš„å€¼æ˜¯ {}&quot;, x, y);
    }
    println!(&quot;x çš„å€¼æ˜¯ {}, y çš„å€¼æ˜¯ {}&quot;, x, y); 
}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä¿®å¤é”™è¯¯
fn main() {
    println!(&quot;{}, world&quot;, x); 
}

fn define_x() {
    let x = &quot;hello&quot;;
}</code></pre></pre>
<h3 id="å˜é‡é®è”½-shadowing-"><a class="header" href="#å˜é‡é®è”½-shadowing-">å˜é‡é®è”½( Shadowing )</a></h3>
<ol start="5">
<li>ğŸŒŸğŸŒŸ è‹¥åé¢çš„å˜é‡å£°æ˜çš„åç§°å’Œä¹‹å‰çš„å˜é‡ç›¸åŒï¼Œåˆ™æˆ‘ä»¬è¯´ï¼šç¬¬ä¸€ä¸ªå˜é‡è¢«ç¬¬äºŒä¸ªåŒåå˜é‡é®è”½äº†( shadowing )</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// åªå…è®¸ä¿®æ”¹ `assert_eq!` æ¥è®© `println!` å·¥ä½œ(åœ¨ç»ˆç«¯è¾“å‡º `42`)
fn main() {
    let x: i32 = 5;
    {
        let x = 12;
        assert_eq!(x, 5);
    }

    assert_eq!(x, 12);

    let x = 42;
    println!(&quot;{}&quot;, x); // è¾“å‡º &quot;42&quot;.
}</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ ä¿®æ”¹ä¸€è¡Œä»£ç ä»¥é€šè¿‡ç¼–è¯‘</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut x: i32 = 1;
    x = 7;
    // é®è”½ä¸”å†æ¬¡ç»‘å®š
    let x = x; 
    x += 3;


    let y = 4;
    // é®è”½
    let y = &quot;I can also be bound to text!&quot;; 
}</code></pre></pre>
<h3 id="æœªä½¿ç”¨çš„å˜é‡"><a class="header" href="#æœªä½¿ç”¨çš„å˜é‡">æœªä½¿ç”¨çš„å˜é‡</a></h3>
<ol start="7">
<li>ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•æ¥ä¿®å¤ç¼–è¯‘å™¨è¾“å‡ºçš„ warning :</li>
</ol>
<ul>
<li>ğŸŒŸ  ä¸€ç§æ–¹æ³•</li>
<li>ğŸŒŸğŸŒŸ  ä¸¤ç§æ–¹æ³•</li>
</ul>
<blockquote>
<p>æ³¨æ„: ä½ å¯ä»¥ä½¿ç”¨ä¸¤ç§æ–¹æ³•è§£å†³ï¼Œä½†æ˜¯å®ƒä»¬æ²¡æœ‰ä¸€ç§æ˜¯ç§»é™¤ <code>let x = 1</code> æ‰€åœ¨çš„ä»£ç è¡Œ</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let x = 1; 
}

// compiler warning: unused variable: `x`</code></pre></pre>
<h3 id="å˜é‡è§£æ„"><a class="header" href="#å˜é‡è§£æ„">å˜é‡è§£æ„</a></h3>
<ol start="8">
<li>ğŸŒŸğŸŒŸ æˆ‘ä»¬å¯ä»¥å°† <code>let</code> è·Ÿä¸€ä¸ªæ¨¡å¼ä¸€èµ·ä½¿ç”¨æ¥è§£æ„ä¸€ä¸ªå…ƒç»„ï¼Œæœ€ç»ˆå°†å®ƒè§£æ„ä¸ºå¤šä¸ªç‹¬ç«‹çš„å˜é‡</li>
</ol>
<blockquote>
<p>æç¤º: å¯ä»¥ä½¿ç”¨å˜é‡é®è”½æˆ–å¯å˜æ€§</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤ä¸‹é¢ä»£ç çš„é”™è¯¯å¹¶å°½å¯èƒ½å°‘çš„ä¿®æ”¹
fn main() {
    let (x, y) = (1, 2);
    x += 2;

    assert_eq!(x, 3);
    assert_eq!(y, 2);
}</code></pre></pre>
<h3 id="è§£æ„å¼èµ‹å€¼"><a class="header" href="#è§£æ„å¼èµ‹å€¼">è§£æ„å¼èµ‹å€¼</a></h3>
<p>è¯¥åŠŸèƒ½äº Rust 1.59 ç‰ˆæœ¬å¼•å…¥ï¼šä½ å¯ä»¥åœ¨èµ‹å€¼è¯­å¥çš„å·¦å¼ä¸­ä½¿ç”¨å…ƒç»„ã€åˆ‡ç‰‡æˆ–ç»“æ„ä½“è¿›è¡ŒåŒ¹é…èµ‹å€¼ã€‚</p>
<ol start="9">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<blockquote>
<p>Note: è§£æ„å¼èµ‹å€¼åªèƒ½åœ¨ Rust 1.59 æˆ–è€…æ›´é«˜ç‰ˆæœ¬ä¸­ä½¿ç”¨</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let (x, y);
    (x,..) = (3, 4);
    [.., y] = [1, 2];
    // å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œ
    assert_eq!([x,y], __);
} </code></pre></pre>
<blockquote>
<p><a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/variables.md">ç­”æ¡ˆ</a> åœ¨ solutions ä¸‹é¢</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="åŸºæœ¬ç±»å‹"><a class="header" href="#åŸºæœ¬ç±»å‹">åŸºæœ¬ç±»å‹</a></h1>
<p>å­¦ä¹ èµ„æ–™: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html">Rust Book 3.2 and 3.3</a></li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/base-type/index.html">Rustè¯­è¨€åœ£ç» - åŸºæœ¬ç±»å‹</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ•°å€¼ç±»å‹"><a class="header" href="#æ•°å€¼ç±»å‹">æ•°å€¼ç±»å‹</a></h1>
<h3 id="æ•´æ•°"><a class="header" href="#æ•´æ•°">æ•´æ•°</a></h3>
<ol>
<li>ğŸŒŸ </li>
</ol>
<blockquote>
<p>Tips: å¦‚æœæˆ‘ä»¬æ²¡æœ‰æ˜¾å¼çš„ç»™äºˆå˜é‡ä¸€ä¸ªç±»å‹ï¼Œé‚£ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å¸®æˆ‘ä»¬æ¨å¯¼ä¸€ä¸ªç±»å‹</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ç§»é™¤æŸä¸ªéƒ¨åˆ†è®©ä»£ç å·¥ä½œ
fn main() {
    let x: i32 = 5;
    let mut y: u32 = 5;

    y = x;
    
    let z = 10; // è¿™é‡Œ z çš„ç±»å‹æ˜¯? 
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn main() {
    let v: u16 = 38_u8 as __;
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ </li>
</ol>
<blockquote>
<p>Tips: å¦‚æœæˆ‘ä»¬æ²¡æœ‰æ˜¾å¼çš„ç»™äºˆå˜é‡ä¸€ä¸ªç±»å‹ï¼Œé‚£ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å¸®æˆ‘ä»¬æ¨å¯¼ä¸€ä¸ªç±»å‹</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®æ”¹ `assert_eq!` è®©ä»£ç å·¥ä½œ
fn main() {
    let x = 5;
    assert_eq!(&quot;u32&quot;.to_string(), type_of(&amp;x));
}

// ä»¥ä¸‹å‡½æ•°å¯ä»¥è·å–ä¼ å…¥å‚æ•°çš„ç±»å‹ï¼Œå¹¶è¿”å›ç±»å‹çš„å­—ç¬¦ä¸²å½¢å¼ï¼Œä¾‹å¦‚  &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;
fn type_of&lt;T&gt;(_: &amp;T) -&gt; String {
    format!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;())
}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œ
fn main() {
    assert_eq!(i8::MAX, __); 
    assert_eq!(u8::MAX, __); 
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// è§£å†³ä»£ç ä¸­çš„é”™è¯¯å’Œ `panic`
fn main() {
   let v1 = 251_u8 + 8;
   let v2 = i8::checked_add(251, 8).unwrap();
   println!(&quot;{},{}&quot;,v1,v2);
}</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®æ”¹ `assert!` è®©ä»£ç å·¥ä½œ
fn main() {
    let v = 1_024 + 0xff + 0o77 + 0b1111_1111;
    assert!(v == 1579);
}</code></pre></pre>
<h3 id="æµ®ç‚¹æ•°"><a class="header" href="#æµ®ç‚¹æ•°">æµ®ç‚¹æ•°</a></h3>
<ol start="7">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å°† ? æ›¿æ¢æˆä½ çš„ç­”æ¡ˆ
fn main() {
    let x = 1_000.000_1; // ?
    let y: f32 = 0.12; // f32
    let z = 0.01_f64; // f64
}</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ ä½¿ç”¨ä¸¤ç§æ–¹æ³•æ¥è®©ä¸‹é¢ä»£ç å·¥ä½œ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    assert!(0.1+0.2==0.3);
}</code></pre></pre>
<h3 id="åºåˆ—range"><a class="header" href="#åºåˆ—range">åºåˆ—Range</a></h3>
<ol start="9">
<li>ğŸŒŸğŸŒŸ ä¸¤ä¸ªç›®æ ‡: 1. ä¿®æ”¹ <code>assert!</code> è®©å®ƒå·¥ä½œ 2. è®© <code>println!</code> è¾“å‡º: 97 - 122</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut sum = 0;
    for i in -3..2 {
        sum += i
    }

    assert!(sum == -3);

    for c in 'a'..='z' {
        println!(&quot;{}&quot;,c);
    }
}</code></pre></pre>
<ol start="10">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
use std::ops::{Range, RangeInclusive};
fn main() {
    assert_eq!((1..__), Range{ start: 1, end: 5 });
    assert_eq!((1..__), RangeInclusive::new(1, 5));
}</code></pre></pre>
<h3 id="è®¡ç®—"><a class="header" href="#è®¡ç®—">è®¡ç®—</a></h3>
<ol start="11">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºï¼Œå¹¶è§£å†³é”™è¯¯
fn main() {
    // æ•´æ•°åŠ æ³•
    assert!(1u32 + 2 == __);

    // æ•´æ•°å‡æ³•
    assert!(1i32 - 2 == __);
    assert!(1u8 - 2 == -1);
    
    assert!(3 * 50 == __);

    assert!(9.6 / 3.2 == 3.0); // error ! ä¿®æ”¹å®ƒè®©ä»£ç å·¥ä½œ

    assert!(24 % 5 == __);
    
    // é€»è¾‘ä¸æˆ–éæ“ä½œ
    assert!(true &amp;&amp; false == __);
    assert!(true || false == __);
    assert!(!true == __);

    // ä½æ“ä½œ
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/basic-types/numbers.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å­—ç¬¦å¸ƒå°”å•å…ƒç±»å‹"><a class="header" href="#å­—ç¬¦å¸ƒå°”å•å…ƒç±»å‹">å­—ç¬¦ã€å¸ƒå°”ã€å•å…ƒç±»å‹</a></h1>
<h3 id="å­—ç¬¦"><a class="header" href="#å­—ç¬¦">å­—ç¬¦</a></h3>
<ol>
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä¿®æ”¹2å¤„ `assert_eq!` è®©ä»£ç å·¥ä½œ

use std::mem::size_of_val;
fn main() {
    let c1 = 'a';
    assert_eq!(size_of_val(&amp;c1),1); 

    let c2 = 'ä¸­';
    assert_eq!(size_of_val(&amp;c2),3); 

    println!(&quot;Success!&quot;)
} </code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä¿®æ”¹ä¸€è¡Œè®©ä»£ç æ­£å¸¸æ‰“å°
fn main() {
    let c1 = &quot;ä¸­&quot;;
    print_char(c1);
} 

fn print_char(c : char) {
    println!(&quot;{}&quot;, c);
}</code></pre></pre>
<h3 id="å¸ƒå°”"><a class="header" href="#å¸ƒå°”">å¸ƒå°”</a></h3>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä½¿æˆåŠŸæ‰“å°
fn main() {
    let _f: bool = false;

    let t = true;
    if !t {
        println!(&quot;Success!&quot;)
    }
} </code></pre></pre>
<ol start="4">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let f = true;
    let t = true &amp;&amp; false;
    assert_eq!(t, f);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="å•å…ƒç±»å‹"><a class="header" href="#å•å…ƒç±»å‹">å•å…ƒç±»å‹</a></h3>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// è®©ä»£ç å·¥ä½œï¼Œä½†ä¸è¦ä¿®æ”¹ `implicitly_ret_unit` !
fn main() {
    let _v: () = ();

    let v = (2, 3);
    assert_eq!(v, implicitly_ret_unit());

    println!(&quot;Success!&quot;)
}

fn implicitly_ret_unit() {
    println!(&quot;I will return a ()&quot;)
}

// ä¸è¦ä½¿ç”¨ä¸‹é¢çš„å‡½æ•°ï¼Œå®ƒåªç”¨äºæ¼”ç¤ºï¼
fn explicitly_ret_unit() -&gt; () {
    println!(&quot;I will return a ()&quot;)
}</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ å•å…ƒç±»å‹å ç”¨çš„å†…å­˜å¤§å°æ˜¯å¤šå°‘ï¼Ÿ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// è®©ä»£ç å·¥ä½œï¼šä¿®æ”¹ `assert!` ä¸­çš„ `4` 
use std::mem::size_of_val;
fn main() {
    let unit: () = ();
    assert!(size_of_val(&amp;unit) == 4);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/basic-types/char-bool.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è¯­å¥ä¸è¡¨è¾¾å¼"><a class="header" href="#è¯­å¥ä¸è¡¨è¾¾å¼">è¯­å¥ä¸è¡¨è¾¾å¼</a></h1>
<h3 id="ç¤ºä¾‹"><a class="header" href="#ç¤ºä¾‹">ç¤ºä¾‹</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // ä¸‹é¢è¡¨è¾¾å¼çš„å€¼å°†è¢«èµ‹ç»™ `y`
        x_cube + x_squared + x
    };

    let z = {
        // åˆ†å·è®©è¡¨è¾¾å¼å˜æˆäº†è¯­å¥ï¼Œå› æ­¤è¿”å›çš„ä¸å†æ˜¯è¡¨è¾¾å¼ `2 * x` çš„å€¼ï¼Œè€Œæ˜¯è¯­å¥çš„å€¼ `()`
        2 * x;
    };

    println!(&quot;x is {:?}&quot;, x);
    println!(&quot;y is {:?}&quot;, y);
    println!(&quot;z is {:?}&quot;, z);
}</code></pre></pre>
<h3 id="ç»ƒä¹ "><a class="header" href="#ç»ƒä¹ ">ç»ƒä¹ </a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä½¿ç”¨ä¸¤ç§æ–¹æ³•è®©ä»£ç å·¥ä½œèµ·æ¥
fn main() {
   let v = {
       let mut x = 1;
       x += 2
   };

   assert_eq!(v, 3);
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let v = (let x = 3);

   assert!(v == 3);
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = sum(1 , 2);
    assert_eq!(s, 3);
}

fn sum(x: i32, y: i32) -&gt; i32 {
    x + y;
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/basic-types/statements.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å‡½æ•°"><a class="header" href="#å‡½æ•°">å‡½æ•°</a></h1>
<ol>
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // ä¸è¦ä¿®æ”¹ä¸‹é¢ä¸¤è¡Œä»£ç !
    let (x, y) = (1, 2);
    let s = sum(x, y);

    assert_eq!(s, 3);
}

fn sum(x, y: i32) {
    x + y;
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   print();
}

// ä½¿ç”¨å¦ä¸€ä¸ªç±»å‹æ¥æ›¿ä»£ i32
fn print() -&gt; i32 {
   println!(&quot;hello,world&quot;);
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ç”¨ä¸¤ç§æ–¹æ³•æ±‚è§£
fn main() {
    never_return();
}

fn never_return() -&gt; ! {
    // å®ç°è¿™ä¸ªå‡½æ•°ï¼Œä¸è¦ä¿®æ”¹å‡½æ•°ç­¾å!
    
}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ å‘æ•£å‡½æ•°( Diverging function )ä¸ä¼šè¿”å›ä»»ä½•å€¼ï¼Œå› æ­¤å®ƒä»¬å¯ä»¥ç”¨äºæ›¿ä»£éœ€è¦è¿”å›ä»»ä½•å€¼çš„åœ°æ–¹</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    println!(&quot;Success!&quot;);
}

fn get_option(tp: u8) -&gt; Option&lt;i32&gt; {
    match tp {
        1 =&gt; {
            // TODO
        }
        _ =&gt; {
            // TODO
        }
    };
    
    // è¿™é‡Œä¸å…¶è¿”å›ä¸€ä¸ª Noneï¼Œä¸å¦‚ä½¿ç”¨å‘æ•£å‡½æ•°æ›¿ä»£
    never_return_fn()
}

// ä½¿ç”¨ä¸‰ç§æ–¹æ³•å®ç°ä»¥ä¸‹å‘æ•£å‡½æ•°
fn never_return_fn() -&gt; ! {
    
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // å¡«ç©º
    let b = __;

    let _v = match b {
        true =&gt; 1,
        // å‘æ•£å‡½æ•°ä¹Ÿå¯ä»¥ç”¨äº `match` è¡¨è¾¾å¼ï¼Œç”¨äºæ›¿ä»£ä»»ä½•ç±»å‹çš„å€¼
        false =&gt; {
            println!(&quot;Success!&quot;);
            panic!(&quot;we have no value for `false`, but we can panic&quot;)
        }
    };

    println!(&quot;Exercise Failed if printing out this line!&quot;);
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/basic-types/functions.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ‰€æœ‰æƒä¸å€Ÿç”¨"><a class="header" href="#æ‰€æœ‰æƒä¸å€Ÿç”¨">æ‰€æœ‰æƒä¸å€Ÿç”¨</a></h1>
<p>å­¦ä¹ èµ„æ–™ : </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Rust Book 4.1-4.4</a></li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/ownership/index.html">Rustè¯­è¨€åœ£ç» - æ‰€æœ‰æƒä¸å€Ÿç”¨</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ‰€æœ‰æƒ"><a class="header" href="#æ‰€æœ‰æƒ">æ‰€æœ‰æƒ</a></h1>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // ä½¿ç”¨å°½å¯èƒ½å¤šçš„æ–¹æ³•æ¥é€šè¿‡ç¼–è¯‘
    let x = String::from(&quot;hello, world&quot;);
    let y = x;
    println!(&quot;{},{}&quot;,x,y);
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä¸è¦ä¿®æ”¹ main ä¸­çš„ä»£ç 
fn main() {
    let s1 = String::from(&quot;hello, world&quot;);
    let s2 = take_ownership(s1);

    println!(&quot;{}&quot;, s2);
}

// åªèƒ½ä¿®æ”¹ä¸‹é¢çš„ä»£ç !
fn take_ownership(s: String) {
    println!(&quot;{}&quot;, s);
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = give_ownership();
    println!(&quot;{}&quot;, s);
}

// åªèƒ½ä¿®æ”¹ä¸‹é¢çš„ä»£ç !
fn give_ownership() -&gt; String {
    let s = String::from(&quot;hello, world&quot;);
    // convert String to Vec
    // å°† String è½¬æ¢æˆ Vec ç±»å‹
    let _s = s.into_bytes();
    s
}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä¿®å¤é”™è¯¯ï¼Œä¸è¦åˆ é™¤ä»»ä½•ä»£ç è¡Œ
fn main() {
    let s = String::from(&quot;hello, world&quot;);

    print_str(s);

    println!(&quot;{}&quot;, s);
}

fn print_str(s: String)  {
    println!(&quot;{}&quot;,s)
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä¸è¦ä½¿ç”¨ cloneï¼Œä½¿ç”¨ copy çš„æ–¹å¼æ›¿ä»£
fn main() {
    let x = (1, 2, (), &quot;hello&quot;.to_string());
    let y = x.clone();
    println!(&quot;{:?}, {:?}&quot;, x, y);
}</code></pre></pre>
<h4 id="å¯å˜æ€§"><a class="header" href="#å¯å˜æ€§">å¯å˜æ€§</a></h4>
<p>å½“æ‰€æœ‰æƒè½¬ç§»æ—¶ï¼Œå¯å˜æ€§ä¹Ÿå¯ä»¥éšä¹‹æ”¹å˜ã€‚</p>
<ol start="6">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = String::from(&quot;hello, &quot;);
    
    // åªä¿®æ”¹ä¸‹é¢è¿™è¡Œä»£ç  !
    let s1 = s;

    s1.push_str(&quot;world&quot;)
}</code></pre></pre>
<ol start="7">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let x = Box::new(5);
    
    let ...      // å®Œæˆè¯¥è¡Œä»£ç ï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒè¡Œï¼
    
    *y = 4;
    
    assert_eq!(*x, 5);
}</code></pre></pre>
<h3 id="éƒ¨åˆ†-move"><a class="header" href="#éƒ¨åˆ†-move">éƒ¨åˆ† move</a></h3>
<p>å½“è§£æ„ä¸€ä¸ªå˜é‡æ—¶ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ <code>move</code> å’Œå¼•ç”¨æ¨¡å¼ç»‘å®šçš„æ–¹å¼ã€‚å½“è¿™ä¹ˆåšæ—¶ï¼Œéƒ¨åˆ† <code>move</code> å°±ä¼šå‘ç”Ÿï¼šå˜é‡ä¸­ä¸€éƒ¨åˆ†çš„æ‰€æœ‰æƒè¢«è½¬ç§»ç»™å…¶å®ƒå˜é‡ï¼Œè€Œå¦ä¸€éƒ¨åˆ†æˆ‘ä»¬è·å–äº†å®ƒçš„å¼•ç”¨ã€‚</p>
<p>åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒåŸå˜é‡å°†æ— æ³•å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯å®ƒæ²¡æœ‰è½¬ç§»æ‰€æœ‰æƒçš„é‚£ä¸€éƒ¨åˆ†ä¾ç„¶å¯ä»¥ä½¿ç”¨ï¼Œä¹Ÿå°±æ˜¯ä¹‹å‰è¢«å¼•ç”¨çš„é‚£éƒ¨åˆ†ã€‚</p>
<h4 id="ç¤ºä¾‹-1"><a class="header" href="#ç¤ºä¾‹-1">ç¤ºä¾‹</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box&lt;u8&gt;,
    }

    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: Box::new(20),
    };

    // é€šè¿‡è¿™ç§è§£æ„å¼æ¨¡å¼åŒ¹é…ï¼Œperson.name çš„æ‰€æœ‰æƒè¢«è½¬ç§»ç»™æ–°çš„å˜é‡ `name`
    // ä½†æ˜¯ï¼Œè¿™é‡Œ `age` å˜é‡å´æ˜¯å¯¹ person.age çš„å¼•ç”¨, è¿™é‡Œ ref çš„ä½¿ç”¨ç›¸å½“äº: let age = &amp;person.age 
    let Person { name, ref age } = person;

    println!(&quot;The person's age is {}&quot;, age);

    println!(&quot;The person's name is {}&quot;, name);

    // Error! åŸå› æ˜¯ person çš„ä¸€éƒ¨åˆ†å·²ç»è¢«è½¬ç§»äº†æ‰€æœ‰æƒï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•å†ä½¿ç”¨å®ƒ
    //println!(&quot;The person struct is {:?}&quot;, person);

    // è™½ç„¶ `person` ä½œä¸ºä¸€ä¸ªæ•´ä½“æ— æ³•å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯ `person.age` ä¾ç„¶å¯ä»¥ä½¿ç”¨
    println!(&quot;The person's age from person struct is {}&quot;, person.age);
}</code></pre></pre>
<h4 id="ç»ƒä¹ -1"><a class="header" href="#ç»ƒä¹ -1">ç»ƒä¹ </a></h4>
<ol start="8">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));

   let _s = t.0;

   // ä»…ä¿®æ”¹ä¸‹é¢è¿™è¡Œä»£ç ï¼Œä¸”ä¸è¦ä½¿ç”¨ `_s`
   println!(&quot;{:?}&quot;, t);
}</code></pre></pre>
<ol start="9">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));

   // å¡«ç©ºï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç 
   let (__, __) = __;

   println!(&quot;{:?}, {:?}, {:?}&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/ownership/ownership.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å¼•ç”¨å’Œå€Ÿç”¨"><a class="header" href="#å¼•ç”¨å’Œå€Ÿç”¨">å¼•ç”¨å’Œå€Ÿç”¨</a></h1>
<h3 id="å¼•ç”¨"><a class="header" href="#å¼•ç”¨">å¼•ç”¨</a></h3>
<ol>
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let x = 5;
   // å¡«å†™ç©ºç™½å¤„
   let p = __;

   println!(&quot;x çš„å†…å­˜åœ°å€æ˜¯ {:p}&quot;, p); // output: 0x16fa3ac84
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let x = 5;
    let y = &amp;x;

    // åªèƒ½ä¿®æ”¹ä»¥ä¸‹è¡Œ
    assert_eq!(5, y);
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    borrow_object(s)
}

fn borrow_object(s: &amp;String) {}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    push_str(s)
}

fn push_str(s: &amp;mut String) {
    s.push_str(&quot;world&quot;)
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    // å¡«å†™ç©ºç™½å¤„ï¼Œè®©ä»£ç å·¥ä½œ
    let p = __;
    
    p.push_str(&quot;world&quot;);
}</code></pre></pre>
<h4 id="ref"><a class="header" href="#ref">ref</a></h4>
<p><code>ref</code> ä¸ <code>&amp;</code> ç±»ä¼¼ï¼Œå¯ä»¥ç”¨æ¥è·å–ä¸€ä¸ªå€¼çš„å¼•ç”¨ï¼Œä½†æ˜¯å®ƒä»¬çš„ç”¨æ³•æœ‰æ‰€ä¸åŒã€‚</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let c = 'ä¸­';

    let r1 = &amp;c;
    // å¡«å†™ç©ºç™½å¤„ï¼Œä½†æ˜¯ä¸è¦ä¿®æ”¹å…¶å®ƒè¡Œçš„ä»£ç 
    let __ r2 = c;

    assert_eq!(*r1, *r2);
    
    // åˆ¤æ–­ä¸¤ä¸ªå†…å­˜åœ°å€çš„å­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰
    assert_eq!(get_addr(r1),get_addr(r2));
}

// è·å–ä¼ å…¥å¼•ç”¨çš„å†…å­˜åœ°å€çš„å­—ç¬¦ä¸²å½¢å¼
fn get_addr(r: &amp;char) -&gt; String {
    format!(&quot;{:p}&quot;, r)
}</code></pre></pre>
<h3 id="å€Ÿç”¨è§„åˆ™"><a class="header" href="#å€Ÿç”¨è§„åˆ™">å€Ÿç”¨è§„åˆ™</a></h3>
<ol start="7">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ç§»é™¤ä»£ç æŸä¸ªéƒ¨åˆ†ï¼Œè®©å®ƒå·¥ä½œ
// ä½ ä¸èƒ½ç§»é™¤æ•´è¡Œçš„ä»£ç ï¼
fn main() {
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
}</code></pre></pre>
<h4 id="å¯å˜æ€§-1"><a class="header" href="#å¯å˜æ€§-1">å¯å˜æ€§</a></h4>
<ol start="8">
<li>ğŸŒŸ é”™è¯¯: ä»ä¸å¯å˜å¯¹è±¡å€Ÿç”¨å¯å˜</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // é€šè¿‡ä¿®æ”¹ä¸‹é¢ä¸€è¡Œä»£ç æ¥ä¿®å¤é”™è¯¯
    let  s = String::from(&quot;hello, &quot;);

    borrow_object(&amp;mut s)
}

fn borrow_object(s: &amp;mut String) {}</code></pre></pre>
<ol start="9">
<li>ğŸŒŸğŸŒŸ Ok: ä»å¯å˜å¯¹è±¡å€Ÿç”¨ä¸å¯å˜</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¸‹é¢çš„ä»£ç æ²¡æœ‰ä»»ä½•é”™è¯¯
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    borrow_object(&amp;s);
    
    s.push_str(&quot;world&quot;);
}

fn borrow_object(s: &amp;String) {}</code></pre></pre>
<h3 id="nll"><a class="header" href="#nll">NLL</a></h3>
<ol start="10">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// æ³¨é‡Šæ‰ä¸€è¡Œä»£ç è®©å®ƒå·¥ä½œ
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    let r1 = &amp;mut s;
    r1.push_str(&quot;world&quot;);
    let r2 = &amp;mut s;
    r2.push_str(&quot;!&quot;);
    
    println!(&quot;{}&quot;,r1);
}</code></pre></pre>
<ol start="11">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    // åœ¨ä¸‹é¢å¢åŠ ä¸€è¡Œä»£ç äººä¸ºåˆ¶é€ ç¼–è¯‘é”™è¯¯ï¼šcannot borrow `s` as mutable more than once at a time
    // ä½ ä¸èƒ½åŒæ—¶ä½¿ç”¨ r1 å’Œ r2
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/ownership/borrowing.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å¤åˆç±»å‹"><a class="header" href="#å¤åˆç±»å‹">å¤åˆç±»å‹</a></h1>
<p>å­¦ä¹ èµ„æ–™: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch04-03-slices.html">Rust Book 4.3, 5.1, 6.1, 8.2</a></li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/compound-type/intro.html">Rustè¯­è¨€åœ£ç» - å¤åˆç±»å‹</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å­—ç¬¦ä¸²"><a class="header" href="#å­—ç¬¦ä¸²">å­—ç¬¦ä¸²</a></h1>
<p>å­—ç¬¦ä¸²å­—é¢é‡çš„ç±»å‹æ˜¯ <code>&amp;str</code>ï¼Œ ä¾‹å¦‚ <code>let s: &amp;str = &quot;hello, world&quot;</code> ä¸­çš„ <code>&quot;hello, world&quot;</code> çš„ç±»å‹å°±æ˜¯ <code>&amp;str</code>ã€‚</p>
<h3 id="str-å’Œ-str"><a class="header" href="#str-å’Œ-str"><code>str</code> å’Œ <code>&amp;str</code></a></h3>
<ol>
<li>ğŸŒŸ æ­£å¸¸æƒ…å†µä¸‹æˆ‘ä»¬æ— æ³•ä½¿ç”¨ <code>str</code> ç±»å‹ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨ <code>&amp;str</code> æ¥æ›¿ä»£</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯ï¼Œä¸è¦æ–°å¢ä»£ç è¡Œ
fn main() {
    let s: str = &quot;hello, world&quot;;
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ å¦‚æœè¦ä½¿ç”¨ <code>str</code> ç±»å‹ï¼Œåªèƒ½é…åˆ <code>Box</code>ã€‚  <code>&amp;</code> å¯ä»¥ç”¨æ¥å°† <code>Box&lt;str&gt;</code> è½¬æ¢ä¸º <code>&amp;str</code> ç±»å‹</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä½¿ç”¨è‡³å°‘ä¸¤ç§æ–¹æ³•æ¥ä¿®å¤é”™è¯¯
fn main() {
    let s: Box&lt;str&gt; = &quot;hello, world&quot;.into();
    greetings(s)
}

fn greetings(s: &amp;str) {
    println!(&quot;{}&quot;,s)
}</code></pre></pre>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<p><code>String</code> æ˜¯å®šä¹‰åœ¨æ ‡å‡†åº“ä¸­çš„ç±»å‹ï¼Œåˆ†é…åœ¨å †ä¸Šï¼Œå¯ä»¥åŠ¨æ€çš„å¢é•¿ã€‚å®ƒçš„åº•å±‚å­˜å‚¨æ˜¯åŠ¨æ€å­—èŠ‚æ•°ç»„çš„æ–¹å¼( <code>Vec&lt;u8&gt;</code> )ï¼Œä½†æ˜¯ä¸å­—èŠ‚æ•°ç»„ä¸åŒï¼Œ<code>String</code> æ˜¯ <code>UTF-8</code> ç¼–ç ã€‚</p>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn main() {
    let mut s = __;
    s.push_str(&quot;hello, world&quot;);
    s.push('!');

    assert_eq!(s, &quot;hello, world!&quot;);
}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤æ‰€æœ‰é”™è¯¯ï¼Œå¹¶ä¸”ä¸è¦æ–°å¢ä»£ç è¡Œ
fn main() {
    let  s = String::from(&quot;hello&quot;);
    s.push(',');
    s.push(&quot; world&quot;);
    s += &quot;!&quot;.to_string();

    println!(&quot;{}&quot;, s)
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ æˆ‘ä»¬å¯ä»¥ç”¨ <code>replace</code> æ–¹æ³•æ¥æ›¿æ¢æŒ‡å®šçš„å­å­—ç¬¦ä¸²</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn main() {
    let s = String::from(&quot;I like dogs&quot;);
    // ä»¥ä¸‹æ–¹æ³•ä¼šé‡æ–°åˆ†é…ä¸€å—å†…å­˜ç©ºé—´ï¼Œç„¶åå°†ä¿®æ”¹åçš„å­—ç¬¦ä¸²å­˜åœ¨è¿™é‡Œ
    let s1 = s.__(&quot;dogs&quot;, &quot;cats&quot;);

    assert_eq!(s1, &quot;I like cats&quot;)
}</code></pre></pre>
<p>åœ¨æ ‡å‡†åº“çš„ <a href="https://doc.rust-lang.org/std/string/struct.String.html">String</a> æ¨¡å—ä¸­ï¼Œæœ‰æ›´å¤šçš„å®ç”¨æ–¹æ³•ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥çœ‹çœ‹ã€‚</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸ ä½ åªèƒ½å°† <code>String</code> è·Ÿ <code>&amp;str</code> ç±»å‹è¿›è¡Œæ‹¼æ¥ï¼Œå¹¶ä¸” <code>String</code> çš„æ‰€æœ‰æƒåœ¨æ­¤è¿‡ç¨‹ä¸­ä¼šè¢« move</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤æ‰€æœ‰é”™è¯¯ï¼Œä¸è¦åˆ é™¤ä»»ä½•ä¸€è¡Œä»£ç 
fn main() {
    let s1 = String::from(&quot;hello,&quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + s2; 
    assert_eq!(s3,&quot;hello,world!&quot;);
    println!(&quot;{}&quot;,s1);
}</code></pre></pre>
<h3 id="str-å’Œ-string"><a class="header" href="#str-å’Œ-string"><code>&amp;str</code> å’Œ <code>String</code></a></h3>
<p>ä¸ <code>str</code> çš„å¾ˆå°‘ä½¿ç”¨ç›¸æ¯”ï¼Œ<code>&amp;str</code> å’Œ <code>String</code> ç±»å‹å´éå¸¸å¸¸ç”¨ï¼Œå› æ­¤ä¹Ÿéå¸¸é‡è¦ã€‚</p>
<ol start="7">
<li>ğŸŒŸğŸŒŸ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸¤ç§æ–¹æ³•å°† <code>&amp;str</code> è½¬æ¢æˆ <code>String</code> ç±»å‹</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä½¿ç”¨è‡³å°‘ä¸¤ç§æ–¹æ³•æ¥ä¿®å¤é”™è¯¯
fn main() {
    let s = &quot;hello, world&quot;;
    greetings(s)
}

fn greetings(s: String) {
    println!(&quot;{}&quot;,s)
}</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ <code>String::from</code> æˆ– <code>to_string</code> å°† <code>&amp;str</code> è½¬æ¢æˆ <code>String</code> ç±»å‹</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä½¿ç”¨ä¸¤ç§æ–¹æ³•æ¥è§£å†³é”™è¯¯ï¼Œä¸è¦æ–°å¢ä»£ç è¡Œ
fn main() {
    let s = &quot;hello, world&quot;.to_string();
    let s1: &amp;str = s;
}</code></pre></pre>
<h3 id="å­—ç¬¦ä¸²è½¬ä¹‰"><a class="header" href="#å­—ç¬¦ä¸²è½¬ä¹‰">å­—ç¬¦ä¸²è½¬ä¹‰</a></h3>
<ol start="9">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // ä½ å¯ä»¥ä½¿ç”¨è½¬ä¹‰çš„æ–¹å¼æ¥è¾“å‡ºæƒ³è¦çš„å­—ç¬¦ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨åå…­è¿›åˆ¶çš„å€¼ï¼Œä¾‹å¦‚ \x73 ä¼šè¢«è½¬ä¹‰æˆå°å†™å­—æ¯ 's'
    // å¡«ç©ºä»¥è¾“å‡º &quot;I'm writing Rust&quot;
    let byte_escape = &quot;I'm writing Ru\x73__!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // ä¹Ÿå¯ä»¥ä½¿ç”¨ Unicode å½¢å¼çš„è½¬ä¹‰å­—ç¬¦
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );

    // è¿˜èƒ½ä½¿ç”¨ \ æ¥è¿æ¥å¤šè¡Œå­—ç¬¦ä¸²
    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here \
                         can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}</code></pre></pre>
<ol start="10">
<li>ğŸŒŸğŸŒŸğŸŒŸ æœ‰æ—¶å€™éœ€è¦è½¬ä¹‰çš„å­—ç¬¦å¾ˆå¤šï¼Œæˆ‘ä»¬ä¼šå¸Œæœ›ä½¿ç”¨æ›´æ–¹ä¾¿çš„æ–¹å¼æ¥ä¹¦å†™å­—ç¬¦ä¸²: raw string.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* å¡«ç©ºå¹¶ä¿®å¤æ‰€æœ‰é”™è¯¯ */
fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    // ä¿®æ”¹ä¸Šé¢çš„è¡Œè®©ä»£ç å·¥ä½œ
    assert_eq!(raw_str, &quot;Escapes don't work here: ? â„&quot;);

    // å¦‚æœä½ å¸Œæœ›åœ¨å­—ç¬¦ä¸²ä¸­ä½¿ç”¨åŒå¼•å·ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å½¢å¼
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // å¦‚æœå¸Œæœ›åœ¨å­—ç¬¦ä¸²ä¸­ä½¿ç”¨ # å·ï¼Œå¯ä»¥å¦‚ä¸‹ä½¿ç”¨ï¼š
    let  delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, delimiter);

    // å¡«ç©º
    let long_delimiter = __;
    assert_eq!(long_delimiter, &quot;Hello, \&quot;##\&quot;&quot;)
}</code></pre></pre>
<h3 id="å­—èŠ‚å­—ç¬¦ä¸²"><a class="header" href="#å­—èŠ‚å­—ç¬¦ä¸²">å­—èŠ‚å­—ç¬¦ä¸²</a></h3>
<p>æƒ³è¦ä¸€ä¸ªé UTF-8 å½¢å¼çš„å­—ç¬¦ä¸²å—(æˆ‘ä»¬ä¹‹å‰çš„ <code>str</code>, <code>&amp;str</code>, <code>String</code> éƒ½æ˜¯ UTF-8 å­—ç¬¦ä¸²) ? å¯ä»¥è¯•è¯•å­—èŠ‚å­—ç¬¦ä¸²æˆ–è€…è¯´å­—èŠ‚æ•°ç»„:</p>
<p><strong>ç¤ºä¾‹</strong>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str;

fn main() {
    // æ³¨æ„ï¼Œè¿™å¹¶ä¸æ˜¯ `&amp;str` ç±»å‹äº†ï¼
    let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;;


    // å­—èŠ‚æ•°ç»„æ²¡æœ‰å®ç° `Display` ç‰¹å¾ï¼Œå› æ­¤åªèƒ½ä½¿ç”¨ `Debug` çš„æ–¹å¼å»æ‰“å°
    println!(&quot;A byte string: {:?}&quot;, bytestring);

    // å­—èŠ‚æ•°ç»„ä¹Ÿå¯ä»¥ä½¿ç”¨è½¬ä¹‰
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...ä½†æ˜¯ä¸æ”¯æŒ unicode è½¬ä¹‰
    // let escaped = b&quot;\u{211D} is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // raw string
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // å°†å­—èŠ‚æ•°ç»„è½¬æˆ `str` ç±»å‹å¯èƒ½ä¼šå¤±è´¥
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // å­—èŠ‚æ•°ç»„å¯ä»¥ä¸æ˜¯ UTF-8 æ ¼å¼
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;; // &quot;ã‚ˆã†ã“ã&quot; in SHIFT-JIS

    // ä½†æ˜¯å®ƒä»¬æœªå¿…èƒ½è½¬æ¢æˆ `str` ç±»å‹
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}</code></pre></pre>
<p>å¦‚æœå¤§å®¶æƒ³è¦äº†è§£æ›´å¤šå…³äºå­—ç¬¦ä¸²å­—é¢é‡ã€è½¬ä¹‰å­—ç¬¦çš„è¯ï¼Œå¯ä»¥çœ‹çœ‹ Rust Reference çš„ <a href="https://doc.rust-lang.org/reference/tokens.html">'Tokens' ç« èŠ‚</a>.</p>
<h3 id="å­—ç¬¦ä¸²ç´¢å¼•string-index"><a class="header" href="#å­—ç¬¦ä¸²ç´¢å¼•string-index">å­—ç¬¦ä¸²ç´¢å¼•string index</a></h3>
<ol start="11">
<li>ğŸŒŸğŸŒŸ ä½ æ— æ³•é€šè¿‡ç´¢å¼•çš„æ–¹å¼å»è®¿é—®å­—ç¬¦ä¸²ä¸­çš„æŸä¸ªå­—ç¬¦ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨åˆ‡ç‰‡çš„æ–¹å¼ <code>&amp;s1[start..end]</code> ï¼Œä½†æ˜¯<code>start</code> å’Œ <code>end</code> å¿…é¡»å‡†ç¡®è½åœ¨å­—ç¬¦çš„è¾¹ç•Œå¤„.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s1 = String::from(&quot;hi,ä¸­å›½&quot;);
    let h = s1[0]; // ä¿®æ”¹å½“å‰è¡Œæ¥ä¿®å¤é”™è¯¯ï¼Œæç¤º: `h` å­—ç¬¦åœ¨ UTF-8 æ ¼å¼ä¸­åªéœ€è¦ 1 ä¸ªå­—èŠ‚æ¥è¡¨ç¤º
    assert_eq!(h, &quot;h&quot;);

    let h1 = &amp;s1[3..5];// ä¿®æ”¹å½“å‰è¡Œæ¥ä¿®å¤é”™è¯¯ï¼Œæç¤º: `ä¸­` å­—ç¬¦åœ¨ UTF-8 æ ¼å¼ä¸­éœ€è¦ 3 ä¸ªå­—èŠ‚æ¥è¡¨ç¤º
    assert_eq!(h1, &quot;ä¸­&quot;);
}</code></pre></pre>
<h3 id="æ“ä½œ-utf-8-å­—ç¬¦ä¸²"><a class="header" href="#æ“ä½œ-utf-8-å­—ç¬¦ä¸²">æ“ä½œ UTF-8 å­—ç¬¦ä¸²</a></h3>
<ol start="12">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // å¡«ç©ºï¼Œæ‰“å°å‡º &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot; ä¸­çš„æ¯ä¸€ä¸ªå­—ç¬¦
    for c in &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;.__ {
        println!(&quot;{}&quot;, c)
    }
}</code></pre></pre>
<h4 id="utf8_slice"><a class="header" href="#utf8_slice">utf8_slice</a></h4>
<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‰æ–¹åº“ <a href="https://docs.rs/utf8_slice/1.0.0/utf8_slice/fn.slice.html">utf8_slice</a> æ¥è®¿é—® UTF-8 å­—ç¬¦ä¸²çš„æŸä¸ªå­ä¸²ï¼Œä½†æ˜¯ä¸ä¹‹å‰ä¸åŒçš„æ˜¯ï¼Œè¯¥åº“ç´¢å¼•çš„æ˜¯å­—ç¬¦ï¼Œè€Œä¸æ˜¯å­—èŠ‚.</p>
<p><strong>Example</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use utf8_slice;
fn main() {
    let s = &quot;The ğŸš€ goes to the ğŸŒ‘!&quot;;

    let rocket = utf8_slice::slice(s, 4, 5);
    // ç»“æœæ˜¯ &quot;ğŸš€&quot;
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/string.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ•°ç»„"><a class="header" href="#æ•°ç»„">æ•°ç»„</a></h1>
<p>æ•°ç»„çš„ç±»å‹æ˜¯ <code>[T; Length]</code>ï¼Œå°±å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œæ•°ç»„çš„é•¿åº¦æ˜¯ç±»å‹ç­¾åçš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤æ•°ç»„çš„é•¿åº¦å¿…é¡»åœ¨ç¼–è¯‘æœŸå°±å·²çŸ¥ï¼Œä¾‹å¦‚ä½ ä¸èƒ½ä½¿ç”¨ä»¥ä¸‹æ–¹å¼æ¥å£°æ˜ä¸€ä¸ªæ•°ç»„:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_arr(n: i32) {
    let arr = [1; n];
}
<span class="boring">}</span></code></pre></pre>
<p>ä»¥ä¸Šå‡½æ•°å°†æŠ¥é”™ï¼Œå› ä¸ºç¼–è¯‘å™¨æ— æ³•åœ¨ç¼–è¯‘æœŸçŸ¥é“ <code>n</code> çš„å…·ä½“å¤§å°ã€‚</p>
<ol>
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // ä½¿ç”¨åˆé€‚çš„ç±»å‹å¡«ç©º
    let arr: __ = [1, 2, 3, 4, 5];

    // ä¿®æ”¹ä»¥ä¸‹ä»£ç ï¼Œè®©å®ƒé¡ºåˆ©è¿è¡Œ
    assert!(arr.len() == 4);
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥å¿½ç•¥æ•°ç»„çš„éƒ¨åˆ†ç±»å‹ï¼Œä¹Ÿå¯ä»¥å¿½ç•¥å…¨éƒ¨ç±»å‹ï¼Œè®©ç¼–è¯‘å™¨å¸®åŠ©æˆ‘ä»¬æ¨å¯¼
    let arr0 = [1, 2, 3];
    let arr: [_; 3] = ['a', 'b', 'c'];
    
    // å¡«ç©º
    // æ•°ç»„åˆ†é…åœ¨æ ˆä¸Šï¼Œ `std::mem::size_of_val` å‡½æ•°ä¼šè¿”å›æ•´ä¸ªæ•°ç»„å ç”¨çš„å†…å­˜ç©ºé—´
    // æ•°ç»„ä¸­çš„æ¯ä¸ª char å…ƒç´ å ç”¨ 4 å­—èŠ‚çš„å†…å­˜ç©ºé—´ï¼Œå› ä¸ºåœ¨ Rust ä¸­ï¼Œ char æ˜¯ Unicode å­—ç¬¦
    assert!(std::mem::size_of_val(&amp;arr) == __);
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ å¯ä»¥ä¸€èµ·åˆå§‹åŒ–ä¸ºåŒä¸€ä¸ªå€¼</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // å¡«ç©º
    let list: [i32; 100] = __ ;

    assert!(list[0] == 1);
    assert!(list.len() == 100);
}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸ æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ å¿…é¡»æ˜¯åŒä¸€ç±»å‹</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // ä¿®å¤é”™è¯¯
    let _arr = [1, 2, '3'];
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸ æ•°ç»„çš„ä¸‹æ ‡ç´¢å¼•ä» 0 å¼€å§‹.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr = ['a', 'b', 'c'];
    
    let ele = arr[1]; // åªä¿®æ”¹æ­¤è¡Œæ¥è®©ä»£ç å·¥ä½œ

    assert!(ele == 'a');
}</code></pre></pre>
<ol start="6">
<li>ğŸŒŸ è¶Šç•Œç´¢å¼•ä¼šå¯¼è‡´ä»£ç çš„ <code>panic</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤ä»£ç ä¸­çš„é”™è¯¯
fn main() {
    let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()];
    
    // `get` è¿”å› `Option&lt;T&gt;` ç±»å‹ï¼Œå› æ­¤å®ƒçš„ä½¿ç”¨éå¸¸å®‰å…¨
    let name0 = names.get(0).unwrap();

    // ä½†æ˜¯ä¸‹æ ‡ç´¢å¼•å°±å­˜åœ¨è¶Šç•Œçš„é£é™©äº†
    let _name1 = &amp;names[2];
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/array.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="åˆ‡ç‰‡-slice-"><a class="header" href="#åˆ‡ç‰‡-slice-">åˆ‡ç‰‡( Slice )</a></h1>
<p>åˆ‡ç‰‡è·Ÿæ•°ç»„ç›¸ä¼¼ï¼Œä½†æ˜¯åˆ‡ç‰‡çš„é•¿åº¦æ— æ³•åœ¨ç¼–è¯‘æœŸå¾—çŸ¥ï¼Œå› æ­¤ä½ æ— æ³•ç›´æ¥ä½¿ç”¨åˆ‡ç‰‡ç±»å‹ã€‚</p>
<ol>
<li>ğŸŒŸğŸŒŸ è¿™é‡Œ, <code>[i32]</code> å’Œ <code>str</code> éƒ½æ˜¯åˆ‡ç‰‡ç±»å‹ï¼Œä½†æ˜¯ç›´æ¥ä½¿ç”¨å®ƒä»¬ä¼šé€ æˆç¼–è¯‘é”™è¯¯ï¼Œå¦‚ä¸‹ä»£ç æ‰€ç¤ºã€‚ä¸ºäº†è§£å†³ï¼Œä½ éœ€è¦ä½¿ç”¨åˆ‡ç‰‡çš„å¼•ç”¨ï¼š <code>&amp;[i32]</code>ï¼Œ<code>&amp;str</code>ã€‚</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤ä»£ç ä¸­çš„é”™è¯¯ï¼Œä¸è¦æ–°å¢ä»£ç è¡Œ!
fn main() {
    let arr = [1, 2, 3];
    let s1: [i32] = arr[0..2];

    let s2: str = &quot;hello, world&quot; as str;
}</code></pre></pre>
<p>ä¸€ä¸ªåˆ‡ç‰‡å¼•ç”¨å ç”¨äº†2ä¸ªå­—å¤§å°çš„å†…å­˜ç©ºé—´( ä»ç°åœ¨å¼€å§‹ï¼Œä¸ºäº†ç®€æ´æ€§è€ƒè™‘ï¼Œå¦‚æ— ç‰¹æ®ŠåŸå› ï¼Œ<strong>æˆ‘ä»¬ç»Ÿä¸€ä½¿ç”¨åˆ‡ç‰‡æ¥ç‰¹æŒ‡åˆ‡ç‰‡å¼•ç”¨</strong> )ã€‚ è¯¥åˆ‡ç‰‡çš„ç¬¬ä¸€ä¸ªå­—æ˜¯æŒ‡å‘æ•°æ®çš„æŒ‡é’ˆï¼Œç¬¬äºŒä¸ªå­—æ˜¯åˆ‡ç‰‡çš„é•¿åº¦ã€‚å­—çš„å¤§å°å–å†³äºå¤„ç†å™¨æ¶æ„ï¼Œä¾‹å¦‚åœ¨ <code>x86-64</code> ä¸Šï¼Œå­—çš„å¤§å°æ˜¯ 64 ä½ä¹Ÿå°±æ˜¯ 8 ä¸ªå­—èŠ‚ï¼Œé‚£ä¹ˆä¸€ä¸ªåˆ‡ç‰‡å¼•ç”¨å°±æ˜¯ 16 ä¸ªå­—èŠ‚å¤§å°ã€‚</p>
<p>åˆ‡ç‰‡( å¼•ç”¨ )å¯ä»¥ç”¨æ¥å€Ÿç”¨æ•°ç»„çš„æŸä¸ªè¿ç»­çš„éƒ¨åˆ†ï¼Œå¯¹åº”çš„ç­¾åæ˜¯ <code>&amp;[T]</code>ï¼Œå¤§å®¶å¯ä»¥ä¸æ•°ç»„çš„ç­¾åå¯¹æ¯”ä¸‹ <code>[T; Length]</code>ã€‚</p>
<ol start="2">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr: [char; 3] = ['ä¸­', 'å›½', 'äºº'];

    let slice = &amp;arr[..2];
    
    // ä¿®æ”¹æ•°å­— `8` è®©ä»£ç å·¥ä½œ
    // å°æç¤º: åˆ‡ç‰‡å’Œæ•°ç»„ä¸ä¸€æ ·ï¼Œå®ƒæ˜¯å¼•ç”¨ã€‚å¦‚æœæ˜¯æ•°ç»„çš„è¯ï¼Œé‚£ä¸‹é¢çš„ `assert!` å°†ä¼šé€šè¿‡ï¼š 'ä¸­'å’Œ'å›½'æ˜¯charç±»å‹ï¼Œcharç±»å‹æ˜¯Unicodeç¼–ç ï¼Œå¤§å°å›ºå®šä¸º4å­—èŠ‚ï¼Œä¸¤ä¸ªå­—ç¬¦ä¸º8å­—èŠ‚ã€‚
    assert!(std::mem::size_of_val(&amp;slice) == 8);
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let arr: [i32; 5] = [1, 2, 3, 4, 5];
  // å¡«ç©ºè®©ä»£ç å·¥ä½œèµ·æ¥
  let slice: __ = __;
  assert_eq!(slice, &amp;[2, 3, 4]);
}</code></pre></pre>
<h3 id="å­—ç¬¦ä¸²åˆ‡ç‰‡"><a class="header" href="#å­—ç¬¦ä¸²åˆ‡ç‰‡">å­—ç¬¦ä¸²åˆ‡ç‰‡</a></h3>
<ol start="4">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = String::from(&quot;hello&quot;);

    let slice1 = &amp;s[0..2];
    // å¡«ç©ºï¼Œä¸è¦å†ä½¿ç”¨ 0..2
    let slice2 = &amp;s[__];

    assert_eq!(slice1, slice2);
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;;
    // ä¿®æ”¹ä»¥ä¸‹ä»£ç è¡Œï¼Œè®©ä»£ç å·¥ä½œèµ·æ¥
    let slice = &amp;s[0..2];

    assert!(slice == &quot;ä½ &quot;);
}</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ <code>&amp;String</code> å¯ä»¥è¢«éšå¼åœ°è½¬æ¢æˆ <code>&amp;str</code> ç±»å‹.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤æ‰€æœ‰é”™è¯¯
fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    // è¿™é‡Œ, &amp;s æ˜¯ `&amp;String` ç±»å‹ï¼Œä½†æ˜¯ `first_character` å‡½æ•°éœ€è¦çš„æ˜¯ `&amp;str` ç±»å‹ã€‚
    // å°½ç®¡ä¸¤ä¸ªç±»å‹ä¸ä¸€æ ·ï¼Œä½†æ˜¯ä»£ç ä»ç„¶å¯ä»¥å·¥ä½œï¼ŒåŸå› æ˜¯ `&amp;String` ä¼šè¢«éšå¼åœ°è½¬æ¢æˆ `&amp;str` ç±»å‹ï¼Œå¦‚æœå¤§å®¶æƒ³è¦çŸ¥é“æ›´å¤šï¼Œå¯ä»¥çœ‹çœ‹ Deref ç« èŠ‚: https://course.rs/advance/smart-pointer/deref.html
    let ch = first_character(&amp;s);

    s.clear(); // error!

    println!(&quot;the first character is: {}&quot;, ch);
}
fn first_character(s: &amp;str) -&gt; &amp;str {
    &amp;s[..1]
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/slice.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å…ƒç»„-tuple-"><a class="header" href="#å…ƒç»„-tuple-">å…ƒç»„( Tuple )</a></h1>
<ol>
<li>ğŸŒŸ å…ƒç»„ä¸­çš„å…ƒç´ å¯ä»¥æ˜¯ä¸åŒçš„ç±»å‹ã€‚å…ƒç»„çš„ç±»å‹ç­¾åæ˜¯ <code>(T1, T2, ...)</code>, è¿™é‡Œ <code>T1</code>, <code>T2</code> æ˜¯ç›¸å¯¹åº”çš„å…ƒç»„æˆå‘˜çš„ç±»å‹.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let _t0: (u8,i16) = (0, -1);
    // å…ƒç»„çš„æˆå‘˜è¿˜å¯ä»¥æ˜¯ä¸€ä¸ªå…ƒç»„
    let _t1: (u8, (i16, u32)) = (0, (-1, 1));
    // å¡«ç©ºè®©ä»£ç å·¥ä½œ
    let t: (u8, __, i64, __, __) = (1u8, 2u16, 3i64, &quot;hello&quot;, String::from(&quot;, world&quot;));
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ å¯ä»¥ä½¿ç”¨ç´¢å¼•æ¥è·å–å…ƒç»„çš„æˆå‘˜</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®æ”¹åˆé€‚çš„åœ°æ–¹ï¼Œè®©ä»£ç å·¥ä½œ
fn main() {
    let t = (&quot;i&quot;, &quot;am&quot;, &quot;sunface&quot;);
    assert_eq!(t.1, &quot;sunface&quot;);
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ è¿‡é•¿çš„å…ƒç»„æ— æ³•è¢«æ‰“å°è¾“å‡º</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤ä»£ç é”™è¯¯
fn main() {
    let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);
}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸ ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥è§£æ„å…ƒç»„</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let tup = (1, 6.4, &quot;hello&quot;);

    // å¡«ç©º
    let __ = tup;

    assert_eq!(x, 1);
    assert_eq!(y, &quot;hello&quot;);
    assert_eq!(z, 6.4);
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ è§£æ„å¼èµ‹å€¼</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let (x, y, z);

    // å¡«ç©º
    __ = (1, 2, 3);
    
    assert_eq!(x, 3);
    assert_eq!(y, 1);
    assert_eq!(z, 2);
}</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ å…ƒç»„å¯ä»¥ç”¨äºå‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // å¡«ç©ºï¼Œéœ€è¦ç¨å¾®è®¡ç®—ä¸‹
    let (x, y) = sum_multiply(__);

    assert_eq!(x, 5);
    assert_eq!(y, 6);
}

fn sum_multiply(nums: (i32, i32)) -&gt; (i32, i32) {
    (nums.0 + nums.1, nums.0 * nums.1)
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/tuple.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç»“æ„ä½“"><a class="header" href="#ç»“æ„ä½“">ç»“æ„ä½“</a></h1>
<h3 id="ä¸‰ç§ç±»å‹çš„ç»“æ„ä½“"><a class="header" href="#ä¸‰ç§ç±»å‹çš„ç»“æ„ä½“">ä¸‰ç§ç±»å‹çš„ç»“æ„ä½“</a></h3>
<ol>
<li>ğŸŒŸ å¯¹äºç»“æ„ä½“ï¼Œæˆ‘ä»¬å¿…é¡»ä¸ºå…¶ä¸­çš„æ¯ä¸€ä¸ªå­—æ®µéƒ½æŒ‡å®šå…·ä½“çš„å€¼</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error
struct Person {
    name: String,
    age: u8,
    hobby: String
}
fn main() {
    let age = 30;
    let p = Person {
        name: String::from(&quot;sunface&quot;),
        age,
    };
} </code></pre></pre>
<ol start="2">
<li>ğŸŒŸ å•å…ƒç»“æ„ä½“æ²¡æœ‰ä»»ä½•å­—æ®µã€‚</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Unit;
trait SomeTrait {
    // ...å®šä¹‰ä¸€äº›è¡Œä¸º
}

// æˆ‘ä»¬å¹¶ä¸å…³å¿ƒç»“æ„ä½“ä¸­æœ‰ä»€ä¹ˆæ•°æ®( å­—æ®µ )ï¼Œä½†æˆ‘ä»¬å…³å¿ƒå®ƒçš„è¡Œä¸ºã€‚
// å› æ­¤è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨æ²¡æœ‰ä»»ä½•å­—æ®µçš„å•å…ƒç»“æ„ä½“ï¼Œç„¶åä¸ºå®ƒå®ç°ä¸€äº›è¡Œä¸º
impl SomeTrait for Unit {  }
fn main() {
    let u = Unit;
    do_something_with_unit(u);
} 

// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œ
fn do_something_with_unit(u: __) {   }</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ å…ƒç»„ç»“æ„ä½“çœ‹èµ·æ¥è·Ÿå…ƒç»„å¾ˆåƒï¼Œä½†æ˜¯å®ƒæ‹¥æœ‰ä¸€ä¸ªç»“æ„ä½“çš„åç§°ï¼Œè¯¥åç§°å¯ä»¥èµ‹äºˆå®ƒä¸€å®šçš„æ„ä¹‰ã€‚ç”±äºå®ƒå¹¶ä¸å…³å¿ƒå†…éƒ¨æ•°æ®åˆ°åº•æ˜¯ä»€ä¹ˆåç§°ï¼Œå› æ­¤æ­¤æ—¶å…ƒç»„ç»“æ„ä½“å°±éå¸¸é€‚åˆã€‚</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
fn main() {
    let v = Point(__, __, __);
    check_color(v);
}   

fn check_color(p: Color) {
    let (x, _, _) = p;
    assert_eq!(x, 0);
    assert_eq!(p.1, 127);
    assert_eq!(__, 255);
 }</code></pre></pre>
<h3 id="ç»“æ„ä½“ä¸Šçš„ä¸€äº›æ“ä½œ"><a class="header" href="#ç»“æ„ä½“ä¸Šçš„ä¸€äº›æ“ä½œ">ç»“æ„ä½“ä¸Šçš„ä¸€äº›æ“ä½œ</a></h3>
<ol start="4">
<li>ğŸŒŸ ä½ å¯ä»¥åœ¨å®ä¾‹åŒ–ä¸€ä¸ªç»“æ„ä½“æ—¶å°†å®ƒæ•´ä½“æ ‡è®°ä¸ºå¯å˜çš„ï¼Œä½†æ˜¯ Rust ä¸å…è®¸æˆ‘ä»¬å°†ç»“æ„ä½“çš„æŸä¸ªå­—æ®µä¸“é—¨æŒ‡å®šä¸ºå¯å˜çš„.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯ï¼Œä¸è¦å¢åŠ æˆ–ç§»é™¤ä»£ç è¡Œ
struct Person {
    name: String,
    age: u8,
}
fn main() {
    let age = 18;
    let p = Person {
        name: String::from(&quot;sunface&quot;),
        age,
    };

    // how can you believe sunface is only 18? 
    p.age = 30;

    // å¡«ç©º
    __ = String::from(&quot;sunfei&quot;);
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸ ä½¿ç”¨ç»“æ„ä½“å­—æ®µåˆå§‹åŒ–ç¼©ç•¥è¯­æ³•å¯ä»¥å‡å°‘ä¸€äº›é‡å¤ä»£ç </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
struct Person {
    name: String,
    age: u8,
}
fn main() {} 

fn build_person(name: String, age: u8) -&gt; Person {
    Person {
        age,
        __
    }
}</code></pre></pre>
<ol start="6">
<li>ğŸŒŸ ä½ å¯ä»¥ä½¿ç”¨ç»“æ„ä½“æ›´æ–°è¯­æ³•åŸºäºä¸€ä¸ªç»“æ„ä½“å®ä¾‹æ¥æ„é€ å¦ä¸€ä¸ª</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œ
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let u1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;sunface&quot;),
        active: true,
        sign_in_count: 1,
    };

    let u2 = set_email(u1);
} 

fn set_email(u: User) -&gt; User {
    User {
        email: String::from(&quot;contact@im.dev&quot;),
        __
    }
}</code></pre></pre>
<h3 id="æ‰“å°ç»“æ„ä½“"><a class="header" href="#æ‰“å°ç»“æ„ä½“">æ‰“å°ç»“æ„ä½“</a></h3>
<ol start="7">
<li>ğŸŒŸğŸŒŸ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ <code>#[derive(Debug)]</code> è®©<a href="https://course.rs/basic/compound-type/struct.html#%E4%BD%BF%E7%94%A8-derivedebug-%E6%9D%A5%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BF%A1%E6%81%AF">ç»“æ„ä½“å˜æˆå¯æ‰“å°çš„</a>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œ
#[__]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale), // æ‰“å° debug ä¿¡æ¯åˆ°æ ‡å‡†é”™è¯¯è¾“å‡º stderr,å¹¶å°† `30 * scale` çš„å€¼èµ‹ç»™ `width`
        height: 50,
    };

    dbg!(&amp;rect1); // æ‰“å° debug ä¿¡æ¯åˆ°æ ‡å‡†é”™è¯¯è¾“å‡º stderr

    println!(__, rect1); // æ‰“å° debug ä¿¡æ¯åˆ°æ ‡å‡†è¾“å‡º stdout
}</code></pre></pre>
<h3 id="ç»“æ„ä½“çš„æ‰€æœ‰æƒ"><a class="header" href="#ç»“æ„ä½“çš„æ‰€æœ‰æƒ">ç»“æ„ä½“çš„æ‰€æœ‰æƒ</a></h3>
<p>å½“è§£æ„ä¸€ä¸ªå˜é‡æ—¶ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ <code>move</code> å’Œå¼•ç”¨æ¨¡å¼ç»‘å®šçš„æ–¹å¼ã€‚å½“è¿™ä¹ˆåšæ—¶ï¼Œéƒ¨åˆ† <code>move</code> å°±ä¼šå‘ç”Ÿï¼šå˜é‡ä¸­ä¸€éƒ¨åˆ†çš„æ‰€æœ‰æƒè¢«è½¬ç§»ç»™å…¶å®ƒå˜é‡ï¼Œè€Œå¦ä¸€éƒ¨åˆ†æˆ‘ä»¬è·å–äº†å®ƒçš„å¼•ç”¨ã€‚</p>
<p>åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒåŸå˜é‡å°†æ— æ³•å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯å®ƒæ²¡æœ‰è½¬ç§»æ‰€æœ‰æƒçš„é‚£ä¸€éƒ¨åˆ†ä¾ç„¶å¯ä»¥ä½¿ç”¨ï¼Œä¹Ÿå°±æ˜¯ä¹‹å‰è¢«å¼•ç”¨çš„é‚£éƒ¨åˆ†ã€‚</p>
<h4 id="ç¤ºä¾‹-2"><a class="header" href="#ç¤ºä¾‹-2">ç¤ºä¾‹</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box&lt;u8&gt;,
    }

    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: Box::new(20),
    };

    // é€šè¿‡è¿™ç§è§£æ„å¼æ¨¡å¼åŒ¹é…ï¼Œperson.name çš„æ‰€æœ‰æƒè¢«è½¬ç§»ç»™æ–°çš„å˜é‡ `name`
    // ä½†æ˜¯ï¼Œè¿™é‡Œ `age` å˜é‡å´æ˜¯å¯¹ person.age çš„å¼•ç”¨, è¿™é‡Œ ref çš„ä½¿ç”¨ç›¸å½“äº: let age = &amp;person.age 
    let Person { name, ref age } = person;

    println!(&quot;The person's age is {}&quot;, age);

    println!(&quot;The person's name is {}&quot;, name);

    // Error! åŸå› æ˜¯ person çš„ä¸€éƒ¨åˆ†å·²ç»è¢«è½¬ç§»äº†æ‰€æœ‰æƒï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•å†ä½¿ç”¨å®ƒ
    //println!(&quot;The person struct is {:?}&quot;, person);

    // è™½ç„¶ `person` ä½œä¸ºä¸€ä¸ªæ•´ä½“æ— æ³•å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯ `person.age` ä¾ç„¶å¯ä»¥ä½¿ç”¨
    println!(&quot;The person's age from person struct is {}&quot;, person.age);
}</code></pre></pre>
<h4 id="ç»ƒä¹ -2"><a class="header" href="#ç»ƒä¹ -2">ç»ƒä¹ </a></h4>
<ol start="8">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯
#[derive(Debug)]
struct File {
    name: String,
    data: String,
}
fn main() {
    let f = File {
        name: String::from(&quot;readme.md&quot;),
        data: &quot;Rust By Practice&quot;.to_string()
    };

    let _name = f.name;

    // åªèƒ½ä¿®æ”¹è¿™ä¸€è¡Œ
    println!(&quot;{}, {}, {:?}&quot;,f.name, f.data, f);
} </code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/struct.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æšä¸¾-enum"><a class="header" href="#æšä¸¾-enum">æšä¸¾ Enum</a></h1>
<ol>
<li>ğŸŒŸğŸŒŸ åœ¨åˆ›å»ºæšä¸¾æ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨æ˜¾å¼çš„æ•´æ•°è®¾å®šæšä¸¾æˆå‘˜çš„å€¼ã€‚</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯
enum Number {
    Zero,
    One,
    Two,
}

enum Number1 {
    Zero = 0,
    One,
    Two,
}

// Cè¯­è¨€é£æ ¼çš„æšä¸¾å®šä¹‰
enum Number2 {
    Zero = 0.0,
    One = 1.0,
    Two = 2.0,
}


fn main() {
    // é€šè¿‡ `as` å¯ä»¥å°†æšä¸¾å€¼å¼ºè½¬ä¸ºæ•´æ•°ç±»å‹
    assert_eq!(Number::One, Number1::One);
    assert_eq!(Number1::One, Number2::One);
} </code></pre></pre>
<ol start="2">
<li>ğŸŒŸ æšä¸¾æˆå‘˜å¯ä»¥æŒæœ‰å„ç§ç±»å‹çš„å€¼</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg1 = Message::Move{__}; // ä½¿ç”¨x = 1, y = 2 æ¥åˆå§‹åŒ–
    let msg2 = Message::Write(__); // ä½¿ç”¨ &quot;hello, world!&quot; æ¥åˆå§‹åŒ–
} </code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ æšä¸¾æˆå‘˜ä¸­çš„å€¼å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥è·å–</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä»…å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::Move{x: 1, y: 2};

    if let Message::Move{__} = msg {
        assert_eq!(a, b);
    } else {
        panic!(&quot;ä¸è¦è®©è¿™è¡Œä»£ç è¿è¡Œï¼&quot;);
    }
} </code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ ä½¿ç”¨æšä¸¾å¯¹ç±»å‹è¿›è¡ŒåŒä¸€åŒ–</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºï¼Œå¹¶ä¿®å¤é”™è¯¯
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msgs: __ = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }
} 

fn show_message(msg: Message) {
    println!(&quot;{}&quot;, msg);
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ Rust ä¸­æ²¡æœ‰ <code>null</code>ï¼Œæˆ‘ä»¬é€šè¿‡ <code>Option&lt;T&gt;</code> æšä¸¾æ¥å¤„ç†å€¼ä¸ºç©ºçš„æƒ…å†µ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºè®© `println` è¾“å‡ºï¼ŒåŒæ—¶æ·»åŠ ä¸€äº›ä»£ç ä¸è¦è®©æœ€åä¸€è¡Œçš„ `panic` æ‰§è¡Œåˆ°
fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    if let __ = six {
        println!(&quot;{}&quot;, n)
    } 
        
    panic!(&quot;ä¸è¦è®©è¿™è¡Œä»£ç è¿è¡Œï¼&quot;);
} 

fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        __ =&gt; None,
        __ =&gt; Some(i + 1),
    }
}</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ ä½¿ç”¨æšä¸¾æ¥å®ç°é“¾è¡¨.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºï¼Œè®©ä»£ç è¿è¡Œ
use crate::List::*;

enum List {
    // Cons: é“¾è¡¨ä¸­åŒ…å«æœ‰å€¼çš„èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹æ˜¯å…ƒç»„ç±»å‹ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯èŠ‚ç‚¹çš„å€¼ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ
    Cons(u32, Box&lt;List&gt;),
    // Nil: é“¾è¡¨ä¸­çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œç”¨äºè¯´æ˜é“¾è¡¨çš„ç»“æŸ
    Nil,
}

// ä¸ºæšä¸¾å®ç°ä¸€äº›æ–¹æ³•
impl List {
    // åˆ›å»ºç©ºçš„é“¾è¡¨
    fn new() -&gt; List {
        // å› ä¸ºæ²¡æœ‰èŠ‚ç‚¹ï¼Œæ‰€ä»¥ç›´æ¥è¿”å› Nil èŠ‚ç‚¹
        // æšä¸¾æˆå‘˜ Nil çš„ç±»å‹æ˜¯ List
        Nil
    }

    // åœ¨è€çš„é“¾è¡¨å‰é¢æ–°å¢ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶è¿”å›æ–°çš„é“¾è¡¨
    fn prepend(self, elem: u32) -&gt; __ {
        Cons(elem, Box::new(self))
    }

    // è¿”å›é“¾è¡¨çš„é•¿åº¦
    fn len(&amp;self) -&gt; u32 {
        match *self {
            // è¿™é‡Œæˆ‘ä»¬ä¸èƒ½æ‹¿èµ° tail çš„æ‰€æœ‰æƒï¼Œå› æ­¤éœ€è¦è·å–å®ƒçš„å¼•ç”¨
            Cons(_, __ tail) =&gt; 1 + tail.len(),
            // ç©ºé“¾è¡¨çš„é•¿åº¦ä¸º 0
            Nil =&gt; 0
        }
    }

    // è¿”å›é“¾è¡¨çš„å­—ç¬¦ä¸²è¡¨ç°å½¢å¼ï¼Œç”¨äºæ‰“å°è¾“å‡º
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // é€’å½’ç”Ÿæˆå­—ç¬¦ä¸²
                format!(&quot;{}, {}&quot;, head, tail.__())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // åˆ›å»ºä¸€ä¸ªæ–°çš„é“¾è¡¨(ä¹Ÿæ˜¯ç©ºçš„)
    let mut list = List::new();

    // æ·»åŠ ä¸€äº›å…ƒç´ 
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // æ‰“å°åˆ—è¡¨çš„å½“å‰çŠ¶æ€
    println!(&quot;é“¾è¡¨çš„é•¿åº¦æ˜¯: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/enum.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æµç¨‹æ§åˆ¶"><a class="header" href="#æµç¨‹æ§åˆ¶">æµç¨‹æ§åˆ¶</a></h1>
<h3 id="ifelse"><a class="header" href="#ifelse">if/else</a></h3>
<ol>
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn main() {
    let n = 5;

    if n &lt; 0 {
        println!(&quot;{} is negative&quot;, n);
    } __ n &gt; 0 {
        println!(&quot;{} is positive&quot;, n);
    } __ {
        println!(&quot;{} is zero&quot;, n);
    }
} </code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ if/else å¯ä»¥ç”¨ä½œè¡¨è¾¾å¼æ¥è¿›è¡Œèµ‹å€¼</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯
fn main() {
    let n = 5;

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot; æ•°å­—å¤ªå°ï¼Œå…ˆå¢åŠ  10 å€å†è¯´&quot;);

            10 * n
        } else {
            println!(&quot;æ•°å­—å¤ªå¤§ï¼Œæˆ‘ä»¬å¾—è®©å®ƒå‡åŠ&quot;);

            n / 2.0 ;
        }

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
} </code></pre></pre>
<h3 id="for"><a class="header" href="#for">for</a></h3>
<ol start="3">
<li>ğŸŒŸ <code>for in</code> å¯ä»¥ç”¨äºè¿­ä»£ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä¾‹å¦‚åºåˆ— <code>a..b</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    for n in 1..=100 { // ä¿®æ”¹æ­¤è¡Œï¼Œè®©ä»£ç å·¥ä½œ
        if n == 100 {
            panic!(&quot;NEVER LET THIS RUN&quot;)
        }
    }
} </code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯ï¼Œä¸è¦æ–°å¢æˆ–åˆ é™¤ä»£ç è¡Œ
fn main() {
    let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)];
    for name in names {
        // do something with name...
    }

    println!(&quot;{:?}&quot;, names);

    let numbers = [1, 2, 3];
    // numbersä¸­çš„å…ƒç´ å®ç°äº† Copyï¼Œå› æ­¤æ— éœ€è½¬ç§»æ‰€æœ‰æƒ
    for n in numbers {
        // do something with name...
    }
    
    println!(&quot;{:?}&quot;, numbers);
} </code></pre></pre>
<ol start="5">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = [4,3,2,1];

    // é€šè¿‡ç´¢å¼•å’Œå€¼çš„æ–¹å¼è¿­ä»£æ•°ç»„ `a` 
    for (i,v) in a.__ {
        println!(&quot;ç¬¬{}ä¸ªå…ƒç´ æ˜¯{}&quot;,i+1,v);
    }
}</code></pre></pre>
<h3 id="while"><a class="header" href="#while">while</a></h3>
<ol start="6">
<li>ğŸŒŸğŸŒŸ å½“æ¡ä»¶ä¸º true æ—¶ï¼Œ<code>while</code> å°†ä¸€ç›´å¾ªç¯</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºï¼Œè®©æœ€åä¸€è¡Œçš„  println! å·¥ä½œ !
fn main() {
    // ä¸€ä¸ªè®¡æ•°å€¼
    let mut n = 1;

    // å½“æ¡ä»¶ä¸ºçœŸæ—¶ï¼Œä¸åœçš„å¾ªç¯
    while n __ 10 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }


        __;
    }

    println!(&quot;n çš„å€¼æ˜¯ {}, å¾ªç¯ç»“æŸ&quot;,n);
}</code></pre></pre>
<h3 id="continue-and-break"><a class="header" href="#continue-and-break">continue and break</a></h3>
<ol start="7">
<li>ğŸŒŸ ä½¿ç”¨ <code>break</code> å¯ä»¥è·³å‡ºå¾ªç¯</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç 
fn main() {
    let mut n = 0;
    for i in 0..=100 {
       if n == 66 {
           __
       }
       n += 1;
    }

    assert_eq!(n, 66);
}</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ <code>continue</code> ä¼šç»“æŸå½“æ¬¡å¾ªç¯å¹¶ç«‹å³å¼€å§‹ä¸‹ä¸€æ¬¡å¾ªç¯</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç 
fn main() {
    let mut n = 0;
    for i in 0..=100 {
       if n != 66 {
           n+=1;
           __;
       }
       
       __
    }

    assert_eq!(n, 66);
}</code></pre></pre>
<h3 id="loop"><a class="header" href="#loop">loop</a></h3>
<ol start="9">
<li>ğŸŒŸğŸŒŸ loop ä¸€èˆ¬éƒ½éœ€è¦é…åˆ <code>break</code> æˆ– <code>continue</code> ä¸€èµ·ä½¿ç”¨ã€‚</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç 
fn main() {
    let mut count = 0u32;

    println!(&quot;Let's count until infinity!&quot;);

    // æ— é™å¾ªç¯
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;three&quot;);

            // è·³è¿‡å½“æ­¤å¾ªç¯çš„å‰©ä½™ä»£ç 
            __;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;OK, that's enough&quot;);

            __;
        }
    }

    assert_eq!(count, 5);
}</code></pre></pre>
<ol start="10">
<li>ğŸŒŸğŸŒŸ loop æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é…åˆ <code>break</code> æ¥è¿”å›ä¸€ä¸ªå€¼</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            __;
        }
    };

    assert_eq!(result, 20);
}</code></pre></pre>
<ol start="11">
<li>ğŸŒŸğŸŒŸğŸŒŸ å½“æœ‰å¤šå±‚å¾ªç¯æ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨ <code>continue</code> æˆ– <code>break</code> æ¥æ§åˆ¶å¤–å±‚çš„å¾ªç¯ã€‚è¦å®ç°è¿™ä¸€ç‚¹ï¼Œå¤–éƒ¨çš„å¾ªç¯å¿…é¡»æ‹¥æœ‰ä¸€ä¸ªæ ‡ç­¾ <code>'label</code>, ç„¶ååœ¨ <code>break</code> æˆ– <code>continue</code> æ—¶æŒ‡å®šè¯¥æ ‡ç­¾</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn main() {
    let mut count = 0;
    'outer: loop {
        'inner1: loop {
            if count &gt;= 20 {
                // è¿™åªä¼šè·³å‡º inner1 å¾ªç¯
                break 'inner1; // è¿™é‡Œä½¿ç”¨ `break` ä¹Ÿæ˜¯ä¸€æ ·çš„
            }
            count += 2;
        }

        count += 5;

        'inner2: loop {
            if count &gt;= 30 {
                break 'outer;
            }

            continue 'outer;
        }
    }

    assert!(count == __)
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/flow-control.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-match"><a class="header" href="#pattern-match">Pattern Match</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-matches-å’Œ-if-let"><a class="header" href="#match-matches-å’Œ-if-let">match, matches! å’Œ if let</a></h1>
<h3 id="match"><a class="header" href="#match">match</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East =&gt; println!(&quot;East&quot;),
        __  =&gt; { // åœ¨è¿™é‡ŒåŒ¹é… South æˆ– North
            println!(&quot;South or North&quot;);
        },
        _ =&gt; println!(__),
    };
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ <code>match</code> æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå› æ­¤å¯ä»¥ç”¨åœ¨èµ‹å€¼è¯­å¥ä¸­</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let boolean = true;

    // ä½¿ç”¨ match è¡¨è¾¾å¼å¡«ç©ºï¼Œå¹¶æ»¡è¶³ä»¥ä¸‹æ¡ä»¶
    //
    // boolean = true =&gt; binary = 1
    // boolean = false =&gt; binary = 0
    let binary = __;

    assert_eq!(binary, 1);
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ ä½¿ç”¨ match åŒ¹é…å‡ºæšä¸¾æˆå‘˜æŒæœ‰çš„å€¼</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msgs = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }
} 

fn show_message(msg: Message) {
    match msg {
        __ =&gt; { // è¿™é‡ŒåŒ¹é… Message::Move
            assert_eq!(a, 1);
            assert_eq!(b, 3);
        },
        Message::ChangeColor(_, g, b) =&gt; {
            assert_eq!(g, __);
            assert_eq!(b, __);
        }
        __ =&gt; println!(&quot;no data in these variants&quot;)
    }
}</code></pre></pre>
<h3 id="matches"><a class="header" href="#matches">matches!</a></h3>
<p><a href="https://doc.rust-lang.org/stable/core/macro.matches.html"><code>matches!</code></a> çœ‹èµ·æ¥åƒ <code>match</code>, ä½†æ˜¯å®ƒå¯ä»¥åšä¸€äº›ç‰¹åˆ«çš„äº‹æƒ…</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let alphabets = ['a', 'E', 'Z', '0', 'x', '9' , 'Y'];

    // ä½¿ç”¨ `matches` å¡«ç©º
    for ab in alphabets {
        assert!(__)
    }
} </code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
enum MyEnum {
    Foo,
    Bar
}

fn main() {
    let mut count = 0;

    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];
    for e in v {
        if e == MyEnum::Foo { // ä¿®å¤é”™è¯¯ï¼Œåªèƒ½ä¿®æ”¹æœ¬è¡Œä»£ç 
            count += 1;
        }
    }

    assert_eq!(count, 2);
}</code></pre></pre>
<h3 id="if-let"><a class="header" href="#if-let">if let</a></h3>
<p>åœ¨æœ‰äº›æ—¶å€™, ä½¿ç”¨ <code>match</code> åŒ¹é…æšä¸¾æœ‰äº›å¤ªé‡äº†ï¼Œæ­¤æ—¶ <code>if let</code> å°±éå¸¸é€‚åˆ.</p>
<ol start="6">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let o = Some(7);

    // ç§»é™¤æ•´ä¸ª `match` è¯­å¥å—ï¼Œä½¿ç”¨ `if let` æ›¿ä»£
    match o {
        Some(i) =&gt; {
            println!(&quot;This is a really long string and `{:?}`&quot;, i);
        }
        _ =&gt; {}
    };
}</code></pre></pre>
<ol start="7">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
enum Foo {
    Bar(u8)
}

fn main() {
    let a = Foo::Bar(1);

    __ {
        println!(&quot;foobar æŒæœ‰çš„å€¼æ˜¯: {}&quot;, i);
    }
}</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    let a = Foo::Qux(10);

    // ç§»é™¤ä»¥ä¸‹ä»£ç ï¼Œä½¿ç”¨ `match` ä»£æ›¿
    if let Foo::Bar = a {
        println!(&quot;match foo::bar&quot;)
    } else if let Foo::Baz = a {
        println!(&quot;match foo::baz&quot;)
    } else {
        println!(&quot;match others&quot;)
    }
}</code></pre></pre>
<h3 id="å˜é‡é®è”½-shadowing--1"><a class="header" href="#å˜é‡é®è”½-shadowing--1">å˜é‡é®è”½( Shadowing )</a></h3>
<ol start="9">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å°±åœ°ä¿®å¤é”™è¯¯
fn main() {
    let age = Some(30);
    if let Some(age) = age { // åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ï¼Œè¯¥å˜é‡ä¸ä¹‹å‰çš„ `age` å˜é‡åŒå
       assert_eq!(age, Some(30));
    } // æ–°çš„ `age` å˜é‡åœ¨è¿™é‡Œè¶…å‡ºä½œç”¨åŸŸ
    
    match age {
        // `match` ä¹Ÿèƒ½å®ç°å˜é‡é®è”½
        Some(age) =&gt;  println!(&quot;age æ˜¯ä¸€ä¸ªæ–°çš„å˜é‡ï¼Œå®ƒçš„å€¼æ˜¯ {}&quot;,age),
        _ =&gt; ()
    }
 }</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/pattern-match/match.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ¨¡å¼"><a class="header" href="#æ¨¡å¼">æ¨¡å¼</a></h1>
<ol>
<li>ğŸŒŸğŸŒŸ ä½¿ç”¨ <code>|</code> å¯ä»¥åŒ¹é…å¤šä¸ªå€¼, è€Œä½¿ç”¨ <code>..=</code> å¯ä»¥åŒ¹é…ä¸€ä¸ªé—­åŒºé—´çš„æ•°å€¼åºåˆ—</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {}
fn match_number(n: i32) {
    match n {
        // åŒ¹é…ä¸€ä¸ªå•ç‹¬çš„å€¼
        1 =&gt; println!(&quot;One!&quot;),
        // ä½¿ç”¨ `|` å¡«ç©ºï¼Œä¸è¦ä½¿ç”¨ `..` æˆ– `..=`
        __ =&gt; println!(&quot;match 2 -&gt; 5&quot;),
        // åŒ¹é…ä¸€ä¸ªé—­åŒºé—´çš„æ•°å€¼åºåˆ—
        6..=10 =&gt; {
            println!(&quot;match 6 -&gt; 10&quot;)
        },
        _ =&gt; {
            println!(&quot;match 11 -&gt; +infinite&quot;)
        }
    }
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸğŸŒŸ  <code>@</code> æ“ä½œç¬¦å¯ä»¥è®©æˆ‘ä»¬å°†ä¸€ä¸ªä¸æ¨¡å¼ç›¸åŒ¹é…çš„å€¼ç»‘å®šåˆ°æ–°çš„å˜é‡ä¸Š</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // å¡«ç©ºï¼Œè®© p åŒ¹é…ç¬¬äºŒä¸ªåˆ†æ”¯
    let p = Point { x: __, y: __ };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        // ç¬¬äºŒä¸ªåˆ†æ”¯
        Point { x: 0..=5, y: y@ (10 | 20 | 30) } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯
enum Message {
    Hello { id: i32 },
}

fn main() {
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id:  3..=7,
        } =&gt; println!(&quot;id å€¼çš„èŒƒå›´åœ¨ [3, 7] ä¹‹é—´: {}&quot;, id),
        Message::Hello { id: newid@10 | 11 | 12 } =&gt; {
            println!(&quot;id å€¼çš„èŒƒå›´åœ¨ [10, 12] ä¹‹é—´: {}&quot;, newid)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id),
    }
}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ åŒ¹é…å®ˆå«ï¼ˆmatch guardï¼‰æ˜¯ä¸€ä¸ªä½äº match åˆ†æ”¯æ¨¡å¼ä¹‹åçš„é¢å¤– if æ¡ä»¶ï¼Œå®ƒèƒ½ä¸ºåˆ†æ”¯æ¨¡å¼æä¾›æ›´è¿›ä¸€æ­¥çš„åŒ¹é…æ¡ä»¶ã€‚</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºè®©ä»£ç å·¥ä½œï¼Œå¿…é¡»ä½¿ç”¨ `split`
fn main() {
    let num = Some(4);
    let split = 5;
    match num {
        Some(x) __ =&gt; assert!(x &lt; split),
        Some(x) =&gt; assert!(x &gt;= split),
        None =&gt; (),
    }
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸğŸŒŸ ä½¿ç”¨ <code>..</code> å¿½ç•¥ä¸€éƒ¨åˆ†å€¼</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œ
fn main() {
    let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);

    match numbers {
        __ =&gt; {
           assert_eq!(first, 2);
           assert_eq!(last, 2048);
        }
    }
}</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ ä½¿ç”¨æ¨¡å¼ <code>&amp;mut V</code> å»åŒ¹é…ä¸€ä¸ªå¯å˜å¼•ç”¨æ—¶ï¼Œä½ éœ€è¦æ ¼å¤–å°å¿ƒï¼Œå› ä¸ºåŒ¹é…å‡ºæ¥çš„ <code>V</code> æ˜¯ä¸€ä¸ªå€¼ï¼Œè€Œä¸æ˜¯å¯å˜å¼•ç”¨</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯ï¼Œå°½é‡å°‘åœ°ä¿®æ”¹ä»£ç 
// ä¸è¦ç§»é™¤ä»»ä½•ä»£ç è¡Œ
fn main() {
    let mut v = String::from(&quot;hello,&quot;);
    let r = &amp;mut v;

    match r {
       &amp;mut value =&gt; value.push_str(&quot; world!&quot;) 
    }
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/pattern-match/patterns.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ–¹æ³•å’Œå…³è”å‡½æ•°"><a class="header" href="#æ–¹æ³•å’Œå…³è”å‡½æ•°">æ–¹æ³•å’Œå…³è”å‡½æ•°</a></h1>
<h2 id="ç¤ºä¾‹-3"><a class="header" href="#ç¤ºä¾‹-3">ç¤ºä¾‹</a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point {
    x: f64,
    y: f64,
}

// `Point` çš„å…³è”å‡½æ•°éƒ½æ”¾åœ¨ä¸‹é¢çš„ `impl` è¯­å¥å—ä¸­
impl Point {
    // å…³è”å‡½æ•°çš„ä½¿ç”¨æ–¹æ³•è·Ÿæ„é€ å™¨éå¸¸ç±»ä¼¼
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // å¦å¤–ä¸€ä¸ªå…³è”å‡½æ•°ï¼Œæœ‰ä¸¤ä¸ªå‚æ•°
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // è¿™æ˜¯ä¸€ä¸ªæ–¹æ³•
    // `&amp;self` æ˜¯ `self: &amp;Self` çš„è¯­æ³•ç³–
    // `Self` æ˜¯å½“å‰è°ƒç”¨å¯¹è±¡çš„ç±»å‹ï¼Œå¯¹äºæœ¬ä¾‹æ¥è¯´ `Self` = `Rectangle`
    fn area(&amp;self) -&gt; f64 {
        // ä½¿ç”¨ç‚¹æ“ä½œç¬¦å¯ä»¥è®¿é—® `self` ä¸­çš„ç»“æ„ä½“å­—æ®µ
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

  
        // `abs` æ˜¯ä¸€ä¸ª `f64` ç±»å‹çš„æ–¹æ³•ï¼Œä¼šè¿”å›è°ƒç”¨è€…çš„ç»å¯¹å€¼
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // è¯¥æ–¹æ³•è¦æ±‚è°ƒç”¨è€…æ˜¯å¯å˜çš„ï¼Œ`&amp;mut self` æ˜¯ `self: &amp;mut Self` çš„è¯­æ³•ç³–
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` æŒæœ‰ä¸¤ä¸ªåˆ†é…åœ¨å †ä¸Šçš„æ•´æ•°
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // è¯¥æ–¹æ³•ä¼šæ‹¿èµ°è°ƒç”¨è€…çš„æ‰€æœ‰æƒ
    // `self` æ˜¯ `self: Self` çš„è¯­æ³•ç³–
    fn destroy(self) {
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);

        // `first` å’Œ `second` åœ¨è¿™é‡Œè¶…å‡ºä½œç”¨åŸŸå¹¶è¢«é‡Šæ”¾
    }
}

fn main() {
    let rectangle = Rectangle {
        // å…³è”å‡½æ•°çš„è°ƒç”¨ä¸æ˜¯é€šè¿‡ç‚¹æ“ä½œç¬¦ï¼Œè€Œæ˜¯ä½¿ç”¨ `::`
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // æ–¹æ³•æ‰æ˜¯é€šè¿‡ç‚¹æ“ä½œç¬¦è°ƒç”¨
    // æ³¨æ„ï¼Œè¿™é‡Œçš„æ–¹æ³•éœ€è¦çš„æ˜¯ `&amp;self` ä½†æ˜¯æˆ‘ä»¬å¹¶æ²¡æœ‰ä½¿ç”¨ `(&amp;rectangle).perimeter()` æ¥è°ƒç”¨ï¼ŒåŸå› åœ¨äºï¼š
    // ç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬è‡ªåŠ¨å–å¼•ç”¨
    //  `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };


    // é”™è¯¯ï¼`rectangle` æ˜¯ä¸å¯å˜çš„ï¼Œä½†æ˜¯è¿™ä¸ªæ–¹æ³•è¦æ±‚ä¸€ä¸ªå¯å˜çš„å¯¹è±¡
    //rectangle.translate(1.0, 0.0);
    // TODO ^ è¯•ç€åæ³¨é‡Šæ­¤è¡Œï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆ

    // å¯ä»¥ï¼å¯å˜å¯¹è±¡å¯ä»¥è°ƒç”¨å¯å˜çš„æ–¹æ³•
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // Error! ä¸Šä¸€ä¸ª `destroy` è°ƒç”¨æ‹¿èµ°äº† `pair` çš„æ‰€æœ‰æƒ
    //pair.destroy();
    // TODO ^ è¯•ç€åæ³¨é‡Šæ­¤è¡Œ
}</code></pre></pre>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<h3 id="method"><a class="header" href="#method">Method</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ æ–¹æ³•è·Ÿå‡½æ•°ç±»ä¼¼ï¼šéƒ½æ˜¯ä½¿ç”¨ <code>fn</code> å£°æ˜ï¼Œæœ‰å‚æ•°å’Œè¿”å›å€¼ã€‚ä½†æ˜¯ä¸å‡½æ•°ä¸åŒçš„æ˜¯ï¼Œæ–¹æ³•å®šä¹‰åœ¨ç»“æ„ä½“çš„ä¸Šä¸‹æ–‡ä¸­(æšä¸¾ã€ç‰¹å¾å¯¹è±¡ä¹Ÿå¯ä»¥å®šä¹‰æ–¹æ³•)ï¼Œè€Œä¸”æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸€å®šæ˜¯ <code>self</code> æˆ–å…¶å˜ä½“ <code>&amp;self</code> ã€<code>&amp;mut self</code>ï¼Œ<code>self</code> ä»£è¡¨äº†å½“å‰è°ƒç”¨çš„ç»“æ„ä½“å®ä¾‹ã€‚</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // å®Œæˆ area æ–¹æ³•ï¼Œè¿”å›çŸ©å½¢ Rectangle çš„é¢ç§¯
    fn area
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    assert_eq!(rect1.area(), 1500);
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ <code>self</code> ä¼šæ‹¿èµ°å½“å‰ç»“æ„ä½“å®ä¾‹(è°ƒç”¨å¯¹è±¡)çš„æ‰€æœ‰æƒï¼Œè€Œ <code>&amp;self</code> å´åªä¼šå€Ÿç”¨ä¸€ä¸ªä¸å¯å˜å¼•ç”¨ï¼Œ<code>&amp;mut self</code> ä¼šå€Ÿç”¨ä¸€ä¸ªå¯å˜å¼•ç”¨</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// åªå¡«ç©ºï¼Œä¸è¦åˆ é™¤ä»»ä½•ä»£ç è¡Œ!
#[derive(Debug)]
struct TrafficLight {
    color: String,
}

impl TrafficLight {
    pub fn show_state(__)  {
        println!(&quot;the current state is {}&quot;, __.color);
    }
}
fn main() {
    let light = TrafficLight{
        color: &quot;red&quot;.to_owned(),
    };
    // ä¸è¦æ‹¿èµ° `light` çš„æ‰€æœ‰æƒ
    light.show_state();
    // å¦åˆ™ä¸‹é¢ä»£ç ä¼šæŠ¥é”™
    println!(&quot;{:?}&quot;, light);
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ  <code>&amp;self</code> å®é™…ä¸Šæ˜¯ <code>self: &amp;Self</code> çš„ç¼©å†™æˆ–è€…è¯´è¯­æ³•ç³–</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct TrafficLight {
    color: String,
}

impl TrafficLight {
    // ä½¿ç”¨ `Self` å¡«ç©º
    pub fn show_state(__)  {
        println!(&quot;the current state is {}&quot;, self.color);
    }

    // å¡«ç©ºï¼Œä¸è¦ä½¿ç”¨ `Self` æˆ–å…¶å˜ä½“
    pub fn change_state(__) {
        self.color = &quot;green&quot;.to_string()
    }
}
fn main() {}</code></pre></pre>
<h3 id="associated-function"><a class="header" href="#associated-function">Associated function</a></h3>
<ol start="4">
<li>ğŸŒŸğŸŒŸ  å®šä¹‰åœ¨ <code>impl</code> è¯­å¥å—ä¸­çš„å‡½æ•°è¢«ç§°ä¸ºå…³è”å‡½æ•°ï¼Œå› ä¸ºå®ƒä»¬è·Ÿå½“å‰ç±»å‹å…³è”åœ¨ä¸€èµ·ã€‚å…³è”å‡½æ•°ä¸æ–¹æ³•æœ€å¤§çš„åŒºåˆ«å°±æ˜¯å®ƒç¬¬ä¸€ä¸ªå‚æ•°ä¸æ˜¯ <code>self</code> ï¼ŒåŸå› æ˜¯å®ƒä»¬ä¸éœ€è¦ä½¿ç”¨å½“å‰çš„å®ä¾‹ï¼Œå› æ­¤å…³è”å‡½æ•°å¾€å¾€å¯ä»¥ç”¨äºæ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–ä¸€ä¸ªå®ä¾‹å¯¹è±¡ã€‚</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct TrafficLight {
    color: String,
}

impl TrafficLight {
    // 1. å®ç°ä¸‹é¢çš„å…³è”å‡½æ•° `new`,
    // 2. è¯¥å‡½æ•°è¿”å›ä¸€ä¸ª TrafficLight å®ä¾‹ï¼ŒåŒ…å« `color` &quot;red&quot;
    // 3. è¯¥å‡½æ•°å¿…é¡»ä½¿ç”¨ `Self` ä½œä¸ºç±»å‹ï¼Œä¸èƒ½åœ¨ç­¾åæˆ–è€…å‡½æ•°ä½“ä¸­ä½¿ç”¨ `TrafficLight`
    pub fn new() 

    pub fn get_state(&amp;self) -&gt; &amp;str {
        &amp;self.color
    }
}

fn main() {
    let light = TrafficLight::new();
    assert_eq!(light.get_state(), &quot;red&quot;);
}</code></pre></pre>
<h3 id="å¤šä¸ª-impl-è¯­å¥å—"><a class="header" href="#å¤šä¸ª-impl-è¯­å¥å—">å¤šä¸ª <code>impl</code> è¯­å¥å—</a></h3>
<ol start="5">
<li>ğŸŒŸ æ¯ä¸€ä¸ªç»“æ„ä½“å…è®¸æ‹¥æœ‰å¤šä¸ª <code>impl</code> è¯­å¥å—</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Rectangle {
    width: u32,
    height: u32,
}

// ä½¿ç”¨å¤šä¸ª `impl` è¯­å¥å—é‡å†™ä¸‹é¢çš„ä»£ç 
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}


fn main() {}</code></pre></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸ æˆ‘ä»¬è¿˜å¯ä»¥ä¸ºæšä¸¾ç±»å‹å®šä¹‰æ–¹æ³•</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
enum TrafficLightColor {
    Red,
    Yellow,
    Green,
}

// ä¸º TrafficLightColor å®ç°æ‰€éœ€çš„æ–¹æ³•
impl TrafficLightColor {
    
}

fn main() {
    let c = TrafficLightColor::Yellow;

    assert_eq!(c.color(), &quot;yellow&quot;);

    println!(&quot;{:?}&quot;,c);
}</code></pre></pre>
<h2 id="practice"><a class="header" href="#practice">Practice</a></h2>
<p>@todo</p>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/method.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-traits"><a class="header" href="#generics-and-traits">Generics and Traits</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ³›å‹"><a class="header" href="#æ³›å‹">æ³›å‹</a></h1>
<h3 id="å‡½æ•°-1"><a class="header" href="#å‡½æ•°-1">å‡½æ•°</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
struct A;          // å…·ä½“çš„ç±»å‹ `A`.
struct S(A);       // å…·ä½“çš„ç±»å‹ `S`.
struct SGen&lt;T&gt;(T); // æ³›å‹ `SGen`.

fn reg_fn(_s: S) {}

fn gen_spec_t(_s: SGen&lt;A&gt;) {}

fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // ä½¿ç”¨éæ³›å‹å‡½æ•°
    reg_fn(__);          // å…·ä½“çš„ç±»å‹
    gen_spec_t(__);   // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•°  `A`.
    gen_spec_i32(__); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•°`i32`.

    // æ˜¾å¼åœ°æŒ‡å®šç±»å‹å‚æ•° `char`
    generic::&lt;char&gt;(__);

    // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•° `char`.
    generic(__);
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å®ç°ä¸‹é¢çš„æ³›å‹å‡½æ•° sum
fn sum

fn main() {
    assert_eq!(5, sum(2i8, 3i8));
    assert_eq!(50, sum(20, 30));
    assert_eq!(2.46, sum(1.23, 1.23));
}</code></pre></pre>
<h3 id="ç»“æ„ä½“å’Œ-impl"><a class="header" href="#ç»“æ„ä½“å’Œ-impl">ç»“æ„ä½“å’Œ <code>impl</code></a></h3>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å®ç°ä¸€ä¸ªç»“æ„ä½“ Point è®©ä»£ç å·¥ä½œ


fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®æ”¹ä»¥ä¸‹ç»“æ„ä½“è®©ä»£ç å·¥ä½œ
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    // ä¸è¦ä¿®æ”¹è¿™è¡Œä»£ç ï¼
    let p = Point{x: 5, y : &quot;hello&quot;.to_string()};
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¸º Val å¢åŠ æ³›å‹å‚æ•°ï¼Œä¸è¦ä¿®æ”¹ `main` ä¸­çš„ä»£ç 
struct Val {
    val: f64,
}

impl Val {
    fn value(&amp;self) -&gt; &amp;f64 {
        &amp;self.val
    }
}


fn main() {
    let x = Val{ val: 3.0 };
    let y = Val{ val: &quot;hello&quot;.to_string()};
    println!(&quot;{}, {}&quot;, x.value(), y.value());
}</code></pre></pre>
<h3 id="æ–¹æ³•"><a class="header" href="#æ–¹æ³•">æ–¹æ³•</a></h3>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    // å®ç° mixupï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç ï¼
    fn mixup
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'ä¸­'};

    let p3 = p1.mixup(p2);

    assert_eq!(p3.x, 5);
    assert_eq!(p3.y, 'ä¸­');
}</code></pre></pre>
<ol start="7">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯ï¼Œè®©ä»£ç å·¥ä½œ
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let p = Point{x: 5, y: 10};
    println!(&quot;{}&quot;,p.distance_from_origin())
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/generics.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="const-æ³›å‹"><a class="header" href="#const-æ³›å‹">Const æ³›å‹</a></h1>
<p>åœ¨ä¹‹å‰çš„æ³›å‹ä¸­ï¼Œå¯ä»¥æŠ½è±¡ä¸ºä¸€å¥è¯ï¼šé’ˆå¯¹ç±»å‹å®ç°çš„æ³›å‹ï¼Œæ‰€æœ‰çš„æ³›å‹éƒ½æ˜¯ä¸ºäº†æŠ½è±¡ä¸åŒçš„ç±»å‹ï¼Œé‚£æœ‰æ²¡æœ‰é’ˆå¯¹å€¼çš„æ³›å‹ï¼Ÿç­”æ¡ˆå°±æ˜¯ <code>Const æ³›å‹</code>ã€‚</p>
<h2 id="ç¤ºä¾‹-4"><a class="header" href="#ç¤ºä¾‹-4">ç¤ºä¾‹</a></h2>
<ol>
<li>ä¸‹é¢çš„ä¾‹å­åŒæ—¶ä½¿ç”¨æ³›å‹å’Œ const æ³›å‹æ¥å®ç°ä¸€ä¸ªç»“æ„ä½“ï¼Œè¯¥ç»“æ„ä½“çš„å­—æ®µä¸­çš„æ•°ç»„é•¿åº¦æ˜¯å¯å˜çš„</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct ArrayPair&lt;T, const N: usize&gt; {
    left: [T; N],
    right: [T; N],
}

impl&lt;T: Debug, const N: usize&gt; Debug for ArrayPair&lt;T, N&gt; {
    // ...
}</code></pre></pre>
<ol start="2">
<li>ç›®å‰ï¼Œconst æ³›å‹å‚æ•°åªèƒ½ä½¿ç”¨ä»¥ä¸‹å½¢å¼çš„å®å‚:</li>
</ol>
<ul>
<li>ä¸€ä¸ªå•ç‹¬çš„ const  æ³›å‹å‚æ•°</li>
<li>ä¸€ä¸ªå­—é¢é‡ (i.e. æ•´æ•°, å¸ƒå°”å€¼æˆ–å­—ç¬¦).</li>
<li>ä¸€ä¸ªå…·ä½“çš„ const è¡¨è¾¾å¼( è¡¨è¾¾å¼ä¸­ä¸èƒ½åŒ…å«ä»»ä½• æ³›å‹å‚æ•°)</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn foo&lt;const N: usize&gt;() {}

fn bar&lt;T, const M: usize&gt;() {
    foo::&lt;M&gt;(); // ok: ç¬¦åˆç¬¬ä¸€ç§
    foo::&lt;2021&gt;(); // ok: ç¬¦åˆç¬¬äºŒç§
    foo::&lt;{20 * 100 + 20 * 10 + 1}&gt;(); // ok: ç¬¦åˆç¬¬ä¸‰ç§
    
    foo::&lt;{ M + 1 }&gt;(); // error: è¿èƒŒç¬¬ä¸‰ç§ï¼Œconst è¡¨è¾¾å¼ä¸­ä¸èƒ½æœ‰æ³›å‹å‚æ•° M
    foo::&lt;{ std::mem::size_of::&lt;T&gt;() }&gt;(); // error: æ³›å‹è¡¨è¾¾å¼åŒ…å«äº†æ³›å‹å‚æ•° T
    
    let _: [u8; M]; // ok: ç¬¦åˆç¬¬ä¸€ç§
    let _: [u8; std::mem::size_of::&lt;T&gt;()]; // error: æ³›å‹è¡¨è¾¾å¼åŒ…å«äº†æ³›å‹å‚æ•° T
}

fn main() {}</code></pre></pre>
<ol start="3">
<li>const æ³›å‹è¿˜èƒ½å¸®æˆ‘ä»¬é¿å…ä¸€äº›è¿è¡Œæ—¶æ£€æŸ¥ï¼Œæå‡æ€§èƒ½</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">pub struct MinSlice&lt;T, const N: usize&gt; {
    pub head: [T; N],
    pub tail: [T],
}

fn main() {
    let slice: &amp;[u8] = b&quot;Hello, world&quot;;
    let reference: Option&lt;&amp;u8&gt; = slice.get(6);
    // æˆ‘ä»¬çŸ¥é“ `.get` è¿”å›çš„æ˜¯ `Some(b' ')`
    // ä½†ç¼–è¯‘å™¨ä¸çŸ¥é“
    assert!(reference.is_some());

    let slice: &amp;[u8] = b&quot;Hello, world&quot;;

    // å½“ç¼–è¯‘æ„å»º MinSlice æ—¶ä¼šè¿›è¡Œé•¿åº¦æ£€æŸ¥ï¼Œä¹Ÿå°±æ˜¯åœ¨ç¼–è¯‘æœŸæˆ‘ä»¬å°±çŸ¥é“å®ƒçš„é•¿åº¦æ˜¯ 12
    // åœ¨è¿è¡ŒæœŸï¼Œä¸€æ—¦ `unwrap` æˆåŠŸï¼Œåœ¨ `MinSlice` çš„ä½œç”¨åŸŸå†…ï¼Œå°±å†æ— éœ€ä»»ä½•æ£€æŸ¥    
    let minslice = MinSlice::&lt;u8, 12&gt;::from_slice(slice).unwrap();
    let value: u8 = minslice.head[6];
    assert_eq!(value, b' ')
}</code></pre></pre>
<h2 id="ç»ƒä¹ -3"><a class="header" href="#ç»ƒä¹ -3">ç»ƒä¹ </a></h2>
<ol>
<li>ğŸŒŸğŸŒŸ <code>&lt;T, const N: usize&gt;</code> æ˜¯ç»“æ„ä½“ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œå’Œæ•°ç»„ç±»å‹ä¸€æ ·ï¼Œè¿™æ„å‘³ç€é•¿åº¦ä¸åŒä¼šå¯¼è‡´ç±»å‹ä¸åŒï¼š <code>Array&lt;i32, 3&gt;</code> å’Œ <code>Array&lt;i32, 4&gt;</code> æ˜¯ä¸åŒçš„ç±»å‹</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯
struct Array&lt;T, const N: usize&gt; {
    data : [T; N]
}

fn main() {
    let arrays = [
        Array{
            data: [1, 2, 3],
        },
        Array {
            data: [1.0, 2.0, 3.0],
        },
        Array {
            data: [1, 2]
        }
    ];
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn print_array&lt;__&gt;(__) {
    println!(&quot;{:?}&quot;, arr);
}
fn main() {
    let arr = [1, 2, 3];
    print_array(arr);

    let arr = [&quot;hello&quot;, &quot;world&quot;];
    print_array(arr);
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ æœ‰æ—¶æˆ‘ä»¬å¸Œæœ›èƒ½é™åˆ¶ä¸€ä¸ªå˜é‡å ç”¨å†…å­˜çš„å¤§å°ï¼Œä¾‹å¦‚åœ¨åµŒå…¥å¼ç¯å¢ƒä¸­ï¼Œæ­¤æ—¶ const æ³›å‹å‚æ•°çš„ç¬¬ä¸‰ç§å½¢å¼ <code>const è¡¨è¾¾å¼</code> å°±éå¸¸é€‚åˆ.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#![allow(incomplete_features)]
#![feature(generic_const_exprs)]

fn check_size&lt;T&gt;(val: T)
where
    Assert&lt;{ core::mem::size_of::&lt;T&gt;() &lt; 768 }&gt;: IsTrue,
{
    //...
}

// ä¿®å¤ main å‡½æ•°ä¸­çš„é”™è¯¯
fn main() {
    check_size([0u8; 767]); 
    check_size([0i32; 191]);
    check_size([&quot;helloä½ å¥½&quot;; __]); // size of &amp;str ?
    check_size([(); __].map(|_| &quot;helloä½ å¥½&quot;.to_string()));  // size of String?
    check_size(['ä¸­'; __]); // size of char ?
}



pub enum Assert&lt;const CHECK: bool&gt; {}

pub trait IsTrue {}

impl IsTrue for Assert&lt;true&gt; {}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/const-generics.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>ç‰¹å¾ Trait å¯ä»¥å‘Šè¯‰ç¼–è¯‘å™¨ä¸€ä¸ªç‰¹å®šçš„ç±»å‹æ‰€å…·æœ‰çš„ã€ä¸”èƒ½è·Ÿå…¶å®ƒç±»å‹å…±äº«çš„ç‰¹æ€§ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç‰¹å¾é€šè¿‡æŠ½è±¡çš„æ–¹å¼æ¥å®šä¹‰è¿™ç§å…±äº«è¡Œä¸ºï¼Œè¿˜å¯ä»¥ä½¿ç”¨ç‰¹å¾çº¦æŸæ¥é™å®šä¸€ä¸ªæ³›å‹ç±»å‹å¿…é¡»è¦å…·æœ‰æŸä¸ªç‰¹å®šçš„è¡Œä¸ºã€‚</p>
<blockquote>
<p>Note: ç‰¹å¾è·Ÿå…¶å®ƒè¯­è¨€çš„æ¥å£è¾ƒä¸ºç±»ä¼¼ï¼Œä½†æ˜¯ä»ç„¶æœ‰ä¸€äº›åŒºåˆ«</p>
</blockquote>
<h2 id="ç¤ºä¾‹-5"><a class="header" href="#ç¤ºä¾‹-5">ç¤ºä¾‹</a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Sheep { naked: bool, name: String }

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // `Sheep` ç»“æ„ä½“ä¸Šå®šä¹‰çš„æ–¹æ³•å¯ä»¥è°ƒç”¨ `Sheep` æ‰€å®ç°çš„ç‰¹å¾çš„æ–¹æ³•
            println!(&quot;{} is already naked...&quot;, self.name());
        } else {
            println!(&quot;{} gets a haircut!&quot;, self.name);

            self.naked = true;
        }
    }
}


trait Animal {
    // å…³è”å‡½æ•°ç­¾åï¼›`Self` æŒ‡ä»£å®ç°è€…çš„ç±»å‹
    // ä¾‹å¦‚æˆ‘ä»¬åœ¨ä¸º Pig ç±»å‹å®ç°ç‰¹å¾æ—¶ï¼Œé‚£ `new` å‡½æ•°å°±ä¼šè¿”å›ä¸€ä¸ª `Pig` ç±»å‹çš„å®ä¾‹ï¼Œè¿™é‡Œçš„ `Self` æŒ‡ä»£çš„å°±æ˜¯ `Pig` ç±»å‹
    fn new(name: String) -&gt; Self;

    // æ–¹æ³•ç­¾å
    fn name(&amp;self) -&gt; String;
    
    fn noise(&amp;self) -&gt; String;

    // æ–¹æ³•è¿˜èƒ½æä¾›é»˜è®¤çš„å®šä¹‰å®ç°
    fn talk(&amp;self) {
        println!(&quot;{} says {}&quot;, self.name(), self.noise());
    }
}

impl Animal for Sheep {
    // `Self` è¢«æ›¿æ¢æˆå…·ä½“çš„å®ç°è€…ç±»å‹ï¼š `Sheep`
    fn new(name: String) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; String {
        self.name.clone()
    }

    fn noise(&amp;self) -&gt; String {
        if self.is_naked() {
            &quot;baaaaah?&quot;.to_string()
        } else {
            &quot;baaaaah!&quot;.to_string()
        }
    }
    
    // é»˜è®¤çš„ç‰¹å¾æ–¹æ³•å¯ä»¥è¢«é‡å†™
    fn talk(&amp;self) {
        println!(&quot;{} pauses briefly... {}&quot;, self.name, self.noise());
    }
}

fn main() {
    // è¿™é‡Œçš„ç±»å‹æ³¨é‡Šæ—¶å¿…é¡»çš„
    let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;.to_string());
    // TODO ^ å°è¯•å»é™¤ç±»å‹æ³¨é‡Šï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆ

    dolly.talk();
    dolly.shear();
    dolly.talk();
}</code></pre></pre>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å®Œæˆä¸¤ä¸ª `impl` è¯­å¥å—
// ä¸è¦ä¿®æ”¹ `main` ä¸­çš„ä»£ç 
trait Hello {
    fn say_hi(&amp;self) -&gt; String {
        String::from(&quot;hi&quot;)
    }

    fn say_something(&amp;self) -&gt; String;
}

struct Student {}
impl Hello for Student {
}
struct Teacher {}
impl Hello for Teacher {
}

fn main() {
    let s = Student {};
    assert_eq!(s.say_hi(), &quot;hi&quot;);
    assert_eq!(s.say_something(), &quot;I'm a good student&quot;);

    let t = Teacher {};
    assert_eq!(t.say_hi(), &quot;Hi, I'm your new teacher&quot;);
    assert_eq!(t.say_something(), &quot;I'm not a bad teacher&quot;);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="derive-æ´¾ç”Ÿ"><a class="header" href="#derive-æ´¾ç”Ÿ">Derive æ´¾ç”Ÿ</a></h3>
<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ <code>#[derive]</code> å±æ€§æ¥æ´¾ç”Ÿä¸€äº›ç‰¹å¾ï¼Œå¯¹äºè¿™äº›ç‰¹å¾ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨è¿›è¡Œé»˜è®¤å®ç°ï¼Œå¯¹äºæ—¥å¸¸ä»£ç å¼€å‘è€Œè¨€ï¼Œè¿™æ˜¯éå¸¸æ–¹ä¾¿çš„ï¼Œä¾‹å¦‚å¤§å®¶ç»å¸¸ç”¨åˆ°çš„ <code>Debug</code> ç‰¹å¾ï¼Œå°±æ˜¯ç›´æ¥é€šè¿‡æ´¾ç”Ÿæ¥è·å–é»˜è®¤å®ç°ï¼Œè€Œæ— éœ€æˆ‘ä»¬æ‰‹åŠ¨å»å®Œæˆè¿™ä¸ªå·¥ä½œã€‚</p>
<p>æƒ³è¦æŸ¥çœ‹æ›´å¤šä¿¡æ¯ï¼Œå¯ä»¥è®¿é—®<a href="https://course.rs/appendix/derive.html">è¿™é‡Œ</a>ã€‚</p>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// `Centimeters`, ä¸€ä¸ªå…ƒç»„ç»“æ„ä½“ï¼Œå¯ä»¥è¢«æ¯”è¾ƒå¤§å°
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`, ä¸€ä¸ªå…ƒç»„ç»“æ„ä½“å¯ä»¥è¢«æ‰“å°
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// æ·»åŠ ä¸€äº›å±æ€§è®©ä»£ç å·¥ä½œ
// ä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç ï¼
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    println!(&quot;One second looks like: {:?}&quot;, _one_second);
    let _this_is_true = _one_second == _one_second;
    let _this_is_false = _one_second &gt; _one_second;

    let foot = Inches(12);

    println!(&quot;One foot equals {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;smaller&quot;
        } else {
            &quot;bigger&quot;
        };

    println!(&quot;One foot is {} than one meter.&quot;, cmp);
}</code></pre></pre>
<h3 id="è¿ç®—ç¬¦"><a class="header" href="#è¿ç®—ç¬¦">è¿ç®—ç¬¦</a></h3>
<p>åœ¨ Rust ä¸­ï¼Œè®¸å¤šè¿ç®—ç¬¦éƒ½å¯ä»¥è¢«é‡è½½ï¼Œäº‹å®ä¸Šï¼Œè¿ç®—ç¬¦ä»…ä»…æ˜¯ç‰¹å¾æ–¹æ³•è°ƒç”¨çš„è¯­æ³•ç³–ã€‚ä¾‹å¦‚ <code>a + b</code> ä¸­çš„ <code>+</code> æ˜¯ <code>std::ops::Add</code> ç‰¹å¾çš„ <code>add</code> æ–¹æ³•è°ƒç”¨ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°è¯¥ç‰¹å¾æ¥æ”¯æŒè¯¥ç±»å‹çš„åŠ æ³•è¿ç®—ã€‚ </p>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::ops;

// å®ç° fn multiply æ–¹æ³•
// å¦‚ä¸Šæ‰€è¿°ï¼Œ`+` éœ€è¦ `T` ç±»å‹å®ç° `std::ops::Add` ç‰¹å¾
// é‚£ä¹ˆ, `*` è¿ç®—ç¬¦éœ€è¦å®ç°ä»€ä¹ˆç‰¹å¾å‘¢? ä½ å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ç­”æ¡ˆ: https://doc.rust-lang.org/core/ops/
fn multiply

fn main() {
    assert_eq!(6, multiply(2u8, 3u8));
    assert_eq!(5.0, multiply(1.0, 5.0));

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯ï¼Œä¸è¦ä¿®æ”¹ `main` ä¸­çš„ä»£ç !
use std::ops;

struct Foo;
struct Bar;

struct FooBar;

struct BarFoo;

// ä¸‹é¢çš„ä»£ç å®ç°äº†è‡ªå®šä¹‰ç±»å‹çš„ç›¸åŠ ï¼š Foo + Bar = FooBar
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        FooBar
    }
}

impl ops::Sub&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn sub(self, _rhs: Foo) -&gt; BarFoo {
        BarFoo
    }
}

fn main() {
    // ä¸è¦ä¿®æ”¹ä¸‹é¢ä»£ç 
    // ä½ éœ€è¦ä¸º FooBar æ´¾ç”Ÿä¸€äº›ç‰¹å¾æ¥è®©ä»£ç å·¥ä½œ
    assert_eq!(Foo + Bar, FooBar);
    assert_eq!(Foo - Bar, BarFoo);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="ä½¿ç”¨ç‰¹å¾ä½œä¸ºå‡½æ•°å‚æ•°"><a class="header" href="#ä½¿ç”¨ç‰¹å¾ä½œä¸ºå‡½æ•°å‚æ•°">ä½¿ç”¨ç‰¹å¾ä½œä¸ºå‡½æ•°å‚æ•°</a></h3>
<p>é™¤äº†ä½¿ç”¨å…·ä½“ç±»å‹æ¥ä½œä¸ºå‡½æ•°å‚æ•°ï¼Œæˆ‘ä»¬è¿˜èƒ½é€šè¿‡ <code>impl Trait</code> çš„æ–¹å¼æ¥æŒ‡å®šå®ç°äº†è¯¥ç‰¹å¾çš„å‚æ•°ï¼šè¯¥å‚æ•°èƒ½æ¥å—çš„ç±»å‹å¿…é¡»è¦å®ç°æŒ‡å®šçš„ç‰¹å¾ã€‚</p>
<ol start="5">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å®ç° `fn summary` 
// ä¿®å¤é”™è¯¯ä¸”ä¸è¦ç§»é™¤ä»»ä½•ä»£ç è¡Œ
trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

#[derive(Debug)]
struct Post {
    title: String,
    author: String,
    content: String,
}

impl Summary for Post {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;The author of post {} is {}&quot;, self.title, self.author)
    }
}

#[derive(Debug)]
struct Weibo {
    username: String,
    content: String,
}

impl Summary for Weibo {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{} published a weibo {}&quot;, self.username, self.content)
    }
}

fn main() {
    let post = Post {
        title: &quot;Popular Rust&quot;.to_string(),
        author: &quot;Sunface&quot;.to_string(),
        content: &quot;Rust is awesome!&quot;.to_string(),
    };
    let weibo = Weibo {
        username: &quot;sunface&quot;.to_string(),
        content: &quot;Weibo seems to be worse than Tweet&quot;.to_string(),
    };

    summary(post);
    summary(weibo);

    println!(&quot;{:?}&quot;, post);
    println!(&quot;{:?}&quot;, weibo);
}

// åœ¨ä¸‹é¢å®ç° `fn summary` å‡½æ•°
</code></pre></pre>
<h3 id="ä½¿ç”¨ç‰¹å¾ä½œä¸ºå‡½æ•°è¿”å›å€¼"><a class="header" href="#ä½¿ç”¨ç‰¹å¾ä½œä¸ºå‡½æ•°è¿”å›å€¼">ä½¿ç”¨ç‰¹å¾ä½œä¸ºå‡½æ•°è¿”å›å€¼</a></h3>
<p>æˆ‘ä»¬è¿˜å¯ä»¥åœ¨å‡½æ•°çš„è¿”å›å€¼ä¸­ä½¿ç”¨ <code>impl Trait</code> è¯­æ³•ã€‚ç„¶ååªæœ‰åœ¨è¿”å›å€¼æ˜¯åŒä¸€ä¸ªç±»å‹æ—¶ï¼Œæ‰èƒ½è¿™ä¹ˆä½¿ç”¨ï¼Œå¦‚æœè¿”å›å€¼æ˜¯ä¸åŒçš„ç±»å‹ï¼Œä½ å¯èƒ½æ›´éœ€è¦ç‰¹å¾å¯¹è±¡ã€‚</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Sheep {}
struct Cow {}

trait Animal {
    fn noise(&amp;self) -&gt; String;
}

impl Animal for Sheep {
    fn noise(&amp;self) -&gt; String {
        &quot;baaaaah!&quot;.to_string()
    }
}

impl Animal for Cow {
    fn noise(&amp;self) -&gt; String {
        &quot;moooooo!&quot;.to_string()
    }
}

// è¿”å›ä¸€ä¸ªç±»å‹ï¼Œè¯¥ç±»å‹å®ç°äº† Animal ç‰¹å¾ï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶ä¸èƒ½åœ¨ç¼–è¯‘æœŸè·çŸ¥å…·ä½“è¿”å›äº†å“ªä¸ªç±»å‹
// ä¿®å¤è¿™é‡Œçš„é”™è¯¯ï¼Œä½ å¯ä»¥ä½¿ç”¨è™šå‡çš„éšæœºï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ç‰¹å¾å¯¹è±¡
fn random_animal(random_number: f64) -&gt; impl Animal {
    if random_number &lt; 0.5 {
        Sheep {}
    } else {
        Cow {}
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!(&quot;You've randomly chosen an animal, and it says {}&quot;, animal.noise());
}</code></pre></pre>
<h3 id="ç‰¹å¾çº¦æŸ"><a class="header" href="#ç‰¹å¾çº¦æŸ">ç‰¹å¾çº¦æŸ</a></h3>
<p><code>impl Trait</code> è¯­æ³•éå¸¸ç›´è§‚ç®€æ´ï¼Œä½†å®ƒå®é™…ä¸Šæ˜¯ç‰¹å¾çº¦æŸçš„è¯­æ³•ç³–ã€‚</p>
<p>å½“ä½¿ç”¨æ³›å‹å‚æ•°æ—¶ï¼Œæˆ‘ä»¬å¾€å¾€éœ€è¦ä¸ºè¯¥å‚æ•°æŒ‡å®šç‰¹å®šçš„è¡Œä¸ºï¼Œè¿™ç§æŒ‡å®šæ–¹å¼å°±æ˜¯é€šè¿‡ç‰¹å¾çº¦æŸæ¥å®ç°çš„ã€‚</p>
<ol start="7">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(sum(1, 2), 3);
}

// é€šè¿‡ä¸¤ç§æ–¹æ³•ä½¿ç”¨ç‰¹å¾çº¦æŸæ¥å®ç° `fn sum`
fn sum&lt;T&gt;(x: T, y: T) -&gt; T {
    x + y
}</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä¿®å¤ä»£ç ä¸­çš„é”™è¯¯
struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: std::fmt::Debug + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {:?}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {:?}&quot;, self.y);
        }
    }
}

struct Unit(i32);

fn main() {
    let pair = Pair{
        x: Unit(1),
        y: Unit(3)
    };

    pair.cmp_display();
}</code></pre></pre>
<ol start="9">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn example1() {
    // `T: Trait` æ˜¯æœ€å¸¸ä½¿ç”¨çš„æ–¹å¼
    // `T: Fn(u32) -&gt; u32` è¯´æ˜ `T` åªèƒ½æ¥æ”¶é—­åŒ…ç±»å‹çš„å‚æ•°
    struct Cacher&lt;T: Fn(u32) -&gt; u32&gt; {
        calculation: T,
        value: Option&lt;u32&gt;,
    }

    impl&lt;T: Fn(u32) -&gt; u32&gt; Cacher&lt;T&gt; {
        fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
            Cacher {
                calculation,
                value: None,
            }
        }

        fn value(&amp;mut self, arg: u32) -&gt; u32 {
            match self.value {
                Some(v) =&gt; v,
                None =&gt; {
                    let v = (self.calculation)(arg);
                    self.value = Some(v);
                    v
                },
            }
        }
    }

    let mut cacher = Cacher::new(|x| x+1);
    assert_eq!(cacher.value(10), __);
    assert_eq!(cacher.value(15), __);
}


fn example2() {
    // è¿˜å¯ä»¥ä½¿ç”¨ `where` æ¥çº¦æŸ T
    struct Cacher&lt;T&gt;
        where T: Fn(u32) -&gt; u32,
    {
        calculation: T,
        value: Option&lt;u32&gt;,
    }

    impl&lt;T&gt; Cacher&lt;T&gt;
        where T: Fn(u32) -&gt; u32,
    {
        fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
            Cacher {
                calculation,
                value: None,
            }
        }

        fn value(&amp;mut self, arg: u32) -&gt; u32 {
            match self.value {
                Some(v) =&gt; v,
                None =&gt; {
                    let v = (self.calculation)(arg);
                    self.value = Some(v);
                    v
                },
            }
        }
    }

    let mut cacher = Cacher::new(|x| x+1);
    assert_eq!(cacher.value(20), __);
    assert_eq!(cacher.value(25), __);
}



fn main() {
    example1();
    example2();

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/traits.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç‰¹å¾å¯¹è±¡"><a class="header" href="#ç‰¹å¾å¯¹è±¡">ç‰¹å¾å¯¹è±¡</a></h1>
<p>åœ¨<a href="https://practice.rs/generics-traits/traits.html#returning-types-that-implement-traits">ç‰¹å¾ç»ƒä¹ ä¸­</a> æˆ‘ä»¬å·²ç»çŸ¥é“å½“å‡½æ•°è¿”å›å¤šä¸ªç±»å‹æ—¶ï¼Œ<code>impl Trait</code> æ˜¯æ— æ³•ä½¿ç”¨çš„ã€‚</p>
<p>å¯¹äºæ•°ç»„è€Œè¨€ï¼Œå…¶ä¸­ä¸€ä¸ªé™åˆ¶å°±æ˜¯æ— æ³•å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ ï¼Œä½†æ˜¯é€šè¿‡ä¹‹å‰çš„å­¦ä¹ ï¼Œå¤§å®¶åº”è¯¥çŸ¥é“æšä¸¾å¯ä»¥åœ¨éƒ¨åˆ†åœºæ™¯è§£å†³è¿™ç§é—®é¢˜ï¼Œä½†æ˜¯è¿™ç§æ–¹æ³•å±€é™æ€§è¾ƒå¤§ã€‚æ­¤æ—¶å°±éœ€è¦æˆ‘ä»¬çš„ä¸»è§’ç™»åœºäº†ã€‚</p>
<h2 id="ä½¿ç”¨-dyn-è¿”å›ç‰¹å¾"><a class="header" href="#ä½¿ç”¨-dyn-è¿”å›ç‰¹å¾">ä½¿ç”¨ <code>dyn</code> è¿”å›ç‰¹å¾</a></h2>
<p>Rust ç¼–è¯‘å™¨éœ€è¦çŸ¥é“ä¸€ä¸ªå‡½æ•°çš„è¿”å›ç±»å‹å ç”¨å¤šå°‘å†…å­˜ç©ºé—´ã€‚ç”±äºç‰¹å¾çš„ä¸åŒå®ç°ç±»å‹å¯èƒ½ä¼šå ç”¨ä¸åŒçš„å†…å­˜ï¼Œå› æ­¤é€šè¿‡ <code>impl Trait</code> è¿”å›å¤šä¸ªç±»å‹æ˜¯ä¸è¢«å…è®¸çš„ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥è¿”å›ä¸€ä¸ª <code>dyn</code> ç‰¹å¾å¯¹è±¡æ¥è§£å†³é—®é¢˜ã€‚</p>
<ol>
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Bird {
    fn quack(&amp;self) -&gt; String;
}

struct Duck;
impl Duck {
    fn swim(&amp;self) {
        println!(&quot;Look, the duck is swimming&quot;)
    }
}
struct Swan;
impl Swan {
    fn fly(&amp;self) {
        println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;)
    }
}

impl Bird for Duck {
    fn quack(&amp;self) -&gt; String{
        &quot;duck duck&quot;.to_string()
    }
}

impl Bird for Swan {
    fn quack(&amp;self) -&gt; String{
        &quot;swan swan&quot;.to_string()
    }
}

fn main() {
    // å¡«ç©º
    let duck = __;
    duck.swim();

    let bird = hatch_a_bird(2);
    // å˜æˆé¸Ÿå„¿åï¼Œå®ƒå¿˜è®°äº†å¦‚ä½•æ¸¸ï¼Œå› æ­¤ä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™
    // bird.swim();
    // ä½†å®ƒä¾ç„¶å¯ä»¥å«å”¤
    assert_eq!(bird.quack(), &quot;duck duck&quot;);

    let bird = hatch_a_bird(1);
    // è¿™åªé¸Ÿå„¿å¿˜äº†å¦‚ä½•é£ç¿”ï¼Œå› æ­¤ä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™
    // bird.fly();
    // ä½†å®ƒä¹Ÿå¯ä»¥å«å”¤
    assert_eq!(bird.quack(), &quot;swan swan&quot;);

    println!(&quot;Success!&quot;)
}   

// å®ç°ä»¥ä¸‹å‡½æ•°
fn hatch_a_bird...
</code></pre></pre>
<h2 id="åœ¨æ•°ç»„ä¸­ä½¿ç”¨ç‰¹å¾å¯¹è±¡"><a class="header" href="#åœ¨æ•°ç»„ä¸­ä½¿ç”¨ç‰¹å¾å¯¹è±¡">åœ¨æ•°ç»„ä¸­ä½¿ç”¨ç‰¹å¾å¯¹è±¡</a></h2>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Bird {
    fn quack(&amp;self);
}

struct Duck;
impl Duck {
    fn fly(&amp;self) {
        println!(&quot;Look, the duck is flying&quot;)
    }
}
struct Swan;
impl Swan {
    fn fly(&amp;self) {
        println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;)
    }
}

impl Bird for Duck {
    fn quack(&amp;self) {
        println!(&quot;{}&quot;, &quot;duck duck&quot;);
    }
}

impl Bird for Swan {
    fn quack(&amp;self) {
        println!(&quot;{}&quot;, &quot;swan swan&quot;);
    }
}

fn main() {
    // å¡«ç©º
    let birds __;

    for bird in birds {
        bird.quack();
        // å½“ duck å’Œ swan å˜æˆ bird åï¼Œå®ƒä»¬éƒ½å¿˜äº†å¦‚ä½•ç¿±ç¿”äºå¤©é™…ï¼Œåªè®°å¾—è¯¥æ€ä¹ˆå«å”¤äº†ã€‚ã€‚
        // å› æ­¤ï¼Œä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™
        // bird.fly();
    }
}</code></pre></pre>
<h2 id="dyn-and-boxdyn"><a class="header" href="#dyn-and-boxdyn"><code>&amp;dyn</code> and <code>Box&lt;dyn&gt;</code></a></h2>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
trait Draw {
    fn draw(&amp;self) -&gt; String;
}

impl Draw for u8 {
    fn draw(&amp;self) -&gt; String {
        format!(&quot;u8: {}&quot;, *self)
    }
}

impl Draw for f64 {
    fn draw(&amp;self) -&gt; String {
        format!(&quot;f64: {}&quot;, *self)
    }
}

fn main() {
    let x = 1.1f64;
    let y = 8u8;

    // draw x
    draw_with_box(__);

    // draw y
    draw_with_ref(&amp;y);

    println!(&quot;Success!&quot;)
}

fn draw_with_box(x: Box&lt;dyn Draw&gt;) {
    x.draw();
}

fn draw_with_ref(x: __) {
    x.draw();
}</code></pre></pre>
<h2 id="é™æ€åˆ†å‘å’ŒåŠ¨æ€åˆ†å‘static-and-dynamic-dispatch"><a class="header" href="#é™æ€åˆ†å‘å’ŒåŠ¨æ€åˆ†å‘static-and-dynamic-dispatch">é™æ€åˆ†å‘å’ŒåŠ¨æ€åˆ†å‘Static and Dynamic dispatch</a></h2>
<p>å…³äºè¿™å—å†…å®¹çš„è§£æä»‹ç»ï¼Œè¯·å‚è§ <a href="https://course.rs/basic/trait/trait-object.html#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91">Rustè¯­è¨€åœ£ç»</a>ã€‚</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Foo {
    fn method(&amp;self) -&gt; String;
}

impl Foo for u8 {
    fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) }
}

impl Foo for String {
    fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) }
}

// é€šè¿‡æ³›å‹å®ç°ä»¥ä¸‹å‡½æ•°
fn static_dispatch...

// é€šè¿‡ç‰¹å¾å¯¹è±¡å®ç°ä»¥ä¸‹å‡½æ•°
fn dynamic_dispatch...

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    static_dispatch(x);
    dynamic_dispatch(&amp;y);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h2 id="å¯¹è±¡å®‰å…¨"><a class="header" href="#å¯¹è±¡å®‰å…¨">å¯¹è±¡å®‰å…¨</a></h2>
<p>ä¸€ä¸ªç‰¹å¾èƒ½å˜æˆç‰¹å¾å¯¹è±¡ï¼Œé¦–å…ˆè¯¥ç‰¹å¾å¿…é¡»æ˜¯å¯¹è±¡å®‰å…¨çš„ï¼Œå³è¯¥ç‰¹å¾çš„æ‰€æœ‰æ–¹æ³•éƒ½å¿…é¡»æ‹¥æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š</p>
<ul>
<li>è¿”å›ç±»å‹ä¸èƒ½æ˜¯ <code>Self</code>.</li>
<li>ä¸èƒ½ä½¿ç”¨æ³›å‹å‚æ•°</li>
</ul>
<ol start="5">
<li>ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä½¿ç”¨è‡³å°‘ä¸¤ç§æ–¹æ³•è®©ä»£ç å·¥ä½œ
// ä¸è¦æ·»åŠ /åˆ é™¤ä»»ä½•ä»£ç è¡Œ
trait MyTrait {
    fn f(&amp;self) -&gt; Self;
}

impl MyTrait for u32 {
    fn f(&amp;self) -&gt; Self { 42 }
}

impl MyTrait for String {
    fn f(&amp;self) -&gt; Self { self.clone() }
}

fn my_function(x: Box&lt;dyn MyTrait&gt;)  {
    x.f()
}

fn main() {
    my_function(Box::new(13_u32));
    my_function(Box::new(String::from(&quot;abc&quot;)));

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/trait-object.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è¿›ä¸€æ­¥æ·±å…¥ç‰¹å¾"><a class="header" href="#è¿›ä¸€æ­¥æ·±å…¥ç‰¹å¾">è¿›ä¸€æ­¥æ·±å…¥ç‰¹å¾</a></h1>
<h2 id="å…³è”ç±»å‹"><a class="header" href="#å…³è”ç±»å‹">å…³è”ç±»å‹</a></h2>
<p>å…³è”ç±»å‹ä¸»è¦ç”¨äºæå‡ä»£ç çš„å¯è¯»æ€§ï¼Œä¾‹å¦‚ä»¥ä¸‹ä»£ç  :</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait CacheableItem: Clone + Default + fmt::Debug + Decodable + Encodable {
  type Address: AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash;
  fn is_null(&amp;self) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<p>ç›¸æ¯” <code>AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash</code>ï¼Œ <code>Address</code> çš„ä½¿ç”¨å¯ä»¥æå¤§çš„å‡å°‘å…¶å®ƒç±»å‹åœ¨å®ç°è¯¥ç‰¹å¾æ—¶æ‰€éœ€çš„æ¨¡ç‰ˆä»£ç .</p>
<ol>
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Container(i32, i32);

// ä½¿ç”¨å…³è”ç±»å‹å®ç°é‡æ–°å®ç°ä»¥ä¸‹ç‰¹å¾
// trait Contains {
//    type A;
//    type B;

trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains&lt;i32, i32&gt; for Container {
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }
    // Grab the first number.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;A, B, C: Contains&lt;A, B&gt;&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());
    
    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}</code></pre></pre>
<h2 id="å®šä¹‰é»˜è®¤çš„æ³›å‹ç±»å‹å‚æ•°"><a class="header" href="#å®šä¹‰é»˜è®¤çš„æ³›å‹ç±»å‹å‚æ•°">å®šä¹‰é»˜è®¤çš„æ³›å‹ç±»å‹å‚æ•°</a></h2>
<p>å½“æˆ‘ä»¬ä½¿ç”¨æ³›å‹ç±»å‹å‚æ•°æ—¶ï¼Œå¯ä»¥ä¸ºè¯¥æ³›å‹å‚æ•°æŒ‡å®šä¸€ä¸ªå…·ä½“çš„é»˜è®¤ç±»å‹ï¼Œè¿™æ ·å½“å®ç°è¯¥ç‰¹å¾æ—¶ï¼Œå¦‚æœè¯¥é»˜è®¤ç±»å‹å¯ä»¥ä½¿ç”¨ï¼Œé‚£ç”¨æˆ·å†æ— éœ€æ‰‹åŠ¨æŒ‡å®šå…·ä½“çš„ç±»å‹ã€‚</p>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::ops::Sub;

#[derive(Debug, PartialEq)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

// ç”¨ä¸‰ç§æ–¹æ³•å¡«ç©º: å…¶ä¸­ä¸¤ç§ä½¿ç”¨é»˜è®¤çš„æ³›å‹å‚æ•°ï¼Œå¦å¤–ä¸€ç§ä¸ä½¿ç”¨
impl __ {
    type Output = Self;

    fn sub(self, other: Self) -&gt; Self::Output {
        Point {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 2, y: 3 } - Point { x: 1, y: 0 },
        Point { x: 1, y: 3 });

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h2 id="å®Œå…¨é™å®šè¯­æ³•"><a class="header" href="#å®Œå…¨é™å®šè¯­æ³•">å®Œå…¨é™å®šè¯­æ³•</a></h2>
<p>åœ¨ Rust ä¸­ï¼Œä¸¤ä¸ªä¸åŒç‰¹å¾çš„æ–¹æ³•å®Œå…¨å¯ä»¥åŒåï¼Œä¸”ä½ å¯ä»¥ä¸ºåŒä¸€ä¸ªç±»å‹åŒæ—¶å®ç°è¿™ä¸¤ä¸ªç‰¹å¾ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œå°±å‡ºç°äº†ä¸€ä¸ªé—®é¢˜ï¼šè¯¥å¦‚ä½•è°ƒç”¨è¿™ä¸¤ä¸ªç‰¹å¾ä¸Šå®šä¹‰çš„åŒåæ–¹æ³•ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨å®Œå…¨é™å®šè¯­æ³•( Fully Qualified Syntax )ã€‚</p>
<h4 id="ç¤ºä¾‹-6"><a class="header" href="#ç¤ºä¾‹-6">ç¤ºä¾‹</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait UsernameWidget {
    fn get(&amp;self) -&gt; String;
}

trait AgeWidget {
    fn get(&amp;self) -&gt; u8;
}

struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&amp;self) -&gt; String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&amp;self) -&gt; u8 {
        self.age
    }
}

fn main() {
    let form = Form{
        username: &quot;rustacean&quot;.to_owned(),
        age: 28,
    };

    // å¦‚æœä½ åæ³¨é‡Šä¸‹é¢ä¸€è¡Œä»£ç ï¼Œå°†çœ‹åˆ°ä¸€ä¸ªé”™è¯¯: Fully Qualified Syntax
    // æ¯•ç«Ÿï¼Œè¿™é‡Œæœ‰å¥½å‡ ä¸ªåŒåçš„ `get` æ–¹æ³•
    // 
    // println!(&quot;{}&quot;, form.get());
    
    let username = UsernameWidget::get(&amp;form);
    assert_eq!(&quot;rustacean&quot;.to_owned(), username);
    let age = AgeWidget::get(&amp;form); // ä½ è¿˜å¯ä»¥ä½¿ç”¨ä»¥ä¸‹è¯­æ³• `&lt;Form as AgeWidget&gt;::get`
    assert_eq!(28, age);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h4 id="ç»ƒä¹ é¢˜"><a class="header" href="#ç»ƒä¹ é¢˜">ç»ƒä¹ é¢˜</a></h4>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Pilot {
    fn fly(&amp;self) -&gt; String;
}

trait Wizard {
    fn fly(&amp;self) -&gt; String;
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) -&gt; String {
        String::from(&quot;This is your captain speaking.&quot;)
    }
}

impl Wizard for Human {
    fn fly(&amp;self) -&gt; String {
        String::from(&quot;Up!&quot;)
    }
}

impl Human {
    fn fly(&amp;self) -&gt; String {
        String::from(&quot;*waving arms furiously*&quot;)
    }
}

fn main() {
    let person = Human;

    assert_eq!(__, &quot;This is your captain speaking.&quot;);
    assert_eq!(__, &quot;Up!&quot;);

    assert_eq!(__, &quot;*waving arms furiously*&quot;);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h2 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h2>
<p>æœ‰äº›æ—¶å€™æˆ‘ä»¬å¸Œæœ›åœ¨ç‰¹å¾ä¸Šå®ç°ç±»ä¼¼ç»§æ‰¿çš„ç‰¹æ€§ï¼Œä¾‹å¦‚è®©ä¸€ä¸ªç‰¹å¾ <code>A</code> ä½¿ç”¨å¦ä¸€ä¸ªç‰¹å¾ <code>B</code> çš„åŠŸèƒ½ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œä¸€ä¸ªç±»å‹è¦å®ç°ç‰¹å¾ <code>A</code> é¦–å…ˆè¦å®ç°ç‰¹å¾ <code>B</code>ï¼Œ ç‰¹å¾ <code>B</code> å°±è¢«ç§°ä¸º <code>supertrait</code></p>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Person {
    fn name(&amp;self) -&gt; String;
}

// Person æ˜¯ Student çš„ supertrait .
// å®ç° Student éœ€è¦åŒæ—¶å®ç° Person.
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// CompSciStudent (computer science student) æ˜¯ Programmer 
// å’Œ Student çš„ subtrait. å®ç° CompSciStudent éœ€è¦å…ˆå®ç°è¿™ä¸¤ä¸ª supertraits.
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        &quot;My name is {} and I attend {}. My favorite language is {}. My Git username is {}&quot;,
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}

struct CSStudent {
    name: String,
    university: String,
    fav_language: String,
    git_username: String
}

// ä¸º CSStudent å®ç°æ‰€éœ€çš„ç‰¹å¾
impl ...

fn main() {
    let student = CSStudent {
        name: &quot;Sunfei&quot;.to_string(),
        university: &quot;XXX&quot;.to_string(),
        fav_language: &quot;Rust&quot;.to_string(),
        git_username: &quot;sunface&quot;.to_string()
    };

    // å¡«ç©º
    println!(&quot;{}&quot;, comp_sci_student_greeting(__));
}</code></pre></pre>
<h2 id="å­¤å„¿åŸåˆ™"><a class="header" href="#å­¤å„¿åŸåˆ™">å­¤å„¿åŸåˆ™</a></h2>
<p>å…³äºå­¤å„¿åŸåˆ™çš„è¯¦ç»†ä»‹ç»è¯·å‚è§<a href="https://course.rs/basic/trait/trait#%E7%89%B9%E5%BE%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%AD%A4%E5%84%BF%E8%A7%84%E5%88%99">ç‰¹å¾å®šä¹‰ä¸å®ç°çš„ä½ç½®å­¤å„¿è§„åˆ™</a> å’Œ <a href="https://course.rs/basic/trait/advance-trait.html#%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E7%89%B9%E5%BE%81newtype">åœ¨å¤–éƒ¨ç±»å‹ä¸Šå®ç°å¤–éƒ¨ç‰¹å¾</a>ã€‚</p>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt;

// å®šä¹‰ä¸€ä¸ª newtype `Pretty`


impl fmt::Display for Pretty {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;\&quot;{}\&quot;&quot;, self.0.clone() + &quot;, world&quot;)
    }
}

fn main() {
    let w = Pretty(&quot;hello&quot;.to_string());
    println!(&quot;w = {}&quot;, w);
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/advanced-trait.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="é›†åˆç±»å‹"><a class="header" href="#é›†åˆç±»å‹">é›†åˆç±»å‹</a></h1>
<p>å­¦ä¹ èµ„æº: </p>
<ul>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/collections/intro.html">Rustè¯­è¨€åœ£ç» - é›†åˆç±»å‹</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-1"><a class="header" href="#string-1">String</a></h1>
<p><code>std::string::String</code> æ˜¯ UTF-8 ç¼–ç ã€å¯å¢é•¿çš„åŠ¨æ€å­—ç¬¦ä¸². å®ƒä¹Ÿæ˜¯æˆ‘ä»¬æ—¥å¸¸å¼€å‘ä¸­æœ€å¸¸ç”¨çš„å­—ç¬¦ä¸²ç±»å‹ï¼ŒåŒæ—¶å¯¹äºå®ƒæ‰€æ‹¥æœ‰çš„å†…å®¹æ‹¥æœ‰æ‰€æœ‰æƒã€‚</p>
<h3 id="åŸºæœ¬æ“ä½œ"><a class="header" href="#åŸºæœ¬æ“ä½œ">åŸºæœ¬æ“ä½œ</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯
// 1. ä¸è¦ä½¿ç”¨ `to_string()`
// 2. ä¸è¦æ·»åŠ /åˆ é™¤ä»»ä½•ä»£ç è¡Œ
fn main() {
    let mut s: String = &quot;hello, &quot;;
    s.push_str(&quot;world&quot;.to_string());
    s.push(__);

    move_ownership(s);

    assert_eq!(s, &quot;hello, world!&quot;);

    println!(&quot;Success!&quot;)
}

fn move_ownership(s: String) {
    println!(&quot;ownership of \&quot;{}\&quot; is moved here!&quot;, s)
}</code></pre></pre>
<h3 id="string-and-str"><a class="header" href="#string-and-str">String and &amp;str</a></h3>
<p>è™½ç„¶ <code>String</code> çš„åº•å±‚æ˜¯ <code>Vec&lt;u8&gt;</code> ä¹Ÿå°±æ˜¯å­—èŠ‚æ•°ç»„çš„å½¢å¼å­˜å‚¨çš„ï¼Œä½†æ˜¯å®ƒæ˜¯åŸºäº UTF-8 ç¼–ç çš„å­—ç¬¦åºåˆ—ã€‚<code>String</code> åˆ†é…åœ¨å †ä¸Šã€å¯å¢é•¿ä¸”ä¸æ˜¯ä»¥ <code>null</code> ç»“å°¾ã€‚</p>
<p>è€Œ <code>&amp;str</code> æ˜¯<a href="https://course.rs/confonding/slice.html">åˆ‡ç‰‡å¼•ç”¨</a>ç±»å‹( <code>&amp;[u8]</code> )ï¼ŒæŒ‡å‘ä¸€ä¸ªåˆæ³•çš„ UTF-8 å­—ç¬¦åºåˆ—ï¼Œæ€»ä¹‹ï¼Œ<code>&amp;str</code> å’Œ <code>String</code> çš„å…³ç³»ç±»ä¼¼äº <code>&amp;[T]</code> å’Œ <code>Vec&lt;T&gt;</code> ã€‚</p>
<p>å¦‚æœå¤§å®¶æƒ³äº†è§£æ›´å¤šï¼Œå¯ä»¥çœ‹çœ‹<a href="https://course.rs/difficulties/string.html">æ˜“æ··æ·†æ¦‚å¿µè§£æ - &amp;str å’Œ String</a>ã€‚</p>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// å¡«ç©º
fn main() {  
   let mut s = String::from(&quot;hello, world&quot;);

   let slice1: &amp;str = __; // ä½¿ç”¨ä¸¤ç§æ–¹æ³•
   assert_eq!(slice1, &quot;hello, world&quot;);

   let slice2 = __;
   assert_eq!(slice2, &quot;hello&quot;);

   let slice3: __ = __; 
   slice3.push('!');
   assert_eq!(slice3, &quot;hello, world!&quot;);

   println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// é—®é¢˜:  æˆ‘ä»¬çš„ä»£ç ä¸­å‘ç”Ÿäº†å¤šå°‘æ¬¡å †å†…å­˜åˆ†é…ï¼Ÿ
// ä½ çš„å›ç­”: 
fn main() {  
    // åŸºäº `&amp;str` ç±»å‹åˆ›å»ºä¸€ä¸ª String,
    // å­—ç¬¦ä¸²å­—é¢é‡çš„ç±»å‹æ˜¯ `&amp;str`
   let s: String = String::from(&quot;hello, world!&quot;);

   // åˆ›å»ºä¸€ä¸ªåˆ‡ç‰‡å¼•ç”¨æŒ‡å‘ String `s`
   let slice: &amp;str = &amp;s;

   // åŸºäºåˆšåˆ›å»ºçš„åˆ‡ç‰‡æ¥åˆ›å»ºä¸€ä¸ª String
   let s: String = slice.to_string();

   assert_eq!(s, &quot;hello, world!&quot;);

   println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="utf-8--ç´¢å¼•"><a class="header" href="#utf-8--ç´¢å¼•">UTF-8 &amp; ç´¢å¼•</a></h3>
<p>ç”±äº String éƒ½æ˜¯ UTF-8 ç¼–ç çš„ï¼Œè¿™ä¼šå¸¦æ¥å‡ ä¸ªå½±å“:</p>
<ul>
<li>å¦‚æœä½ éœ€è¦çš„æ˜¯é UTF-8 å­—ç¬¦ä¸²ï¼Œå¯ä»¥è€ƒè™‘ <a href="https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html">OsString</a> </li>
<li>æ— æ³•é€šè¿‡ç´¢å¼•çš„æ–¹å¼è®¿é—®ä¸€ä¸ª String</li>
</ul>
<p>å…·ä½“è¯·çœ‹<a href="https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95">å­—ç¬¦ä¸²ç´¢å¼•</a>ã€‚</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ æˆ‘ä»¬æ— æ³•é€šè¿‡ç´¢å¼•çš„æ–¹å¼è®¿é—®å­—ç¬¦ä¸²ä¸­çš„æŸä¸ªå­—ç¬¦ï¼Œä½†æ˜¯å¯ä»¥é€šè¿‡åˆ‡ç‰‡çš„æ–¹å¼æ¥è·å–å­—ç¬¦ä¸²çš„æŸä¸€éƒ¨åˆ† <code>&amp;s1[start..end]</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯
fn main() {
    let s = String::from(&quot;hello, ä¸–ç•Œ&quot;);
    let slice1 = s[0]; //æç¤º: `h` åœ¨ UTF-8 ç¼–ç ä¸­åªå ç”¨ 1 ä¸ªå­—èŠ‚
    assert_eq!(slice1, &quot;h&quot;);

    let slice2 = &amp;s[3..5];// æç¤º: `ä¸–` åœ¨ UTF-8 ç¼–ç ä¸­å ç”¨ 3 ä¸ªå­—èŠ‚
    assert_eq!(slice2, &quot;ä¸–&quot;);
    
    // è¿­ä»£ s ä¸­çš„æ‰€æœ‰å­—ç¬¦
    for (i, c) in s.__ {
        if i == 7 {
            assert_eq!(c, 'ä¸–')
        }
    }

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h4 id="utf8_slice-1"><a class="header" href="#utf8_slice-1">utf8_slice</a></h4>
<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ <a href="https://docs.rs/utf8_slice/1.0.0/utf8_slice/fn.slice.html">utf8_slice</a> æ¥æŒ‰ç…§å­—ç¬¦çš„è‡ªç„¶ç´¢å¼•æ–¹å¼å¯¹ UTF-8 å­—ç¬¦ä¸²è¿›è¡Œåˆ‡ç‰‡è®¿é—®ï¼Œä¸ä¹‹å‰çš„åˆ‡ç‰‡æ–¹å¼ç›¸æ¯”ï¼Œå®ƒç´¢å¼•çš„æ˜¯å­—ç¬¦ï¼Œè€Œä¹‹å‰çš„æ–¹å¼ç´¢å¼•çš„æ˜¯å­—èŠ‚.</p>
<p><strong>ç¤ºä¾‹</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use utf8_slice;
fn main() {
   let s = &quot;The ğŸš€ goes to the ğŸŒ‘!&quot;;

   let rocket = utf8_slice::slice(s, 4, 5);
   // Will equal &quot;ğŸš€&quot;
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<blockquote>
<p>æç¤º: ä¹Ÿè®¸ä½ éœ€è¦ä½¿ç”¨ <code>from_utf8</code> æ–¹æ³•</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn main() {
    let mut s = String::new();
    __;

    let v = vec![104, 101, 108, 108, 111];

    // å°†å­—èŠ‚æ•°ç»„è½¬æ¢æˆ String
    let s1 = __;
    
    
    assert_eq!(s, s1);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="å†…éƒ¨è¡¨ç¤º"><a class="header" href="#å†…éƒ¨è¡¨ç¤º">å†…éƒ¨è¡¨ç¤º</a></h3>
<p>äº‹å®ä¸Š <code>String</code> æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒä½œä¸ºä¸€ä¸ªç»“æ„ä½“å­˜å‚¨åœ¨æ ˆä¸Šï¼Œç„¶åæŒ‡å‘å­˜å‚¨åœ¨å †ä¸Šçš„å­—ç¬¦ä¸²åº•å±‚æ•°æ®ã€‚</p>
<p>å­˜å‚¨åœ¨æ ˆä¸Šçš„æ™ºèƒ½æŒ‡é’ˆç»“æ„ä½“ç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼šä¸€ä¸ªæŒ‡é’ˆåªæŒ‡å‘å †ä¸Šçš„å­—èŠ‚æ•°ç»„ï¼Œå·²ä½¿ç”¨çš„é•¿åº¦ä»¥åŠå·²åˆ†é…çš„å®¹é‡ capacity (å·²ä½¿ç”¨çš„é•¿åº¦å°äºç­‰äºå·²åˆ†é…çš„å®¹é‡ï¼Œå½“å®¹é‡ä¸å¤Ÿæ—¶ï¼Œä¼šé‡æ–°åˆ†é…å†…å­˜ç©ºé—´)ã€‚</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸ å¦‚æœ String çš„å½“å‰å®¹é‡è¶³å¤Ÿï¼Œé‚£ä¹ˆæ·»åŠ å­—ç¬¦å°†ä¸ä¼šå¯¼è‡´æ–°çš„å†…å­˜åˆ†é…</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®æ”¹ä¸‹é¢çš„ä»£ç ä»¥æ‰“å°å¦‚ä¸‹å†…å®¹: 
// 25
// 25
// 25
// å¾ªç¯ä¸­ä¸ä¼šå‘ç”Ÿä»»ä½•å†…å­˜åˆ†é…
fn main() {
    let mut s = String::new();

    println!(&quot;{}&quot;, s.capacity());

    for _ in 0..2 {
        s.push_str(&quot;hello&quot;);
        println!(&quot;{}&quot;, s.capacity());
    }

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="7">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
use std::mem;

fn main() {
    let story = String::from(&quot;Rust By Practice&quot;);

    // é˜»æ­¢ String çš„æ•°æ®è¢«è‡ªåŠ¨ drop
    let mut story = mem::ManuallyDrop::new(story);

    let ptr = story.__();
    let len = story.__();
    let capacity = story.__();

    assert_eq!(16, len);

    // æˆ‘ä»¬å¯ä»¥åŸºäº ptr æŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡æ¥é‡æ–°æ„å»º String. 
    // è¿™ç§æ“ä½œå¿…é¡»æ ‡è®°ä¸º unsafeï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦è‡ªå·±æ¥ç¡®ä¿è¿™é‡Œçš„æ“ä½œæ˜¯å®‰å…¨çš„
    let s = unsafe { String::from_raw_parts(ptr, len, capacity) };

    assert_eq!(*story, s);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="å¸¸ç”¨æ–¹æ³•todo"><a class="header" href="#å¸¸ç”¨æ–¹æ³•todo">å¸¸ç”¨æ–¹æ³•(TODO)</a></h3>
<p>å…³äº String çš„å¸¸ç”¨æ–¹æ³•ç»ƒä¹ ï¼Œå¯ä»¥æŸ¥çœ‹<a href="collections/../std/String.html">è¿™é‡Œ</a>.</p>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/String.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector"><a class="header" href="#vector">Vector</a></h1>
<p>ç›¸æ¯” <code>[T; N]</code> å½¢å¼çš„æ•°ç»„ï¼Œ <code>Vector</code> æœ€å¤§çš„ç‰¹ç‚¹å°±æ˜¯å¯ä»¥åŠ¨æ€è°ƒæ•´é•¿åº¦ã€‚</p>
<h3 id="åŸºæœ¬æ“ä½œ-1"><a class="header" href="#åŸºæœ¬æ“ä½œ-1">åŸºæœ¬æ“ä½œ</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr: [u8; 3] = [1, 2, 3];
    
    let v = Vec::from(arr);
    is_vec(v);

    let v = vec![1, 2, 3];
    is_vec(v);

    // vec!(..) å’Œ vec![..] æ˜¯åŒæ ·çš„å®ï¼Œå®å¯ä»¥ä½¿ç”¨ []ã€()ã€{}ä¸‰ç§å½¢å¼ï¼Œå› æ­¤...
    let v = vec!(1, 2, 3);
    is_vec(v);
    
    // ...åœ¨ä¸‹é¢çš„ä»£ç ä¸­, v æ˜¯ Vec&lt;[u8; 3]&gt; , è€Œä¸æ˜¯ Vec&lt;u8&gt;
    // ä½¿ç”¨ Vec::new å’Œ `for` æ¥é‡å†™ä¸‹é¢è¿™æ®µä»£ç 
    let v1 = vec!(arr);
    is_vec(v1);
 
    assert_eq!(v, v1);

    println!(&quot;Success!&quot;)
}

fn is_vec(v: Vec&lt;u8&gt;) {}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ <code>Vec</code> å¯ä»¥ä½¿ç”¨ <code>extend</code> æ–¹æ³•è¿›è¡Œæ‰©å±•</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn main() {
    let mut v1 = Vec::from([1, 2, 4]);
    v1.pop();
    v1.push(3);
    
    let mut v2 = Vec::new();
    v2.__;

    assert_eq!(v1, v2);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="å°†-x-ç±»å‹è½¬æ¢frominto-ç‰¹å¾æˆ-vec"><a class="header" href="#å°†-x-ç±»å‹è½¬æ¢frominto-ç‰¹å¾æˆ-vec">å°† X ç±»å‹è½¬æ¢(From/Into ç‰¹å¾)æˆ Vec</a></h3>
<p>åªè¦ä¸º <code>Vec</code> å®ç°äº† <code>From&lt;T&gt;</code> ç‰¹å¾ï¼Œé‚£ä¹ˆ <code>T</code> å°±å¯ä»¥è¢«è½¬æ¢æˆ <code>Vec</code>ã€‚</p>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn main() {
    // array -&gt; Vec
    // impl From&lt;[T; N]&gt; for Vec
    let arr = [1, 2, 3];
    let v1 = __(arr);
    let v2: Vec&lt;i32&gt; = arr.__();
 
    assert_eq!(v1, v2);
 
    
    // String -&gt; Vec
    // impl From&lt;String&gt; for Vec
    let s = &quot;hello&quot;.to_string();
    let v1: Vec&lt;u8&gt; = s.__();

    let s = &quot;hello&quot;.to_string();
    let v2 = s.into_bytes();
    assert_eq!(v1, v2);

    // impl&lt;'_&gt; From&lt;&amp;'_ str&gt; for Vec
    let s = &quot;hello&quot;;
    let v3 = Vec::__(s);
    assert_eq!(v2, v3);

    // è¿­ä»£å™¨ Iterators å¯ä»¥é€šè¿‡ collect å˜æˆ Vec
    let v4: Vec&lt;i32&gt; = [0; 10].into_iter().collect();
    assert_eq!(v4, vec![0; 10]);

    println!(&quot;Success!&quot;)
 }</code></pre></pre>
<h3 id="ç´¢å¼•"><a class="header" href="#ç´¢å¼•">ç´¢å¼•</a></h3>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯å¹¶å®ç°ç¼ºå¤±çš„ä»£ç 
fn main() {
    let mut v = Vec::from([1, 2, 3]);
    for i in 0..5 {
        println!(&quot;{:?}&quot;, v[i])
    }

    for i in 0..5 {
       // å®ç°è¿™é‡Œçš„ä»£ç ...
    }
    
    assert_eq!(v, vec![2, 3, 4, 5, 6]);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="åˆ‡ç‰‡"><a class="header" href="#åˆ‡ç‰‡">åˆ‡ç‰‡</a></h3>
<p>ä¸ <code>String</code> çš„åˆ‡ç‰‡ç±»ä¼¼ï¼Œ <code>Vec</code> ä¹Ÿå¯ä»¥ä½¿ç”¨åˆ‡ç‰‡ã€‚å¦‚æœè¯´ <code>Vec</code> æ˜¯å¯å˜çš„ï¼Œé‚£å®ƒçš„åˆ‡ç‰‡å°±æ˜¯ä¸å¯å˜æˆ–è€…è¯´åªè¯»çš„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ <code>&amp;</code> æ¥è·å–åˆ‡ç‰‡ã€‚</p>
<p>åœ¨ Rust ä¸­ï¼Œå°†åˆ‡ç‰‡ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’æ˜¯æ›´å¸¸è§çš„ä½¿ç”¨æ–¹å¼ï¼Œä¾‹å¦‚å½“ä¸€ä¸ªå‡½æ•°åªéœ€è¦å¯è¯»æ€§æ—¶ï¼Œé‚£ä¼ é€’ <code>Vec</code> æˆ– <code>String</code> çš„åˆ‡ç‰‡ <code>&amp;[T]</code> / <code>&amp;str</code> ä¼šæ›´åŠ é€‚åˆã€‚</p>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯
fn main() {
    let mut v = vec![1, 2, 3];

    let slice1 = &amp;v[..];
    // è¶Šç•Œè®¿é—®å°†å¯¼è‡´ panic.
    // ä¿®æ”¹æ—¶å¿…é¡»ä½¿ç”¨ `v.len`
    let slice2 = &amp;v[0..4];
    
    assert_eq!(slice1, slice2);
    
    // åˆ‡ç‰‡æ˜¯åªè¯»çš„
    // æ³¨æ„ï¼šåˆ‡ç‰‡å’Œ `&amp;Vec` æ˜¯ä¸åŒçš„ç±»å‹ï¼Œåè€…ä»…ä»…æ˜¯ `Vec` çš„å¼•ç”¨ï¼Œå¹¶å¯ä»¥é€šè¿‡è§£å¼•ç”¨ç›´æ¥è·å– `Vec`
    let vec_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut v;
    (*vec_ref).push(4);
    let slice3 = &amp;mut v[0..3];
    slice3.push(4);

    assert_eq!(slice3, &amp;[1, 2, 3, 4]);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="å®¹é‡"><a class="header" href="#å®¹é‡">å®¹é‡</a></h3>
<p>å®¹é‡ <code>capacity</code> æ˜¯å·²ç»åˆ†é…å¥½çš„å†…å­˜ç©ºé—´ï¼Œç”¨äºå­˜å‚¨æœªæ¥æ·»åŠ åˆ° <code>Vec</code> ä¸­çš„å…ƒç´ ã€‚è€Œé•¿åº¦ <code>len</code> åˆ™æ˜¯å½“å‰ <code>Vec</code> ä¸­å·²ç»å­˜å‚¨çš„å…ƒç´ æ•°é‡ã€‚å¦‚æœè¦æ·»åŠ æ–°å…ƒç´ æ—¶ï¼Œé•¿åº¦å°†è¦è¶…è¿‡å·²æœ‰çš„å®¹é‡ï¼Œé‚£å®¹é‡ä¼šè‡ªåŠ¨è¿›è¡Œå¢é•¿ï¼šRust ä¼šé‡æ–°åˆ†é…ä¸€å—æ›´å¤§çš„å†…å­˜ç©ºé—´ï¼Œç„¶åå°†ä¹‹å‰çš„ <code>Vec</code> æ‹·è´è¿‡å»ï¼Œå› æ­¤ï¼Œè¿™é‡Œå°±ä¼šå‘ç”Ÿæ–°çš„å†…å­˜åˆ†é…( ç›®å‰ Rust çš„å®¹é‡è°ƒæ•´ç­–ç•¥æ˜¯åŠ å€ï¼Œä¾‹å¦‚ 2 -&gt; 4 -&gt; 8 ..)ã€‚</p>
<p>è‹¥è¿™æ®µä»£ç ä¼šé¢‘ç¹å‘ç”Ÿï¼Œé‚£é¢‘ç¹çš„å†…å­˜åˆ†é…ä¼šå¤§å¹…å½±å“æˆ‘ä»¬ç³»ç»Ÿçš„æ€§èƒ½ï¼Œæœ€å¥½çš„åŠæ³•å°±æ˜¯æå‰åˆ†é…å¥½è¶³å¤Ÿçš„å®¹é‡ï¼Œå°½é‡å‡å°‘å†…å­˜åˆ†é…ã€‚</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä¿®å¤é”™è¯¯
fn main() {
    let mut vec = Vec::with_capacity(10);

    assert_eq!(vec.len(), __);
    assert_eq!(vec.capacity(), 10);

    // ç”±äºæå‰è®¾ç½®äº†è¶³å¤Ÿçš„å®¹é‡ï¼Œè¿™é‡Œçš„å¾ªç¯ä¸ä¼šé€ æˆä»»ä½•å†…å­˜åˆ†é…...
    for i in 0..10 {
        vec.push(i);
    }
    assert_eq!(vec.len(), __);
    assert_eq!(vec.capacity(), __);

    // ...ä½†æ˜¯ä¸‹é¢çš„ä»£ç ä¼šé€ æˆæ–°çš„å†…å­˜åˆ†é…
    vec.push(11);
    assert_eq!(vec.len(), 11);
    assert!(vec.capacity() &gt;= 11);


    // å¡«å†™ä¸€ä¸ªåˆé€‚çš„å€¼ï¼Œåœ¨ `for` å¾ªç¯è¿è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œä¸ä¼šé€ æˆä»»ä½•å†…å­˜åˆ†é…
    let mut vec = Vec::with_capacity(__);
    for i in 0..100 {
        vec.push(i);
    }

    assert_eq!(vec.len(), __);
    assert_eq!(vec.capacity(), __);
    
    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="åœ¨-vec-ä¸­å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ "><a class="header" href="#åœ¨-vec-ä¸­å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ ">åœ¨ Vec ä¸­å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ </a></h3>
<p><code>Vec</code> ä¸­çš„å…ƒç´ å¿…é¡»æ˜¯ç›¸åŒçš„ç±»å‹ï¼Œä¾‹å¦‚ä»¥ä¸‹ä»£ç ä¼šå‘ç”Ÿé”™è¯¯:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let v = vec![1, 2.0, 3];
}</code></pre></pre>
<p>ä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æšä¸¾æˆ–ç‰¹å¾å¯¹è±¡æ¥å­˜å‚¨ä¸åŒçš„ç±»å‹.</p>
<ol start="7">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum IpAddr {
    V4(String),
    V6(String),
}
fn main() {
    // å¡«ç©º
    let v : Vec&lt;IpAddr&gt;= __;
    
    // æšä¸¾çš„æ¯”è¾ƒéœ€è¦æ´¾ç”Ÿ PartialEq ç‰¹å¾
    assert_eq!(v[0], IpAddr::V4(&quot;127.0.0.1&quot;.to_string()));
    assert_eq!(v[1], IpAddr::V6(&quot;::1&quot;.to_string()));

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait IpAddr {
    fn display(&amp;self);
}

struct V4(String);
impl IpAddr for V4 {
    fn display(&amp;self) {
        println!(&quot;ipv4: {:?}&quot;,self.0)
    }
}
struct V6(String);
impl IpAddr for V6 {
    fn display(&amp;self) {
        println!(&quot;ipv6: {:?}&quot;,self.0)
    }
}

fn main() {
    // å¡«ç©º
    let v: __= vec![
        Box::new(V4(&quot;127.0.0.1&quot;.to_string())),
        Box::new(V6(&quot;::1&quot;.to_string())),
    ];

    for ip in v {
        ip.display();
    }
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/Vector.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h1>
<p><code>HashMap</code> é»˜è®¤ä½¿ç”¨ <code>SipHash 1-3</code> å“ˆå¸Œç®—æ³•ï¼Œè¯¥ç®—æ³•å¯¹äºæŠµæŠ— <code>HashDos</code> æ”»å‡»éå¸¸æœ‰æ•ˆã€‚åœ¨æ€§èƒ½æ–¹é¢ï¼Œå¦‚æœä½ çš„ key æ˜¯ä¸­å‹å¤§å°çš„ï¼Œé‚£è¯¥ç®—æ³•éå¸¸ä¸é”™ï¼Œä½†æ˜¯å¦‚æœæ˜¯å°å‹çš„ key( ä¾‹å¦‚æ•´æ•° )äº¦æˆ–æ˜¯å¤§å‹çš„ key ( ä¾‹å¦‚å­—ç¬¦ä¸² )ï¼Œé‚£ä½ éœ€è¦é‡‡ç”¨ç¤¾åŒºæä¾›çš„å…¶å®ƒç®—æ³•æ¥æé«˜æ€§èƒ½ã€‚</p>
<p>å“ˆå¸Œè¡¨çš„ç®—æ³•æ˜¯åŸºäº Google çš„ <a href="https://abseil.io/blog/20180927-swisstables">SwissTable</a>ï¼Œä½ å¯ä»¥åœ¨<a href="https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h">è¿™é‡Œ</a>æ‰¾åˆ° C++ çš„å®ç°ï¼ŒåŒæ—¶åœ¨ <a href="https://www.youtube.com/watch?v=ncHmEUmJZf4">CppCon talk</a> ä¸Šä¹Ÿæœ‰å…³äºç®—æ³•å¦‚ä½•å·¥ä½œçš„æ¼”è®²ã€‚</p>
<h3 id="åŸºæœ¬æ“ä½œ-2"><a class="header" href="#åŸºæœ¬æ“ä½œ-2">åŸºæœ¬æ“ä½œ</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯
use std::collections::HashMap;
fn main() {
    let mut scores = HashMap::new();
    scores.insert(&quot;Sunface&quot;, 98);
    scores.insert(&quot;Daniel&quot;, 95);
    scores.insert(&quot;Ashley&quot;, 69.0);
    scores.insert(&quot;Katie&quot;, &quot;58&quot;);

    // get è¿”å›ä¸€ä¸ª Option&lt;&amp;V&gt; æšä¸¾å€¼
    let score = scores.get(&quot;Sunface&quot;);
    assert_eq!(score, Some(98));

    if scores.contains_key(&quot;Daniel&quot;) {
        // ç´¢å¼•è¿”å›ä¸€ä¸ªå€¼ V
        let score = scores[&quot;Daniel&quot;];
        assert_eq!(score, __);
        scores.remove(&quot;Daniel&quot;);
    }

    assert_eq!(scores.len(), __);

    for (name, score) in scores {
        println!(&quot;The score of {} is {}&quot;, name, score)
    }
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::collections::HashMap;
fn main() {
    let teams = [
        (&quot;Chinese Team&quot;, 100),
        (&quot;American Team&quot;, 10),
        (&quot;France Team&quot;, 50),
    ];

    let mut teams_map1 = HashMap::new();
    for team in &amp;teams {
        teams_map1.insert(team.0, team.1);
    }

    // ä½¿ç”¨ä¸¤ç§æ–¹æ³•å®ç° team_map2
    // æç¤º:å…¶ä¸­ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ `collect` æ–¹æ³•
    let teams_map2...

    assert_eq!(teams_map1, teams_map2);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
use std::collections::HashMap;
fn main() {
    // ç¼–è¯‘å™¨å¯ä»¥æ ¹æ®åç»­çš„ä½¿ç”¨æƒ…å†µå¸®æˆ‘è‡ªåŠ¨æ¨æ–­å‡º HashMap çš„ç±»å‹ï¼Œå½“ç„¶ä½ ä¹Ÿå¯ä»¥æ˜¾å¼åœ°æ ‡æ³¨ç±»å‹ï¼šHashMap&lt;&amp;str, u8&gt;
    let mut player_stats = HashMap::new();

    // æŸ¥è¯¢æŒ‡å®šçš„ key, è‹¥ä¸å­˜åœ¨æ—¶ï¼Œåˆ™æ’å…¥æ–°çš„ kv å€¼
    player_stats.entry(&quot;health&quot;).or_insert(100);

    assert_eq!(player_stats[&quot;health&quot;], __);

    // é€šè¿‡å‡½æ•°æ¥è¿”å›æ–°çš„å€¼
    player_stats.entry(&quot;health&quot;).or_insert_with(random_stat_buff);
    assert_eq!(player_stats[&quot;health&quot;], __);

    let health = player_stats.entry(&quot;health&quot;).or_insert(50);
    assert_eq!(health, __);
    *health -= 50;
    assert_eq!(*health, __);

    println!(&quot;Success!&quot;)
}

fn random_stat_buff() -&gt; u8 {
    // ä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨éšæœºï¼Œè€Œæ˜¯è¿”å›ä¸€ä¸ªå›ºå®šçš„å€¼
    42
}</code></pre></pre>
<h3 id="hashmap-key-çš„é™åˆ¶"><a class="header" href="#hashmap-key-çš„é™åˆ¶">HashMap key çš„é™åˆ¶</a></h3>
<p>ä»»ä½•å®ç°äº† <code>Eq</code> å’Œ <code>Hash</code> ç‰¹å¾çš„ç±»å‹éƒ½å¯ä»¥ç”¨äº <code>HashMap</code> çš„ keyï¼ŒåŒ…æ‹¬:</p>
<ul>
<li><code>bool</code> (è™½ç„¶å¾ˆå°‘ç”¨åˆ°ï¼Œå› ä¸ºå®ƒåªèƒ½è¡¨è¾¾ä¸¤ç§ key)</li>
<li><code>int</code>, <code>uint</code> ä»¥åŠå®ƒä»¬çš„å˜ä½“ï¼Œä¾‹å¦‚ <code>u8</code>ã€<code>i32</code> ç­‰</li>
<li><code>String</code> å’Œ <code>&amp;str</code> (æç¤º: <code>HashMap</code> çš„ key æ˜¯ <code>String</code> ç±»å‹æ—¶ï¼Œä½ å…¶å®å¯ä»¥ä½¿ç”¨ <code>&amp;str</code> é…åˆ <code>get</code> æ–¹æ³•è¿›è¡ŒæŸ¥è¯¢</li>
</ul>
<p>éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ<code>f32</code> å’Œ <code>f64</code> å¹¶æ²¡æœ‰å®ç° <code>Hash</code>ï¼ŒåŸå› æ˜¯ <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems">æµ®ç‚¹æ•°ç²¾åº¦</a> çš„é—®é¢˜ä¼šå¯¼è‡´å®ƒä»¬æ— æ³•è¿›è¡Œç›¸ç­‰æ¯”è¾ƒã€‚</p>
<p>å¦‚æœä¸€ä¸ªé›†åˆç±»å‹çš„æ‰€æœ‰å­—æ®µéƒ½å®ç°äº† <code>Eq</code> å’Œ <code>Hash</code>,é‚£è¯¥é›†åˆç±»å‹ä¼šè‡ªåŠ¨å®ç° <code>Eq</code> å’Œ <code>Hash</code>ã€‚ä¾‹å¦‚ <code>Vect&lt;T&gt;</code> è¦å®ç° <code>Hash</code>ï¼Œé‚£ä¹ˆé¦–å…ˆéœ€è¦ <code>T</code> å®ç° <code>Hash</code>ã€‚</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä¿®å¤é”™è¯¯
// æç¤º: `derive` æ˜¯å®ç°ä¸€äº›å¸¸ç”¨ç‰¹å¾çš„å¥½åŠæ³•
use std::collections::HashMap;

struct Viking {
    name: String,
    country: String,
}

impl Viking {
    fn new(name: &amp;str, country: &amp;str) -&gt; Viking {
        Viking {
            name: name.to_string(),
            country: country.to_string(),
        }
    }
}

fn main() {
    // ä½¿ç”¨ HashMap æ¥å­˜å‚¨ viking çš„ç”Ÿå‘½å€¼
    let vikings = HashMap::from([
        (Viking::new(&quot;Einar&quot;, &quot;Norway&quot;), 25),
        (Viking::new(&quot;Olaf&quot;, &quot;Denmark&quot;), 24),
        (Viking::new(&quot;Harald&quot;, &quot;Iceland&quot;), 12),
    ]);

    // ä½¿ç”¨ derive çš„æ–¹å¼æ¥æ‰“å° viking çš„å½“å‰çŠ¶æ€
    for (viking, health) in &amp;vikings {
        println!(&quot;{:?} has {} hp&quot;, viking, health);
    }
}</code></pre></pre>
<h3 id="å®¹é‡-1"><a class="header" href="#å®¹é‡-1">å®¹é‡</a></h3>
<p>å…³äºå®¹é‡ï¼Œæˆ‘ä»¬åœ¨ä¹‹å‰çš„ <a href="https://practice-zh.course.rs/collections/vector.html#%E5%AE%B9%E9%87%8F">Vector</a> ä¸­æœ‰è¯¦ç»†çš„ä»‹ç»ï¼Œè€Œ <code>HashMap</code> ä¹Ÿå¯ä»¥è°ƒæ•´å®¹é‡: ä½ å¯ä»¥é€šè¿‡ <code>HashMap::with_capacity(uint)</code> ä½¿ç”¨æŒ‡å®šçš„å®¹é‡æ¥åˆå§‹åŒ–ï¼Œæˆ–è€…ä½¿ç”¨ <code>HashMap::new()</code> ï¼Œåè€…ä¼šæä¾›ä¸€ä¸ªé»˜è®¤çš„åˆå§‹åŒ–å®¹é‡ã€‚</p>
<h4 id="ç¤ºä¾‹-7"><a class="header" href="#ç¤ºä¾‹-7">ç¤ºä¾‹</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::collections::HashMap;
fn main() {
    let mut map: HashMap&lt;i32, i32&gt; = HashMap::with_capacity(100);
    map.insert(1, 2);
    map.insert(3, 4);
    // äº‹å®ä¸Šï¼Œè™½ç„¶æˆ‘ä»¬ä½¿ç”¨äº† 100 å®¹é‡æ¥åˆå§‹åŒ–ï¼Œä½†æ˜¯ map çš„å®¹é‡å¾ˆå¯èƒ½ä¼šæ¯” 100 æ›´å¤š
    assert!(map.capacity() &gt;= 100);

    // å¯¹å®¹é‡è¿›è¡Œæ”¶ç¼©ï¼Œä½ æä¾›çš„å€¼ä»…ä»…æ˜¯ä¸€ä¸ªå…è®¸çš„æœ€å°å€¼ï¼Œå®é™…ä¸Šï¼ŒRust ä¼šæ ¹æ®å½“å‰å­˜å‚¨çš„æ•°æ®é‡è¿›è¡Œè‡ªåŠ¨è®¾ç½®ï¼Œå½“ç„¶ï¼Œè¿™ä¸ªå€¼ä¼šå°½é‡é è¿‘ä½ æä¾›çš„å€¼ï¼ŒåŒæ—¶è¿˜å¯èƒ½ä¼šé¢„ç•™ä¸€äº›è°ƒæ•´ç©ºé—´

    map.shrink_to(50);
    assert!(map.capacity() &gt;= 50);

    // è®© Rust  è‡ªè¡Œè°ƒæ•´åˆ°ä¸€ä¸ªåˆé€‚çš„å€¼ï¼Œå‰©ä½™ç­–ç•¥åŒä¸Š
    map.shrink_to_fit();
    assert!(map.capacity() &gt;= 2);
    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="æ‰€æœ‰æƒ-1"><a class="header" href="#æ‰€æœ‰æƒ-1">æ‰€æœ‰æƒ</a></h3>
<p>å¯¹äºå®ç°äº† <code>Copy</code> ç‰¹å¾çš„ç±»å‹ï¼Œä¾‹å¦‚ <code>i32</code>ï¼Œé‚£ç±»å‹çš„å€¼ä¼šè¢«æ‹·è´åˆ° <code>HashMap</code> ä¸­ã€‚è€Œå¯¹äºæœ‰æ‰€æœ‰æƒçš„ç±»å‹ï¼Œä¾‹å¦‚ <code>String</code>ï¼Œå®ƒä»¬çš„å€¼çš„æ‰€æœ‰æƒå°†è¢«è½¬ç§»åˆ° <code>HashMap</code> ä¸­ã€‚</p>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä¿®å¤é”™è¯¯ï¼Œå°½å¯èƒ½å°‘çš„å»ä¿®æ”¹ä»£ç 
// ä¸è¦ç§»é™¤ä»»ä½•ä»£ç è¡Œï¼
use std::collections::HashMap;
fn main() {
  let v1 = 10;
  let mut m1 = HashMap::new();
  m1.insert(v1, v1);
  println!(&quot;v1 is still usable after inserting to hashmap : {}&quot;, v1);

  let v2 = &quot;hello&quot;.to_string();
  let mut m2 = HashMap::new();
  // æ‰€æœ‰æƒåœ¨è¿™é‡Œå‘ç”Ÿäº†è½¬ç§»
  m2.insert(v2, v1);

  assert_eq!(v2, &quot;hello&quot;);

   println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="ä¸‰æ–¹åº“-hash-åº“"><a class="header" href="#ä¸‰æ–¹åº“-hash-åº“">ä¸‰æ–¹åº“ Hash åº“</a></h3>
<p>åœ¨å¼€å¤´ï¼Œæˆ‘ä»¬æåˆ°è¿‡å¦‚æœç°æœ‰çš„ <code>SipHash 1-3</code> çš„æ€§èƒ½æ— æ³•æ»¡è¶³ä½ çš„éœ€æ±‚ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨ç¤¾åŒºæä¾›çš„æ›¿ä»£ç®—æ³•ã€‚</p>
<p>ä¾‹å¦‚å…¶ä¸­ä¸€ä¸ªç¤¾åŒºåº“çš„ä½¿ç”¨æ–¹å¼å¦‚ä¸‹ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::hash::BuildHasherDefault;
use std::collections::HashMap;
// å¼•å…¥ç¬¬ä¸‰æ–¹çš„å“ˆå¸Œå‡½æ•°
use twox_hash::XxHash64;


let mut hash: HashMap&lt;_, _, BuildHasherDefault&lt;XxHash64&gt;&gt; = Default::default();
hash.insert(42, &quot;the answer&quot;);
assert_eq!(hash.get(&amp;42), Some(&amp;&quot;the answer&quot;));
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/Hashmap.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conversions"><a class="header" href="#type-conversions">Type conversions</a></h1>
<p>There are several ways we can use to perform type conversions, such as <code>as</code>, <code>From/Intro</code>, <code>TryFrom/TryInto</code>, <code>transmute</code> etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ä½¿ç”¨-as-è¿›è¡Œç±»å‹è½¬æ¢"><a class="header" href="#ä½¿ç”¨-as-è¿›è¡Œç±»å‹è½¬æ¢">ä½¿ç”¨ as è¿›è¡Œç±»å‹è½¬æ¢</a></h1>
<p>Rust å¹¶æ²¡æœ‰ä¸ºåŸºæœ¬ç±»å‹æä¾›éšå¼çš„ç±»å‹è½¬æ¢( coercion )ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡ <code>as</code> æ¥è¿›è¡Œæ˜¾å¼åœ°è½¬æ¢ã€‚</p>
<ol>
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä¿®å¤é”™è¯¯ï¼Œå¡«ç©º
// ä¸è¦ç§»é™¤ä»»ä½•ä»£ç 
fn main() {
    let decimal = 97.123_f32;

    let integer: __ = decimal as u8;

    let c1: char = decimal as char;
    let c2 = integer as char;

    assert_eq!(integer, 'b' as u8);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ é»˜è®¤æƒ…å†µä¸‹, æ•°å€¼æº¢å‡ºä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡æ·»åŠ ä¸€è¡Œå…¨å±€æ³¨è§£çš„æ–¹å¼æ¥é¿å…ç¼–è¯‘é”™è¯¯(æº¢å‡ºè¿˜æ˜¯ä¼šå‘ç”Ÿ)</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(u8::MAX, 255);
    // å¦‚ä¸Šæ‰€ç¤ºï¼Œu8 ç±»å‹å…è®¸çš„æœ€å¤§å€¼æ˜¯ 255.
    // å› æ­¤ä»¥ä¸‹ä»£ç ä¼šæŠ¥æº¢å‡ºçš„é”™è¯¯ï¼š literal out of range for `u8`.
    // **è¯·ä»”ç»†æŸ¥çœ‹ç›¸åº”çš„ç¼–è¯‘é”™è¯¯ï¼Œä»ä¸­å¯»æ‰¾åˆ°è§£å†³çš„åŠæ³•**
    // **ä¸è¦ä¿®æ”¹ main ä¸­çš„ä»»ä½•ä»£ç **
    let v = 1000 as u8;

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ  å½“å°†ä»»ä½•æ•°å€¼è½¬æ¢æˆæ— ç¬¦å·æ•´å‹ <code>T</code> æ—¶ï¼Œå¦‚æœå½“å‰çš„æ•°å€¼ä¸åœ¨æ–°ç±»å‹çš„èŒƒå›´å†…ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹å½“å‰æ•°å€¼è¿›è¡ŒåŠ å€¼æˆ–å‡å€¼æ“ä½œ( å¢åŠ æˆ–å‡å°‘ <code>T::MAX + 1</code> )ï¼Œç›´åˆ°æœ€æ–°çš„å€¼åœ¨æ–°ç±»å‹çš„èŒƒå›´å†…ï¼Œå‡è®¾æˆ‘ä»¬è¦å°† <code>300</code> è½¬æˆ <code>u8</code> ç±»å‹ï¼Œç”±äº<code>u8</code> æœ€å¤§å€¼æ˜¯ 255ï¼Œå› æ­¤ <code>300</code> ä¸åœ¨æ–°ç±»å‹çš„èŒƒå›´å†…å¹¶ä¸”å¤§äºæ–°ç±»å‹çš„æœ€å¤§å€¼ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å‡å» <code>T::MAX + 1</code>ï¼Œä¹Ÿå°±æ˜¯ <code>300</code> - <code>256</code> = <code>44</code>ã€‚</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(1000 as u16, __);

    assert_eq!(1000 as u8, __);

    // äº‹å®ä¸Šï¼Œä¹‹å‰è¯´çš„è§„åˆ™å¯¹äºæ­£æ•´æ•°è€Œè¨€ï¼Œå°±æ˜¯å¦‚ä¸‹çš„å–æ¨¡
    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);

    assert_eq!(-1_i8 as u8, __);
    

    // ä» Rust 1.45 å¼€å§‹ï¼Œå½“æµ®ç‚¹æ•°è¶…å‡ºç›®æ ‡æ•´æ•°çš„èŒƒå›´æ—¶ï¼Œè½¬åŒ–ä¼šç›´æ¥å–æ­£æ•´æ•°å–å€¼èŒƒå›´çš„æœ€å¤§æˆ–æœ€å°å€¼
    assert_eq!(300.1_f32 as u8, __);
    assert_eq!(-100.1_f32 as u8, __);
    

    // ä¸Šé¢çš„æµ®ç‚¹æ•°è½¬æ¢æœ‰ä¸€ç‚¹æ€§èƒ½æŸè€—ï¼Œå¦‚æœå¤§å®¶å¯¹äºæŸæ®µä»£ç æœ‰æè‡´çš„æ€§èƒ½è¦æ±‚ï¼Œ
    // å¯ä»¥è€ƒè™‘ä¸‹é¢çš„æ–¹æ³•ï¼Œä½†æ˜¯è¿™äº›æ–¹æ³•çš„ç»“æœå¯èƒ½ä¼šæº¢å‡ºå¹¶ä¸”è¿”å›ä¸€äº›æ— æ„ä¹‰çš„å€¼
    // æ€»ä¹‹ï¼Œè¯·å°å¿ƒä½¿ç”¨
    unsafe {
        // 300.0 is 44
        println!(&quot;300.0 is {}&quot;, 300.0_f32.to_int_unchecked::&lt;u8&gt;());
        // -100.0 as u8 is 156
        println!(&quot;-100.0 as u8 is {}&quot;, (-100.0_f32).to_int_unchecked::&lt;u8&gt;());
        // nan as u8 is 0
        println!(&quot;nan as u8 is {}&quot;, f32::NAN.to_int_unchecked::&lt;u8&gt;());
    }
}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ è£¸æŒ‡é’ˆå¯ä»¥å’Œä»£è¡¨å†…å­˜åœ°å€çš„æ•´æ•°äº’ç›¸è½¬æ¢</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn main() {
    let mut values: [i32; 2] = [1, 2];
    let p1: *mut i32 = values.as_mut_ptr();
    let first_address: usize = p1 __; 
    let second_address = first_address + 4; // 4 == std::mem::size_of::&lt;i32&gt;()
    let p2: *mut i32 = second_address __; // p2 æŒ‡å‘ values æ•°ç»„ä¸­çš„ç¬¬äºŒä¸ªå…ƒç´ 
    unsafe {
        // å°†ç¬¬äºŒä¸ªå…ƒç´ åŠ  1
        __
    }
    
    assert_eq!(values[1], 3);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr :[u64; 13] = [0; 13];
    assert_eq!(std::mem::size_of_val(&amp;arr), 8 * 13);
    let a: *const [u64] = &amp;arr;
    let b = a as *const [u8];
    unsafe {
        assert_eq!(std::mem::size_of_val(&amp;*b), __)
    }
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/type-conversions/as.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frominto"><a class="header" href="#frominto">From/Into</a></h1>
<p><code>From</code> ç‰¹å¾å…è®¸è®©ä¸€ä¸ªç±»å‹å®šä¹‰å¦‚ä½•åŸºäºå¦ä¸€ä¸ªç±»å‹æ¥åˆ›å»ºè‡ªå·±ï¼Œå› æ­¤å®ƒæä¾›äº†ä¸€ä¸ªå¾ˆæ–¹ä¾¿çš„ç±»å‹è½¬æ¢çš„æ–¹å¼ã€‚</p>
<p><code>From</code> å’Œ <code>Into</code> æ˜¯é…å¯¹çš„ï¼Œæˆ‘ä»¬åªè¦å®ç°äº†å‰è€…ï¼Œé‚£åè€…å°±ä¼šè‡ªåŠ¨è¢«å®ç°ï¼šåªè¦å®ç°äº† <code>impl From&lt;T&gt; for U</code>ï¼Œ å°±å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä¸¤ä¸ªæ–¹æ³•: <code>let u: U = U::from(T)</code> å’Œ <code>let u:U = T.into()</code>ï¼Œå‰è€…ç”± <code>From</code> ç‰¹å¾æä¾›ï¼Œè€Œåè€…ç”±è‡ªåŠ¨å®ç°çš„ <code>Into</code> ç‰¹å¾æä¾›ã€‚</p>
<p>éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“ä½¿ç”¨ <code>into</code> æ–¹æ³•æ—¶ï¼Œä½ éœ€è¦è¿›è¡Œæ˜¾å¼åœ°ç±»å‹æ ‡æ³¨ï¼Œå› ä¸ºç¼–è¯‘å™¨å¾ˆå¯èƒ½æ— æ³•å¸®æˆ‘ä»¬æ¨å¯¼å‡ºæ‰€éœ€çš„ç±»å‹ã€‚</p>
<p>æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•çš„å°† <code>&amp;str</code> è½¬æ¢æˆ <code>String</code></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let my_str = &quot;hello&quot;;

    // ä»¥ä¸‹ä¸‰ä¸ªè½¬æ¢éƒ½ä¾èµ–äºä¸€ä¸ªäº‹å®ï¼šString å®ç°äº† From&lt;&amp;str&gt; ç‰¹å¾
    let string1 = String::from(my_str);
    let string2 = my_str.to_string();
    // è¿™é‡Œéœ€è¦æ˜¾å¼åœ°ç±»å‹æ ‡æ³¨
    let string3: String = my_str.into();
}</code></pre></pre>
<p>è¿™ç§è½¬æ¢å¯ä»¥å‘ç”Ÿæ˜¯å› ä¸ºæ ‡å‡†åº“å·²ç»å¸®æˆ‘ä»¬å®ç°äº† <code>From</code> ç‰¹å¾ï¼š <code>impl From&lt;&amp;'_ str&gt; for String</code>ã€‚ä½ è¿˜å¯ä»¥åœ¨<a href="https://doc.rust-lang.org/stable/std/convert/trait.From.html#implementors">è¿™é‡Œ</a>)æ‰¾åˆ°å…¶å®ƒå®ç° <code>From</code> ç‰¹å¾çš„å¸¸ç”¨ç±»å‹ã€‚</p>
<ol>
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // impl From&lt;bool&gt; for i32
    let i1: i32 = false.into();
    let i2: i32 = i32::from(false);
    assert_eq!(i1, i2);
    assert_eq!(i1, 0);

    // ä½¿ç”¨ä¸¤ç§æ–¹å¼ä¿®å¤é”™è¯¯
    // 1. å“ªä¸ªç±»å‹å®ç° From ç‰¹å¾ : impl From&lt;char&gt; for ? , ä½ å¯ä»¥æŸ¥çœ‹ä¸€ä¸‹ä¹‹å‰æåˆ°çš„æ–‡æ¡£ï¼Œæ¥æ‰¾åˆ°åˆé€‚çš„ç±»å‹
    // 2. ä¸Šä¸€ç« èŠ‚ä¸­ä»‹ç»è¿‡çš„æŸä¸ªå…³é”®å­—
    let i3: i32 = 'a'.into();

    // ä½¿ç”¨ä¸¤ç§æ–¹æ³•æ¥è§£å†³é”™è¯¯
    let s: String = 'a' as String;

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°-from-ç‰¹å¾"><a class="header" href="#ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°-from-ç‰¹å¾">ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° <code>From</code> ç‰¹å¾</a></h3>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// From è¢«åŒ…å«åœ¨ `std::prelude` ä¸­ï¼Œå› æ­¤æˆ‘ä»¬æ²¡å¿…è¦æ‰‹åŠ¨å°†å…¶å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸæ¥
// use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    // å®ç° `from` æ–¹æ³•
}

// å¡«ç©º
fn main() {
    let num = __(30);
    assert_eq!(num.value, 30);

    let num: Number = __;
    assert_eq!(num.value, 30);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ å½“æ‰§è¡Œé”™è¯¯å¤„ç†æ—¶ï¼Œä¸ºæˆ‘ä»¬è‡ªå®šä¹‰çš„é”™è¯¯ç±»å‹å®ç° <code>From</code> ç‰¹å¾æ˜¯éå¸¸æœ‰ç”¨ã€‚è¿™æ ·å°±å¯ä»¥é€šè¿‡ <code>?</code> è‡ªåŠ¨å°†æŸä¸ªé”™è¯¯ç±»å‹è½¬æ¢æˆæˆ‘ä»¬è‡ªå®šä¹‰çš„é”™è¯¯ç±»å‹</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs;
use std::io;
use std::num;

enum CliError {
    IoError(io::Error),
    ParseError(num::ParseIntError),
}

impl From&lt;io::Error&gt; for CliError {
    // å®ç° from æ–¹æ³•
}

impl From&lt;num::ParseIntError&gt; for CliError {
    // å®ç° from æ–¹æ³•
}

fn open_and_parse_file(file_name: &amp;str) -&gt; Result&lt;i32, CliError&gt; {
    // ? è‡ªåŠ¨å°† io::Error è½¬æ¢æˆ CliError
    let contents = fs::read_to_string(&amp;file_name)?;
    // num::ParseIntError -&gt; CliError
    let num: i32 = contents.trim().parse()?;
    Ok(num)
}

fn main() {
    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="tryfromtryinto"><a class="header" href="#tryfromtryinto">TryFrom/TryInto</a></h3>
<p>ç±»ä¼¼äº <code>From</code> å’Œ <code>Into</code>, <code>TryFrom</code> å’Œ <code>TryInto</code> ä¹Ÿæ˜¯ç”¨äºç±»å‹è½¬æ¢çš„æ³›å‹ç‰¹å¾ã€‚</p>
<p>ä½†æ˜¯åˆä¸ <code>From/Into</code> ä¸åŒ, <code>TryFrom</code> å’Œ <code>TryInto</code> å¯ä»¥å¯¹è½¬æ¢åçš„å¤±è´¥è¿›è¡Œå¤„ç†ï¼Œç„¶åè¿”å›ä¸€ä¸ª <code>Result</code>ã€‚</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// TryFrom å’Œ TryInto ä¹Ÿè¢«åŒ…å«åœ¨ `std::prelude` ä¸­, å› æ­¤ä»¥ä¸‹å¼•å…¥æ˜¯æ²¡å¿…è¦çš„
// use std::convert::TryInto;

fn main() {
    let n: i16 = 256;

    // Into ç‰¹å¾æ‹¥æœ‰ä¸€ä¸ªæ–¹æ³•`into`,
    // å› æ­¤ TryInto æœ‰ä¸€ä¸ªæ–¹æ³•æ˜¯ ?
    let n: u8 = match n.__() {
        Ok(n) =&gt; n,
        Err(e) =&gt; {
            println!(&quot;there is an error when converting: {:?}, but we catch it&quot;, e.to_string());
            0
        }
    };

    assert_eq!(n, __);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, PartialEq)]
struct EvenNum(i32);

impl TryFrom&lt;i32&gt; for EvenNum {
    type Error = ();

    // å®ç° `try_from`
    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value % 2 == 0 {
            Ok(EvenNum(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    assert_eq!(EvenNum::try_from(8), Ok(EvenNum(8)));
    assert_eq!(EvenNum::try_from(5), Err(()));

    // å¡«ç©º
    let result: Result&lt;EvenNum, ()&gt; = 8i32.try_into();
    assert_eq!(result, __);
    let result: Result&lt;EvenNum, ()&gt; = 5i32.try_into();
    assert_eq!(result, __);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/type-conversions/from-into.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å…¶å®ƒè½¬æ¢"><a class="header" href="#å…¶å®ƒè½¬æ¢">å…¶å®ƒè½¬æ¢</a></h1>
<h3 id="å°†ä»»ä½•ç±»å‹è½¬æ¢æˆ-string"><a class="header" href="#å°†ä»»ä½•ç±»å‹è½¬æ¢æˆ-string">å°†ä»»ä½•ç±»å‹è½¬æ¢æˆ String</a></h3>
<p>åªè¦ä¸ºä¸€ä¸ªç±»å‹å®ç°äº† <code>ToString</code>ï¼Œå°±å¯ä»¥å°†ä»»ä½•ç±»å‹è½¬æ¢æˆ <code>String</code>ã€‚äº‹å®ä¸Šï¼Œè¿™ç§æ–¹å¼å¹¶ä¸æ˜¯æœ€å¥½çš„ï¼Œå¤§å®¶è¿˜è®°å¾— <code>fmt::Display</code> ç‰¹å¾å—ï¼Ÿå®ƒå¯ä»¥æ§åˆ¶ä¸€ä¸ªç±»å‹å¦‚ä½•æ‰“å°ï¼Œåœ¨å®ç°å®ƒçš„æ—¶å€™è¿˜ä¼šè‡ªåŠ¨å®ç° <code>ToString</code>ã€‚</p>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    // å®ç° fmt æ–¹æ³•
}

fn main() {
    let origin = Point { x: 0, y: 0 };
    // å¡«ç©º
    assert_eq!(origin.__, &quot;The point is (0, 0)&quot;);
    assert_eq!(format!(__), &quot;The point is (0, 0)&quot;);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="è§£æ-string"><a class="header" href="#è§£æ-string">è§£æ String</a></h3>
<ol start="2">
<li>ğŸŒŸğŸŒŸğŸŒŸ ä½¿ç”¨ <code>parse</code> æ–¹æ³•å¯ä»¥å°†ä¸€ä¸ª <code>String</code> è½¬æ¢æˆ <code>i32</code> æ•°å­—ï¼Œè¿™æ˜¯å› ä¸ºåœ¨æ ‡å‡†åº“ä¸­ä¸º <code>i32</code> ç±»å‹å®ç°äº† <code>FromStr</code>: : <code>impl FromStr for i32</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä¸ºäº†ä½¿ç”¨ `from_str` æ–¹æ³•, ä½ éœ€è¦å¼•å…¥è¯¥ç‰¹å¾åˆ°å½“å‰ä½œç”¨åŸŸä¸­
use std::str::FromStr;
fn main() {
    let parsed: i32 = &quot;5&quot;.__.unwrap();
    let turbo_parsed = &quot;10&quot;.__.unwrap();
    let from_str = __.unwrap();
    let sum = parsed + turbo_parsed + from_str;
    assert_eq!(sum, 35);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ è¿˜å¯ä»¥ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° <code>FromStr</code> ç‰¹å¾</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str::FromStr;
use std::num::ParseIntError;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32
}

impl FromStr for Point {
    type Err = ParseIntError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let coords: Vec&lt;&amp;str&gt; = s.trim_matches(|p| p == '(' || p == ')' )
                                 .split(',')
                                 .map(|x| x.trim())
                                 .collect();

        let x_fromstr = coords[0].parse::&lt;i32&gt;()?;
        let y_fromstr = coords[1].parse::&lt;i32&gt;()?;

        Ok(Point { x: x_fromstr, y: y_fromstr })
    }
}
fn main() {
    // ä½¿ç”¨ä¸¤ç§æ–¹å¼å¡«ç©º
    // ä¸è¦ä¿®æ”¹å…¶å®ƒåœ°æ–¹çš„ä»£ç 
    let p = __;
    assert_eq!(p.unwrap(), Point{ x: 3, y: 4} );

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="deref-ç‰¹å¾"><a class="header" href="#deref-ç‰¹å¾">Deref ç‰¹å¾</a></h3>
<p>Deref ç‰¹å¾åœ¨<a href="https://practice.rs/smart-pointers/deref.html">æ™ºèƒ½æŒ‡é’ˆ - Deref</a>ç« èŠ‚ä¸­æœ‰æ›´åŠ è¯¦ç»†çš„ä»‹ç»ã€‚</p>
<h3 id="transmute"><a class="header" href="#transmute">transmute</a></h3>
<p><code>std::mem::transmute</code> æ˜¯ä¸€ä¸ª unsafe å‡½æ•°ï¼Œå¯ä»¥æŠŠä¸€ä¸ªç±»å‹æŒ‰ä½è§£é‡Šä¸ºå¦ä¸€ä¸ªç±»å‹ï¼Œå…¶ä¸­è¿™ä¸¤ä¸ªç±»å‹å¿…é¡»æœ‰åŒæ ·çš„ä½æ•°( bits )ã€‚</p>
<p><code>transmute</code> ç›¸å½“äºå°†ä¸€ä¸ªç±»å‹æŒ‰ä½ç§»åŠ¨åˆ°å¦ä¸€ä¸ªç±»å‹ï¼Œå®ƒä¼šå°†æºå€¼çš„æ‰€æœ‰ä½æ‹·è´åˆ°ç›®æ ‡å€¼ä¸­ï¼Œç„¶åé—å¿˜æºå€¼ã€‚è¯¥å‡½æ•°è·Ÿ C è¯­è¨€ä¸­çš„ <code>memcpy</code> å‡½æ•°ç±»ä¼¼ã€‚</p>
<p>æ­£å› ä¸ºæ­¤ï¼Œ<strong><code>transmute</code> éå¸¸éå¸¸ä¸å®‰å…¨!</strong> è°ƒç”¨è€…å¿…é¡»è¦è‡ªå·±ä¿è¯ä»£ç çš„å®‰å…¨æ€§ï¼Œå½“ç„¶è¿™ä¹Ÿæ˜¯ unsafe çš„ç›®çš„ã€‚</p>
<h4 id="ç¤ºä¾‹-8"><a class="header" href="#ç¤ºä¾‹-8">ç¤ºä¾‹</a></h4>
<ol>
<li><code>transmute</code> å¯ä»¥å°†ä¸€ä¸ªæŒ‡é’ˆè½¬æ¢æˆä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œè¯¥è½¬æ¢å¹¶ä¸å…·å¤‡å¯ç§»æ¤æ€§ï¼ŒåŸå› æ˜¯åœ¨ä¸åŒæœºå™¨ä¸Šï¼Œå‡½æ•°æŒ‡é’ˆå’Œæ•°æ®æŒ‡é’ˆå¯èƒ½æœ‰ä¸åŒçš„ä½æ•°( size )ã€‚</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn foo() -&gt; i32 {
    0
}

fn main() {
    let pointer = foo as *const ();
    let function = unsafe {
        std::mem::transmute::&lt;*const (), fn() -&gt; i32&gt;(pointer)
    };
    assert_eq!(function(), 0);
}</code></pre></pre>
<ol start="2">
<li><code>transmute</code> è¿˜å¯ä»¥æ‰©å±•æˆ–ç¼©çŸ­ä¸€ä¸ªä¸å˜é‡çš„ç”Ÿå‘½å‘¨æœŸï¼Œå°† Unsafe Rust çš„ä¸å®‰å…¨æ€§ä½“ç°çš„æ·‹æ¼“å°½è‡´!</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct R&lt;'a&gt;(&amp;'a i32);
unsafe fn extend_lifetime&lt;'b&gt;(r: R&lt;'b&gt;) -&gt; R&lt;'static&gt; {
    std::mem::transmute::&lt;R&lt;'b&gt;, R&lt;'static&gt;&gt;(r)
}

unsafe fn shorten_invariant_lifetime&lt;'b, 'c&gt;(r: &amp;'b mut R&lt;'static&gt;)
                                             -&gt; &amp;'b mut R&lt;'c&gt; {
    std::mem::transmute::&lt;&amp;'b mut R&lt;'static&gt;, &amp;'b mut R&lt;'c&gt;&gt;(r)
}</code></pre></pre>
<ol start="3">
<li>äº‹å®ä¸Šæˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ä¸€äº›å®‰å…¨çš„æ–¹æ³•æ¥æ›¿ä»£ <code>transmute</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    /*Turning raw bytes(&amp;[u8]) to u32, f64, etc.: */
    let raw_bytes = [0x78, 0x56, 0x34, 0x12];

    let num = unsafe { std::mem::transmute::&lt;[u8; 4], u32&gt;(raw_bytes) };

    // use `u32::from_ne_bytes` instead
    let num = u32::from_ne_bytes(raw_bytes);
    // or use `u32::from_le_bytes` or `u32::from_be_bytes` to specify the endianness
    let num = u32::from_le_bytes(raw_bytes);
    assert_eq!(num, 0x12345678);
    let num = u32::from_be_bytes(raw_bytes);
    assert_eq!(num, 0x78563412);

    /*Turning a pointer into a usize: */
    let ptr = &amp;0;
    let ptr_num_transmute = unsafe { std::mem::transmute::&lt;&amp;i32, usize&gt;(ptr) };

    // Use an `as` cast instead
    let ptr_num_cast = ptr as *const i32 as usize;

    /*Turning an &amp;mut T into an &amp;mut U: */
    let ptr = &amp;mut 0;
    let val_transmuted = unsafe { std::mem::transmute::&lt;&amp;mut i32, &amp;mut u32&gt;(ptr) };

    // Now, put together `as` and reborrowing - note the chaining of `as`
    // `as` is not transitive
    let val_casts = unsafe { &amp;mut *(ptr as *mut i32 as *mut u32) };

    /*Turning an &amp;str into a &amp;[u8]: */
    // this is not a good way to do this.
    let slice = unsafe { std::mem::transmute::&lt;&amp;str, &amp;[u8]&gt;(&quot;Rust&quot;) };
    assert_eq!(slice, &amp;[82, 117, 115, 116]);

    // You could use `str::as_bytes`
    let slice = &quot;Rust&quot;.as_bytes();
    assert_eq!(slice, &amp;[82, 117, 115, 116]);

    // Or, just use a byte string, if you have control over the string
    // literal
    assert_eq!(b&quot;Rust&quot;, &amp;[82, 117, 115, 116]);
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/type-conversions/others.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-and-panic"><a class="header" href="#result-and-panic">Result and panic</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">Rust Book 9.1, 9.2</a></li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/result-error/intro.html">Rustè¯­è¨€åœ£ç» - è¿”å›å€¼å’Œé”™è¯¯å¤„ç†</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic">panic!</a></h1>
<p>Rust ä¸­æœ€ç®€å•çš„é”™è¯¯å¤„ç†æ–¹å¼å°±æ˜¯ä½¿ç”¨ <code>panic</code>ã€‚å®ƒä¼šæ‰“å°å‡ºä¸€æ¡é”™è¯¯ä¿¡æ¯å¹¶æ‰“å°å‡ºæ ˆè°ƒç”¨æƒ…å†µï¼Œæœ€ç»ˆç»“æŸå½“å‰çº¿ç¨‹:</p>
<ul>
<li>è‹¥ panic å‘ç”Ÿåœ¨ <code>main</code> çº¿ç¨‹ï¼Œé‚£ç¨‹åºä¼šéšä¹‹é€€å‡º</li>
<li>å¦‚æœæ˜¯åœ¨ç”Ÿæˆçš„( spawn )å­çº¿ç¨‹ä¸­å‘ç”Ÿ panic, é‚£ä¹ˆå½“å‰çš„çº¿ç¨‹ä¼šç»“æŸï¼Œä½†æ˜¯ç¨‹åºä¾ç„¶ä¼šç»§ç»­è¿è¡Œ</li>
</ul>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©º
fn drink(beverage: &amp;str) {
    if beverage == &quot;lemonade&quot; {
        println!(&quot;Success!&quot;);
        // å®ç°ä¸‹é¢çš„ä»£ç 
        __
     }

    println!(&quot;Exercise Failed if printing out this line!&quot;);
}

fn main() {
    drink(__);

    println!(&quot;Exercise Failed if printing out this line!&quot;);
}</code></pre></pre>
<h2 id="å¸¸è§çš„-panic"><a class="header" href="#å¸¸è§çš„-panic">å¸¸è§çš„ panic</a></h2>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// ä¿®å¤æ‰€æœ‰çš„ panicï¼Œè®©ä»£ç å·¥ä½œ
fn main() {
    assert_eq!(&quot;abc&quot;.as_bytes(), [96, 97, 98]);

    let v = vec![1, 2, 3];
    let ele = v[3];
    let ele = v.get(3).unwrap();

    // å¤§éƒ¨åˆ†æ—¶å€™ç¼–è¯‘å™¨æ˜¯å¯ä»¥å¸®æˆ‘ä»¬æå‰å‘ç°æº¢å‡ºé”™è¯¯ï¼Œå¹¶é˜»æ­¢ç¼–è¯‘é€šè¿‡ã€‚ä½†æ˜¯ä¹Ÿæœ‰ä¸€äº›æ—¶å€™ï¼Œè¿™ç§æº¢å‡ºé—®é¢˜ç›´åˆ°è¿è¡ŒæœŸæ‰ä¼šå‡ºç°
    let v = production_rate_per_hour(2);

    divide(15, 0);

    println!(&quot;Success!&quot;)
}

fn divide(x:u8, y:u8) {
    println!(&quot;{}&quot;, x / y)
}

fn production_rate_per_hour(speed: u8) -&gt; f64 {
    let cph: u8 = 221;
    match speed {
        1..=4 =&gt; (speed * cph) as f64,
        5..=8 =&gt; (speed * cph) as f64 * 0.9,
        9..=10 =&gt; (speed * cph) as f64 * 0.77,
        _ =&gt; 0 as f64,
    }
}

pub fn working_items_per_minute(speed: u8) -&gt; u32 {
    (production_rate_per_hour(speed) / 60 as f64) as u32
}</code></pre></pre>
<h3 id="è¯¦ç»†çš„æ ˆè°ƒç”¨ä¿¡æ¯"><a class="header" href="#è¯¦ç»†çš„æ ˆè°ƒç”¨ä¿¡æ¯">è¯¦ç»†çš„æ ˆè°ƒç”¨ä¿¡æ¯</a></h3>
<p>é»˜è®¤æƒ…å†µä¸‹ï¼Œæ ˆè°ƒç”¨åªä¼šå±•ç¤ºæœ€åŸºæœ¬çš„ä¿¡æ¯: </p>
<pre><code class="language-shell">thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>ä½†æ˜¯æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬è¿˜å¸Œæœ›è·å–æ›´è¯¦ç»†çš„ä¿¡æ¯:</p>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><code class="language-shell">## å¡«ç©ºä»¥æ‰“å°å…¨éƒ¨çš„è°ƒç”¨æ ˆ
## æç¤º: ä½ å¯ä»¥åœ¨ä¹‹å‰çš„é»˜è®¤ panic ä¿¡æ¯ä¸­æ‰¾åˆ°ç›¸å…³çº¿ç´¢
$ __ cargo run
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[97, 98, 99]`,
 right: `[96, 97, 98]`', src/main.rs:3:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/std/src/panicking.rs:498:5
   1: core::panicking::panic_fmt
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/panicking.rs:116:14
   2: core::panicking::assert_failed_inner
   3: core::panicking::assert_failed
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/panicking.rs:154:5
   4: study_cargo::main
             at ./src/main.rs:3:5
   5: core::ops::function::FnOnce::call_once
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<h3 id="unwinding-å’Œ-abort"><a class="header" href="#unwinding-å’Œ-abort"><code>unwinding</code> å’Œ <code>abort</code></a></h3>
<p>å½“å‡ºç° <code>panic!</code> æ—¶ï¼Œç¨‹åºæä¾›äº†ä¸¤ç§æ–¹å¼æ¥å¤„ç†ç»ˆæ­¢æµç¨‹ï¼š<strong>æ ˆå±•å¼€</strong>å’Œ<strong>ç›´æ¥ç»ˆæ­¢</strong>ã€‚</p>
<p>å…¶ä¸­ï¼Œé»˜è®¤çš„æ–¹å¼å°±æ˜¯ <code>æ ˆå±•å¼€</code>ï¼Œè¿™æ„å‘³ç€ Rust ä¼šå›æº¯æ ˆä¸Šæ•°æ®å’Œå‡½æ•°è°ƒç”¨ï¼Œå› æ­¤ä¹Ÿæ„å‘³ç€æ›´å¤šçš„å–„åå·¥ä½œï¼Œå¥½å¤„æ˜¯å¯ä»¥ç»™å‡ºå……åˆ†çš„æŠ¥é”™ä¿¡æ¯å’Œæ ˆè°ƒç”¨ä¿¡æ¯ï¼Œä¾¿äºäº‹åçš„é—®é¢˜å¤ç›˜ã€‚<code>ç›´æ¥ç»ˆæ­¢</code>ï¼Œé¡¾åæ€ä¹‰ï¼Œä¸æ¸…ç†æ•°æ®å°±ç›´æ¥é€€å‡ºç¨‹åºï¼Œå–„åå·¥ä½œäº¤ä¸æ“ä½œç³»ç»Ÿæ¥è´Ÿè´£ã€‚</p>
<p>å¯¹äºç»å¤§å¤šæ•°ç”¨æˆ·ï¼Œä½¿ç”¨é»˜è®¤é€‰æ‹©æ˜¯æœ€å¥½çš„ï¼Œä½†æ˜¯å½“ä½ å…³å¿ƒæœ€ç»ˆç¼–è¯‘å‡ºçš„äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶å¤§å°æ—¶ï¼Œé‚£ä¹ˆå¯ä»¥å°è¯•å»ä½¿ç”¨ç›´æ¥ç»ˆæ­¢çš„æ–¹å¼ï¼Œä¾‹å¦‚ä¸‹é¢çš„é…ç½®ä¿®æ”¹ <code>Cargo.toml</code> æ–‡ä»¶ï¼Œå®ç°åœ¨ <a href="result-panic/../first-try/cargo.html#%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE"><code>release</code></a> æ¨¡å¼ä¸‹é‡åˆ° <code>panic</code> ç›´æ¥ç»ˆæ­¢ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[profile.release]
panic = 'abort'
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/result-panic/panic.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-and-"><a class="header" href="#result-and-">result and ?</a></h1>
<p><code>Result&lt;T&gt;</code> æ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ç”¨äºæè¿°è¿”å›çš„ç»“æœæˆ–é”™è¯¯ï¼Œå®ƒåŒ…å«ä¸¤ä¸ªæˆå‘˜(å˜ä½“ variants) :</p>
<ul>
<li><code>Ok(T)</code>: è¿”å›ä¸€ä¸ªç»“æœå€¼ T</li>
<li><code>Err(e)</code>: è¿”å›ä¸€ä¸ªé”™è¯¯ï¼Œ<code>e</code> æ˜¯å…·ä½“çš„é”™è¯¯å€¼</li>
</ul>
<p>ç®€è€Œè¨€ä¹‹ï¼Œå¦‚æœæœŸå¾…ä¸€ä¸ªæ­£ç¡®çš„ç»“æœï¼Œå°±è¿”å› <code>Ok</code>ï¼Œåä¹‹åˆ™æ˜¯ <code>Err</code>ã€‚</p>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯
use std::num::ParseIntError;

fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; __ {
    let n1 = n1_str.parse::&lt;i32&gt;();
    let n2 = n2_str.parse::&lt;i32&gt;();
    Ok(n1.unwrap() * n2.unwrap())
}

fn main() {
    let result = multiply(&quot;10&quot;, &quot;2&quot;);
    assert_eq!(result, __);

    let result = multiply(&quot;t&quot;, &quot;2&quot;);
    assert_eq!(result.__, 8);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id=""><a class="header" href="#">?</a></h3>
<p><code>?</code> è·Ÿ <code>unwrap</code> éå¸¸åƒï¼Œä½†æ˜¯ <code>?</code> ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ï¼Œè€Œä¸æ˜¯ç›´æ¥ panic.</p>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::num::ParseIntError;

// ä½¿ç”¨ `?` æ¥å®ç° multiply
// ä¸è¦ä½¿ç”¨ unwrap !
fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; __ {
}

fn main() {
    assert_eq!(multiply(&quot;3&quot;, &quot;4&quot;).unwrap(), 12);
    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::fs::File;
use std::io::{self, Read};

fn read_file1() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);
    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// å¡«ç©º
// ä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç 
fn read_file2() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    __;

    Ok(s)
}

fn main() {
    assert_eq!(read_file1().unwrap_err().to_string(), read_file2().unwrap_err().to_string());
    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="map--and_then"><a class="header" href="#map--and_then">map &amp; and_then</a></h3>
<p><a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.map">map</a> and <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.and_then">and_then</a> æ˜¯ä¸¤ä¸ªå¸¸ç”¨çš„ç»„åˆå™¨( combinator )ï¼Œå¯ä»¥ç”¨äº <code>Result&lt;T, E&gt;</code> (ä¹Ÿå¯ç”¨äº <code>Option&lt;T&gt;</code>).</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// ä½¿ç”¨ä¸¤ç§æ–¹å¼å¡«ç©º: map, and then
fn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
   n_str.parse::&lt;i32&gt;().__
}

fn main() {
    assert_eq!(add_two(&quot;4&quot;).unwrap(), 6);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// ä½¿ç”¨ Result é‡å†™åï¼Œæˆ‘ä»¬ä½¿ç”¨æ¨¡å¼åŒ¹é…çš„æ–¹å¼æ¥å¤„ç†ï¼Œè€Œæ— éœ€ä½¿ç”¨ `unwrap`
// ä½†æ˜¯è¿™ç§å†™æ³•å®åœ¨è¿‡äºå•°å—¦..
fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match n1_str.parse::&lt;i32&gt;() {
        Ok(n1)  =&gt; {
            match n2_str.parse::&lt;i32&gt;() {
                Ok(n2)  =&gt; {
                    Ok(n1 * n2)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

// é‡å†™ä¸Šé¢çš„ `multiply` ï¼Œè®©å®ƒå°½é‡ç®€æ´
// æç¤ºï¼šä½¿ç”¨ `and_then` å’Œ `map`
fn multiply1(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    // å®ç°...
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let twenty = multiply1(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // ä¸‹é¢çš„è°ƒç”¨ä¼šæä¾›æ›´æœ‰å¸®åŠ©çš„é”™è¯¯ä¿¡æ¯
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="ç±»å‹åˆ«å"><a class="header" href="#ç±»å‹åˆ«å">ç±»å‹åˆ«å</a></h3>
<p>å¦‚æœæˆ‘ä»¬è¦åœ¨ä»£ç ä¸­åˆ°å¤„ä½¿ç”¨ <code>std::result::Result&lt;T, ParseIntError&gt;</code> ï¼Œé‚£æ¯«æ— ç–‘é—®ï¼Œä»£ç å°†å˜å¾—ç‰¹åˆ«å†—é•¿å’Œå•°å—¦ï¼Œå¯¹äºè¿™ç§æƒ…å†µï¼Œå¯ä»¥ä½¿ç”¨ç±»å‹åˆ«åæ¥è§£å†³ã€‚</p>
<p>ä¾‹å¦‚åœ¨æ ‡å‡†åº“ä¸­ï¼Œå°±åœ¨å¤§é‡ä½¿ç”¨è¿™ç§æ–¹å¼æ¥ç®€åŒ–ä»£ç : <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>.</p>
<ol start="6">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// å¡«ç©º
type __;

// ä½¿ç”¨ä¸Šé¢çš„åˆ«åæ¥å¼•ç”¨åŸæ¥çš„ `Result` ç±»å‹
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Res&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

// åŒæ ·, è¿™é‡Œä¹Ÿä½¿ç”¨äº†ç±»å‹åˆ«åæ¥ç®€åŒ–ä»£ç 
fn print(result: Res&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h3 id="åœ¨-fn-main-ä¸­ä½¿ç”¨-result"><a class="header" href="#åœ¨-fn-main-ä¸­ä½¿ç”¨-result">åœ¨ <code>fn main</code> ä¸­ä½¿ç”¨ <code>Result</code></a></h3>
<p>ä¸€ä¸ªå…¸å‹çš„ <code>main</code> å‡½æ•°é•¿è¿™æ ·: </p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;Hello World!&quot;);
}</code></pre></pre>
<p>äº‹å®ä¸Š <code>main</code> å‡½æ•°è¿˜å¯ä»¥è¿”å›ä¸€ä¸ª <code>Result</code> ç±»å‹ï¼šå¦‚æœ <code>main</code> å‡½æ•°å†…éƒ¨å‘ç”Ÿäº†é”™è¯¯ï¼Œé‚£è¯¥é”™è¯¯ä¼šè¢«è¿”å›å¹¶ä¸”æ‰“å°å‡ºä¸€æ¡é”™è¯¯çš„ debug ä¿¡æ¯ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::num::ParseIntError;

fn main() -&gt; Result&lt;(), ParseIntError&gt; {
    let number_str = &quot;10&quot;;
    let number = match number_str.parse::&lt;i32&gt;() {
        Ok(number)  =&gt; number,
        Err(e) =&gt; return Err(e),
    };
    println!(&quot;{}&quot;, number);
    Ok(())
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/result-panic/result.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="åŒ…å’Œæ¨¡å—"><a class="header" href="#åŒ…å’Œæ¨¡å—">åŒ…å’Œæ¨¡å—</a></h1>
<p>å­¦ä¹ èµ„æ–™: </p>
<ul>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/crate-module/intro.html">Rustè¯­è¨€åœ£ç» - åŒ…å’Œæ¨¡å—</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-and-crate"><a class="header" href="#package-and-crate">Package and Crate</a></h1>
<p><code>package</code> æ˜¯ä½ é€šè¿‡ <code>Cargo</code> åˆ›å»ºçš„å·¥ç¨‹æˆ–é¡¹ç›®ï¼Œå› æ­¤åœ¨ <code>package</code> çš„æ ¹ç›®å½•ä¸‹ä¼šæœ‰ä¸€ä¸ª <code>Cargo.toml</code> æ–‡ä»¶ã€‚</p>
<ol>
<li>ğŸŒŸ åˆ›å»ºä¸€ä¸ª <code>package</code>ï¼Œæ‹¥æœ‰ä»¥ä¸‹ç›®å½•ç»“æ„:</li>
</ol>
<pre><code class="language-shell">.
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
    â””â”€â”€ main.rs

1 directory, 2 files
</code></pre>
<pre><code class="language-toml"># in Cargo.toml
[package]
name = &quot;hello-package&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<blockquote>
<p>æ³¨æ„! æˆ‘ä»¬ä¼šåœ¨åŒ…ä¸æ¨¡å—ä¸­ä½¿ç”¨ä¸Šé¢çš„é¡¹ç›®ä½œä¸ºæ¼”ç¤ºï¼Œå› æ­¤ä¸è¦åˆ é™¤</p>
</blockquote>
<ol start="2">
<li>ğŸŒŸ åˆ›å»ºä¸€ä¸ª packageï¼Œæ‹¥æœ‰ä»¥ä¸‹ç›®å½•ç»“æ„:</li>
</ol>
<pre><code class="language-shell">.
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
    â””â”€â”€ lib.rs

1 directory, 2 files
</code></pre>
<pre><code class="language-toml"># in Cargo.toml
[package]
name = &quot;hello-package1&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<blockquote>
<p>è¯¥é¡¹ç›®å¯ä»¥å®‰å…¨çš„ç§»é™¤</p>
</blockquote>
<ol start="3">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* ä½¿ç”¨ä½ çš„ç­”æ¡ˆå¡«ç©º */

// Q: package 1# å’Œ 2# çš„åŒºåˆ«æ˜¯ä»€ä¹ˆ ?
// A: __</code></pre></pre>
<h2 id="åŒ…crate"><a class="header" href="#åŒ…crate">åŒ…Crate</a></h2>
<p>ä¸€ä¸ªåŒ…å¯ä»¥æ˜¯äºŒè¿›åˆ¶ä¹Ÿå¯ä»¥ä¸€ä¸ªä¾èµ–åº“ã€‚æ¯ä¸€ä¸ªåŒ…éƒ½æœ‰ä¸€ä¸ªåŒ…æ ¹ï¼Œä¾‹å¦‚äºŒè¿›åˆ¶åŒ…çš„åŒ…æ ¹æ˜¯ <code>src/main.rs</code>ï¼Œåº“åŒ…çš„åŒ…æ ¹æ˜¯ <code>src/lib.rs</code>ã€‚åŒ…æ ¹æ˜¯ç¼–è¯‘å™¨å¼€å§‹å¤„ç†æºä»£ç æ–‡ä»¶çš„åœ°æ–¹ï¼ŒåŒæ—¶ä¹Ÿæ˜¯åŒ…æ¨¡å—æ ‘çš„æ ¹éƒ¨ã€‚ </p>
<p>åœ¨ package <code>hello-package</code> ä¸­ï¼Œæœ‰ä¸€ä¸ªäºŒè¿›åˆ¶åŒ…ï¼Œè¯¥åŒ…ä¸ <code>package</code> åŒå : <code>hello-package</code>,  å…¶ä¸­ <code>src/main.rs</code> æ˜¯è¯¥äºŒè¿›åˆ¶åŒ…çš„åŒ…æ ¹.</p>
<p>ä¸ <code>hello-package</code> ç±»ä¼¼, <code>hello-package1</code> åŒæ ·åŒ…å«ä¸€ä¸ªåŒ…ï¼Œä½†æ˜¯ä¸ä¹‹å‰çš„äºŒè¿›åˆ¶åŒ…ä¸åŒï¼Œè¯¥ package åŒ…å«çš„æ˜¯åº“åŒ…ï¼Œå…¶ä¸­ <code>src/lib.rs</code> æ˜¯å…¶åŒ…æ ¹.</p>
<ol start="4">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* å¡«ç©º */

// Q: package `hello-package1` ä¸­çš„åº“åŒ…åç§°æ˜¯?
// A: __</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ ä¸º <code>hello-package</code> æ·»åŠ ä¸€ä¸ªåº“åŒ…ï¼Œå¹¶ä¸”å®Œæˆä»¥ä¸‹ç›®å½•ç»“æ„çš„å¡«ç©º:</li>
</ol>
<pre><code class="language-shell editable"># å¡«ç©º
.
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ __
â”‚Â Â  â””â”€â”€ __
</code></pre>
<p>åœ¨ä¸Šä¸€ä¸ªæ­¥éª¤åï¼Œæˆ‘ä»¬çš„ <code>hello-package</code> ä¸­å·²ç»å­˜åœ¨ä¸¤ä¸ªåŒ…ï¼šä¸€ä¸ªäºŒè¿›åˆ¶åŒ…å’Œä¸€ä¸ªåº“åŒ…ï¼Œä¸¤ä¸ªåŒ…çš„åç§°éƒ½ä¸ package ç›¸åŒï¼š<code>hello-package</code>ã€‚</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸ ä¸€ä¸ª package æœ€å¤šåªèƒ½åŒ…å«ä¸€ä¸ªåº“åŒ…ï¼Œä½†æ˜¯å´å¯ä»¥åŒ…å«å¤šä¸ªäºŒè¿›åˆ¶åŒ…ï¼šé€šè¿‡å°†äºŒè¿›åˆ¶æ–‡ä»¶æ”¾å…¥åˆ° <code>src/bin</code> ç›®å½•ä¸‹å®ç°: <strong>è¯¥ç›®å½•ä¸‹çš„æ¯ä¸ªæ–‡ä»¶éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„äºŒè¿›åˆ¶åŒ…ï¼ŒåŒ…åä¸æ–‡ä»¶åç›¸åŒï¼Œä¸å†ä¸ package çš„åç§°ç›¸åŒã€‚</strong>.</li>
</ol>
<pre><code class="language-shell editable"># åˆ›å»ºä¸€ä¸ª a package åŒ…å«ä»¥ä¸‹åŒ…ï¼š 
# 1. ä¸‰ä¸ªäºŒè¿›åˆ¶åŒ…: `hello-package`, `main1` and `main2`
# 2. ä¸€ä¸ªåº“åŒ…
# å¹¶å®Œæˆä»¥ä¸‹ç›®å½•ç»“æ„çš„å¡«ç©º
.
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ __
â”‚   â”œâ”€â”€ __
â”‚   â””â”€â”€ __
â”‚       â””â”€â”€ __
â”‚       â””â”€â”€ __
â”œâ”€â”€ tests # å­˜æ”¾é›†æˆæµ‹è¯•æ–‡ä»¶çš„ç›®å½•
â”‚   â””â”€â”€ some_integration_tests.rs
â”œâ”€â”€ benches # å­˜æ”¾ benchmark æ–‡ä»¶çš„ç›®å½•dir for benchmark files
â”‚   â””â”€â”€ simple_bench.rs
â””â”€â”€ examples # å­˜æ”¾ç¤ºä¾‹æ–‡ä»¶çš„ç›®å½•
    â””â”€â”€ simple_example.rs
</code></pre>
<p>å¯ä»¥çœ‹åˆ°ï¼Œä¸Šé¢çš„ package ç»“æ„éå¸¸æ ‡å‡†ï¼Œä½ å¯ä»¥åœ¨å¾ˆå¤š Rust é¡¹ç›®ä¸­çœ‹åˆ°è¯¥ç»“æ„çš„èº«å½±ã€‚</p>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/crate-module/crate.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module"><a class="header" href="#module">Module</a></h1>
<p>åœ¨ Rust è¯­è¨€åœ£ç»ä¸­ï¼Œæˆ‘ä»¬å·²ç»æ·±å…¥è®²è§£è¿‡<a href="https://course.rs/basic/crate-module/module.html">æ¨¡å—module</a>ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ï¼Œç›´æ¥å¼€å§‹æˆ‘ä»¬çš„ç»ƒä¹ ã€‚</p>
<p>ä¹‹å‰æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª package <code>hello-package</code>ï¼Œå®ƒçš„ç›®å½•ç»“æ„åœ¨ç»è¿‡å¤šæ¬¡ä¿®æ”¹åï¼Œå˜æˆäº†ä»¥ä¸‹æ¨¡æ ·:</p>
<pre><code class="language-shell">.
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ lib.rs
â”‚Â Â  â””â”€â”€ main.rs
</code></pre>
<p>ä¸‹é¢ï¼Œæˆ‘ä»¬æ¥ä¸ºå…¶ä¸­çš„åº“åŒ…åˆ›å»ºä¸€äº›æ¨¡å—ï¼Œç„¶ååœ¨äºŒè¿›åˆ¶åŒ…ä¸­ä½¿ç”¨è¿™äº›æ¨¡å—ã€‚</p>
<ol>
<li>ğŸŒŸğŸŒŸ æ ¹æ®ä»¥ä¸‹çš„æ¨¡å—æ ‘æè¿°å®ç°æ¨¡å— <code>front_of_house</code> :</li>
</ol>
<pre><code class="language-shell">åº“åŒ…çš„æ ¹(src/lib.rs)
 â””â”€â”€ front_of_house
     â”œâ”€â”€ hosting
     â”‚   â”œâ”€â”€ add_to_waitlist
     â”‚   â””â”€â”€ seat_at_table
     â””â”€â”€ serving
         â”œâ”€â”€ take_order
         â”œâ”€â”€ serve_order
         â”œâ”€â”€ take_payment
         â””â”€â”€ complain
</code></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// å¡«ç©º
// in __.rs

mod front_of_house {
    // å®ç°æ­¤æ¨¡å—
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ è®©æˆ‘ä»¬åœ¨åº“åŒ…çš„æ ¹ä¸­å®šä¹‰ä¸€ä¸ªå‡½æ•° <code>eat_at_restaurant</code>, ç„¶ååœ¨è¯¥å‡½æ•°ä¸­è°ƒç”¨ä¹‹å‰åˆ›å»ºçš„å‡½æ•° <code>eat_at_restaurant</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯

// æç¤ºï¼šä½ éœ€è¦é€šè¿‡ `pub` å°†ä¸€äº›é¡¹æ ‡è®°ä¸ºå…¬æœ‰çš„ï¼Œè¿™æ ·æ¨¡å— `front_of_house` ä¸­çš„é¡¹æ‰èƒ½è¢«æ¨¡å—å¤–çš„é¡¹è®¿é—®
mod front_of_house {
    /* ...snip... */
}

pub fn eat_at_restaurant() {
    // ä½¿ç”¨ç»å¯¹è·¯å¾„è°ƒç”¨
    __.add_to_waitlist();

    // ä½¿ç”¨ç›¸å¯¹è·¯å¾„è°ƒç”¨
     __.add_to_waitlist();
}
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ <code>super</code> æ¥å¯¼å…¥çˆ¶æ¨¡å—ä¸­çš„é¡¹</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in lib.rs

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        // ä½¿ç”¨ä¸‰ç§æ–¹å¼å¡«ç©º
        //1. ä½¿ç”¨å…³é”®å­— `super`
        //2. ä½¿ç”¨ç»å¯¹è·¯å¾„
        __.serve_order();
    }

    fn cook_order() {}
}</code></pre></pre>
<h3 id="å°†æ¨¡å—åˆ†ç¦»å¹¶æ”¾å…¥ç‹¬ç«‹çš„æ–‡ä»¶ä¸­"><a class="header" href="#å°†æ¨¡å—åˆ†ç¦»å¹¶æ”¾å…¥ç‹¬ç«‹çš„æ–‡ä»¶ä¸­">å°†æ¨¡å—åˆ†ç¦»å¹¶æ”¾å…¥ç‹¬ç«‹çš„æ–‡ä»¶ä¸­</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs
pub mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}

        pub fn seat_at_table() -&gt; String {
            String::from(&quot;sit down please&quot;)
        }
    }

    pub mod serving {
        pub fn take_order() {}

        pub fn serve_order() {}

        pub fn take_payment() {}

        // æˆ‘çŒœä½ ä¸å¸Œæœ›é¡¾å®¢å¬åˆ°ä½ åœ¨æŠ±æ€¨ä»–ä»¬ï¼Œå› æ­¤è®©è¿™ä¸ªå‡½æ•°ç§æœ‰åŒ–å§
        fn complain() {} 
    }
}

pub fn eat_at_restaurant() -&gt; String {
    front_of_house::hosting::add_to_waitlist();
    
    back_of_house::cook_order();

    String::from(&quot;yummy yummy!&quot;)
}

pub mod back_of_house {
    pub fn fix_incorrect_order() {
        cook_order();
        crate::front_of_house::serving::serve_order();
    }

    pub fn cook_order() {}
}
<span class="boring">}</span></code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ è¯·å°†ä¸Šé¢çš„æ¨¡å—å’Œä»£ç åˆ†ç¦»åˆ°ä»¥ä¸‹ç›®å½•æ–‡ä»¶ä¸­e :</li>
</ol>
<pre><code class="language-shell">.
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ back_of_house.rs
â”‚Â Â  â”œâ”€â”€ front_of_house
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hosting.rs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ mod.rs
â”‚Â Â  â”‚Â Â  â””â”€â”€ serving.rs
â”‚Â Â  â”œâ”€â”€ lib.rs
â”‚Â Â  â””â”€â”€ main.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in src/lib.rs

// IMPLEMENT...</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in src/back_of_house.rs

// IMPLEMENT...</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in src/front_of_house/mod.rs

// IMPLEMENT...</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in src/front_of_house/hosting.rs

// IMPLEMENT...</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in src/front_of_house/serving.rs

// IMPLEMENT...</code></pre></pre>
<h3 id="ä»äºŒè¿›åˆ¶åŒ…ä¸­è®¿é—®åº“åŒ…çš„ä»£ç "><a class="header" href="#ä»äºŒè¿›åˆ¶åŒ…ä¸­è®¿é—®åº“åŒ…çš„ä»£ç ">ä»äºŒè¿›åˆ¶åŒ…ä¸­è®¿é—®åº“åŒ…çš„ä»£ç </a></h3>
<p><strong>è¯·ç¡®ä¿ä½ å·²ç»å®Œæˆäº†ç¬¬å››é¢˜ï¼Œç„¶åå†ç»§ç»­è¿›è¡Œ.</strong></p>
<p>å½“åˆ°åº•æ­¤å¤„æ—¶ï¼Œä½ çš„é¡¹ç›®ç»“æ„åº”è¯¥å¦‚ä¸‹æ‰€ç¤º: </p>
<pre><code class="language-shell">.
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ back_of_house.rs
â”‚Â Â  â”œâ”€â”€ front_of_house
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hosting.rs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ mod.rs
â”‚Â Â  â”‚Â Â  â””â”€â”€ serving.rs
â”‚Â Â  â”œâ”€â”€ lib.rs
â”‚Â Â  â””â”€â”€ main.rs
</code></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸğŸŒŸç°åœ¨æˆ‘ä»¬å¯ä»¥ä»äºŒè¿›åˆ¶åŒ…ä¸­å‘èµ·å‡½æ•°è°ƒç”¨äº†.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in src/main.rs

// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯
fn main() {
    assert_eq!(__, &quot;sit down please&quot;);
    assert_eq!(__,&quot;yummy yummy!&quot;);
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/crate-module/module.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-and-pub"><a class="header" href="#use-and-pub">use and pub</a></h1>
<ol>
<li>ğŸŒŸ ä½¿ç”¨ <code>use</code> å¯ä»¥å°†ä¸¤ä¸ªåŒåç±»å‹å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸä¸­ï¼Œä½†æ˜¯åˆ«å¿˜äº† <code>as</code> å…³é”®å­—.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Result;
use std::io::Result;

fn main() {}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ å¦‚æœæˆ‘ä»¬åœ¨ä½¿ç”¨æ¥è‡ªåŒä¸€ä¸ªåŒ…æˆ–æ¨¡å—ä¸­çš„å¤šä¸ªä¸åŒé¡¹ï¼Œé‚£ä¹ˆå¯ä»¥é€šè¿‡ç®€å•çš„æ–¹å¼å°†å®ƒä»¬ä¸€æ¬¡æ€§å¼•å…¥è¿›æ¥</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// ä½¿ç”¨ä¸¤ç§æ–¹å¼å¡«ç©º
// ä¸è¦æ·»åŠ æ–°çš„ä»£ç è¡Œ
use std::collections::__;

fn main() {
    let _c1:HashMap&lt;&amp;str, i32&gt; = HashMap::new();
    let mut c2 = BTreeMap::new();
    c2.insert(1, &quot;a&quot;);
    let _c3: HashSet&lt;i32&gt; = HashSet::new();
}</code></pre></pre>
<h3 id="ä½¿ç”¨-pub-use-è¿›è¡Œå†å¯¼å‡º"><a class="header" href="#ä½¿ç”¨-pub-use-è¿›è¡Œå†å¯¼å‡º">ä½¿ç”¨ <code>pub use</code> è¿›è¡Œå†å¯¼å‡º</a></h3>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ åœ¨ä¹‹å‰åˆ›å»ºçš„<code>hello-package</code> çš„åº“åŒ…ä¸­, æ·»åŠ ä¸€äº›ä»£ç è®©ä¸‹é¢çš„ä»£ç èƒ½å¤Ÿæ­£å¸¸å·¥ä½œ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(hello_package::hosting::seat_at_table(), &quot;sit down please&quot;);
     assert_eq!(hello_package::eat_at_restaurant(),&quot;yummy yummy!&quot;);
}</code></pre></pre>
<h3 id="pubin-crate"><a class="header" href="#pubin-crate">pub(in Crate)</a></h3>
<p>æœ‰æ—¶æˆ‘ä»¬å¸Œæœ›æŸä¸€ä¸ªé¡¹åªå¯¹ç‰¹å®šçš„åŒ…å¯è§ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨ <code>pub(in Crate)</code> è¯­æ³•.</p>
<h4 id="ç¤ºä¾‹-9"><a class="header" href="#ç¤ºä¾‹-9">ç¤ºä¾‹</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub mod a {
    pub const I: i32 = 3;

    fn semisecret(x: i32) -&gt; i32 {
        use self::b::c::J;
        x + J
    }

    pub fn bar(z: i32) -&gt; i32 {
        semisecret(I) * z
    }
    pub fn foo(y: i32) -&gt; i32 {
        semisecret(I) + y
    }

    mod b {
        pub(in crate::a) mod c {
            pub(in crate::a) const J: i32 = 4;
        }
    }
}</code></pre></pre>
<h3 id="å®Œæ•´ä»£ç "><a class="header" href="#å®Œæ•´ä»£ç ">å®Œæ•´ä»£ç </a></h3>
<p>è‡³æ­¤ï¼ŒåŒ…ä¸æ¨¡å—ç« èŠ‚å·²ç»ç»“æŸï¼Œå…³äº <code>hello-package</code> çš„å®Œæ•´ä»£ç å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/tree/master/practices/hello-package">è¿™é‡Œ</a> æ‰¾åˆ°.</p>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/crate-module/use-pub.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ³¨é‡Šå’Œæ–‡æ¡£"><a class="header" href="#æ³¨é‡Šå’Œæ–‡æ¡£">æ³¨é‡Šå’Œæ–‡æ¡£</a></h1>
<p>æœ¬ç« çš„å­¦ä¹ èµ„æ–™åœ¨<a href="https://course.rs/basic/comment.html">è¿™é‡Œ</a>ï¼Œå¤§å®¶å¯ä»¥å…ˆè¡Œå­¦ä¹ åå†æ¥åšé¢˜ã€‚</p>
<h2 id="æ³¨é‡Š"><a class="header" href="#æ³¨é‡Š">æ³¨é‡Š</a></h2>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
/* åªä½¿ç”¨æ³¨é‡Šè®©ä¸‹é¢ä»£ç å·¥ä½œ! */
fn main() {
    todo!();
    unimplemented!();

    assert_eq!(6, 5 + 3 + 2 + 1 )
}</code></pre></pre>
<h2 id="æ–‡æ¡£æ³¨é‡Š"><a class="header" href="#æ–‡æ¡£æ³¨é‡Š">æ–‡æ¡£æ³¨é‡Š</a></h2>
<p>æ–‡æ¡£æ³¨é‡Šä¼šè¢«è§£æä¸º HTML æ–‡ä»¶ï¼Œå¹¶æ”¯æŒ <code>Markdown</code> è¯­æ³•ã€‚</p>
<p>åœ¨å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„é¡¹ç›®ç”¨äºåé¢çš„ç»ƒä¹ : <code>cargo new --lib doc-comments</code>.</p>
<h3 id="è¡Œæ–‡æ¡£æ³¨é‡Š-"><a class="header" href="#è¡Œæ–‡æ¡£æ³¨é‡Š-">è¡Œæ–‡æ¡£æ³¨é‡Š <code>///</code></a></h3>
<p>ä¸º <code>add_one</code> å‡½æ•°æ·»åŠ æ–‡æ¡£</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

/// Add one to the given value and return the value
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cargo-doc"><a class="header" href="#cargo-doc">Cargo doc</a></h3>
<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ <code>cargo doc --open</code> æ¥ç”Ÿæˆ HTML æ–‡ä»¶ï¼Œå¹¶è‡ªåŠ¨åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ç½‘é¡µã€‚</p>
<h3 id="å—æ–‡æ¡£æ³¨é‡Š---"><a class="header" href="#å—æ–‡æ¡£æ³¨é‡Š---">å—æ–‡æ¡£æ³¨é‡Š <code>/** ... */</code></a></h3>
<p>ä¸ºå‡½æ•° <code>add_two</code> æ·»åŠ æ–‡æ¡£:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/** Add two to the given value and return a new value

<span class="boring">Examples
</span>
let arg = 5;
let answer = my_crate::add_two(arg);

assert_eq!(7, answer);

*/
pub fn add_two(x: i32) -&gt; i32 {
    x + 2
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ä¸ºåŒ…å’Œæ¨¡å—åˆ›å»ºæ–‡æ¡£æ³¨é‡Š"><a class="header" href="#ä¸ºåŒ…å’Œæ¨¡å—åˆ›å»ºæ–‡æ¡£æ³¨é‡Š">ä¸ºåŒ…å’Œæ¨¡å—åˆ›å»ºæ–‡æ¡£æ³¨é‡Š</a></h3>
<p>æˆ‘ä»¬è¿˜å¯ä»¥åˆ›å»ºåŒ…å’Œæ¨¡å—çš„æ³¨é‡Šï¼Œç”¨äºæè¿°å®ƒä»¬çš„åŠŸèƒ½ã€‚</p>
<p>é¦–å…ˆï¼Œæ¥ä¸ºæˆ‘ä»¬çš„åº“åŒ…æ·»åŠ ä¸€äº›æ–‡æ¡£æ³¨é‡Š:</p>
<blockquote>
<p>æ³¨æ„: å¿…é¡»è¦å°†åŒ…ã€æ¨¡å—æ³¨é‡Šæ”¾ç½®åœ¨åŒ…æ ¹æˆ–æ¨¡å—æ–‡ä»¶çš„æœ€é¡¶éƒ¨</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! # æ–‡æ¡£æ³¨é‡Š
//! 
//! è¯¥åº“ç”¨äºæ–‡æ¡£æ³¨é‡Šçš„æ•™å­¦

// in lib.rs
pub mod compute;
<span class="boring">}</span></code></pre></pre>
<p>åŒæ ·çš„ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨å—æ³¨é‡Šæ¥è¾¾æˆç›®çš„:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*! # æ–‡æ¡£æ³¨é‡Š

 è¯¥åº“ç”¨äºæ–‡æ¡£æ³¨é‡Šçš„æ•™å­¦ */
<span class="boring">}</span></code></pre></pre>
<p>ä¸‹ä¸€æ­¥ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„æ¨¡å—æ–‡ä»¶ <code>src/compute.rs</code>, ç„¶ååœ¨å…¶ä¸­æ·»åŠ ä»¥ä¸‹æ³¨é‡Š:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! æœ¬æ¨¡å—ç”¨äºå¤„ç†ä¸€äº›å¤æ‚è®¡ç®—

// in compute.rs
<span class="boring">}</span></code></pre></pre>
<p>ç„¶åè¿è¡Œ <code>cargo doc --open</code> æŸ¥çœ‹ä¸‹ç»“æœã€‚</p>
<h3 id="æ–‡æ¡£æµ‹è¯•"><a class="header" href="#æ–‡æ¡£æµ‹è¯•">æ–‡æ¡£æµ‹è¯•</a></h3>
<p>ç»†å¿ƒçš„åŒå­¦å¯èƒ½ä¼šå‘ç°ä¹‹å‰çš„ <code>add_one</code> å’Œ <code>add_tow</code> çš„æ–‡æ¡£æ³¨é‡Šä¸­ï¼ŒåŒ…å«äº†ä¸¤ä¸ªç¤ºä¾‹ä»£ç å—.</p>
<p>ä»¥ä¸Šç¤ºä¾‹ä¸ä»…ä»…æ˜¯ä½œä¸ºæ–‡æ¡£ç”¨äºæ¼”ç¤ºä½ çš„å‡½æ•°è¯¥å¦‚ä½•ä½¿ç”¨ï¼Œå®ƒçš„å¦ä¸€ä¸ªä½œç”¨å°±æ˜¯ç”¨äºæ–‡æ¡£æµ‹è¯• <code>cargo test</code>ã€‚</p>
<ol start="2">
<li>ğŸŒŸğŸŒŸ ä½†æ˜¯åœ¨è¿™ä¸¤ä¸ªå‡½æ•°çš„ç¤ºä¾‹ä¸­ï¼Œå­˜åœ¨é”™è¯¯ï¼Œè¯·ä¿®å¤å®ƒä»¬å¹¶ä½¿ç”¨ <code>cargo test</code> è·å–ä»¥ä¸‹è¾“å‡ºç»“æœ: </li>
</ol>
<pre><code class="language-shell">running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests doc-comments

running 2 tests
test src/lib.rs - add_one (line 11) ... ok
test src/lib.rs - add_two (line 26) ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.55s
</code></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ æœ‰æ—¶æˆ‘ä»¬ä¼šæœŸæœ›ç¤ºä¾‹çš„ç»“æœæ˜¯ä¸€ä¸ª panicã€‚å°†ä»¥ä¸‹ä»£ç æ·»åŠ åˆ° <code>src/compute.rs</code> ï¼Œå¹¶ä¸”è®©  <code>cargo test</code> æˆåŠŸè¿è¡Œ.</li>
</ol>
<blockquote>
<p>ä½ åªèƒ½ä¿®æ”¹æ³¨é‡Šï¼Œä¸è¦ä¿®æ”¹ <code>fn div</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in src/compute.rs

/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust,should_panic
/// // panics on division by zero
/// doc_comments::compute::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    }

    a / b
}
<span class="boring">}</span></code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ æœ‰æ—¶æˆ‘ä»¬ä¼šæƒ³è¦éšè—æ–‡æ¡£ï¼Œä½†æ˜¯ä¿ç•™æ–‡æ¡£æµ‹è¯•</li>
</ol>
<p>å°†ä»¥ä¸‹ä»£ç æ·»åŠ åˆ° <code>src/compute.rs</code> ,</p>
<pre><pre class="playground"><code class="language-rust edition2021">// in src/compute.rs

/// ```
/// # fn try_main() -&gt; Result&lt;(), String&gt; {
/// let res = doc_comments::compute::try_div(10, 0)?;
/// # Ok(()) // returning from try_main
/// # }
/// # fn main() { 
/// #    try_main().unwrap();
/// #
/// # }
/// ```
pub fn try_div(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from(&quot;Divide-by-zero&quot;))
    } else {
        Ok(a / b)
    }
}</code></pre></pre>
<p>ç„¶åä¿®æ”¹ä»¥ä¸Šä»£ç å·²å®ç°ä¸¤ä¸ªç›®æ ‡:</p>
<ul>
<li>æ–‡æ¡£æ³¨é‡Šä¸èƒ½å‡ºç°åœ¨ <code>cargo doc --open</code> ç”Ÿæˆçš„ç½‘é¡µä¸­</li>
<li>è¿è¡Œæµ‹è¯•ï¼Œå¹¶æˆåŠŸçœ‹åˆ°ä»¥ä¸‹ç»“æœ:</li>
</ul>
<pre><code class="language-shell">running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests doc-comments

running 4 tests
test src/compute.rs - compute::div (line 7) ... ok
test src/lib.rs - add_two (line 27) ... ok
test src/lib.rs - add_one (line 11) ... ok
test src/compute.rs - compute::try_div (line 20) ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.51s
</code></pre>
<h3 id="ä»£ç è·³è½¬"><a class="header" href="#ä»£ç è·³è½¬">ä»£ç è·³è½¬</a></h3>
<p>Rust ä¸ºæˆ‘ä»¬æä¾›ä¸€ä¸ªéå¸¸å¼ºå¤§çš„ç‰¹æ€§ï¼šå¯ä»¥åœ¨æ–‡æ¡£æ³¨é‡Šä¸­å®ç°ä»£ç è·³è½¬ã€‚</p>
<p>å°†ä»¥ä¸‹ä»£ç æ·»åŠ åˆ° <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

/// Add one to the given value and return a [`Option`] type
pub fn add_three(x: i32) -&gt; Option&lt;i32&gt; {
    Some(x + 3)
}
<span class="boring">}</span></code></pre></pre>
<p>é™¤äº†è·³è½¬åˆ°æ ‡å‡†åº“ä¸­ï¼Œæˆ‘ä»¬è¿˜èƒ½è·³è½¬åˆ°é¡¹ç›®ä¸­çš„å…¶å®ƒæ¨¡å—ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

mod a {
    /// Add four to the given value and return a [`Option`] type
    /// [`crate::MySpecialFormatter`]
    pub fn add_four(x: i32) -&gt; Option&lt;i32&gt; {
        Some(x + 4)
    }
}

struct MySpecialFormatter;
<span class="boring">}</span></code></pre></pre>
<h3 id="æ–‡æ¡£å±æ€§"><a class="header" href="#æ–‡æ¡£å±æ€§">æ–‡æ¡£å±æ€§</a></h3>
<p>ä¸‹é¢æ˜¯å¾ˆå¸¸ç”¨çš„ <code>#[doc]</code> å±æ€§ï¼Œè¯¥å±æ€§å¯ä»¥è¢« <code>rustdoc</code> æ‰€ä½¿ç”¨ã€‚</p>
<h3 id="inline"><a class="header" href="#inline"><code>inline</code></a></h3>
<p>å¯ä»¥ç”¨äºå†…è”æ–‡æ¡£, è€Œä¸æ˜¯é“¾æ¥åˆ°ä¸€ä¸ªå•ç‹¬çš„é¡µé¢ã€‚</p>
<pre><code class="language-rust ignore">#[doc(inline)]
pub use bar::Bar;

/// bar docs
mod bar {
    /// the docs for Bar
    pub struct Bar;
}</code></pre>
<h3 id="no_inline"><a class="header" href="#no_inline"><code>no_inline</code></a></h3>
<p>ç”¨äºé˜²æ­¢é“¾æ¥åˆ°å•ç‹¬çš„é¡µé¢æˆ–å…¶å®ƒåœ°æ–¹ã€‚</p>
<pre><code class="language-rust ignore">// Example from libcore/prelude
#[doc(no_inline)]
pub use crate::mem::drop;</code></pre>
<h3 id="hidden"><a class="header" href="#hidden"><code>hidden</code></a></h3>
<p>é€šè¿‡è¿™ä¸ªå±æ€§è®© <code>rustdoc</code> ä¸è¦å°†ä¸‹é¢çš„é¡¹åŒ…å«åœ¨æ–‡æ¡£ä¸­:</p>
<pre><code class="language-rust editable ignore">// Example from the futures-rs library
#[doc(hidden)]
pub use self::async_await::*;</code></pre>
<p>å¯¹æ–‡æ¡£æ¥è¯´ï¼Œ<code>rustdoc</code> è¢«ç¤¾åŒºå¹¿æ³›é‡‡ç”¨ï¼Œå¤§å®¶æ‰€çœ‹åˆ°çš„<a href="https://doc.rust-lang.org/std/">æ ‡å‡†åº“æ–‡æ¡£</a>ä¹Ÿæ˜¯åŸºäºæ­¤ç”Ÿæˆçš„ã€‚</p>
<h3 id="å®Œæ•´çš„ä»£ç "><a class="header" href="#å®Œæ•´çš„ä»£ç ">å®Œæ•´çš„ä»£ç </a></h3>
<p><code>doc-comments</code> çš„å®Œæ•´ä»£ç å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/tree/master/practices/doc-comments">è¿™é‡Œæ‰¾åˆ°</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ ¼å¼åŒ–è¾“å‡º"><a class="header" href="#æ ¼å¼åŒ–è¾“å‡º">æ ¼å¼åŒ–è¾“å‡º</a></h1>
<h2 id="ä½ç½®å‚æ•°"><a class="header" href="#ä½ç½®å‚æ•°">ä½ç½®å‚æ•°</a></h2>
<p>1.ğŸŒŸğŸŒŸ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* å¡«ç©º */
fn main() {
    println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;Alice&quot;, &quot;Bob&quot;);// =&gt; Alice, this is Bob. Bob, this is Alice
    assert_eq!(format!(&quot;{1}{0}&quot;, 1, 2), __);
    assert_eq!(format!(__, 1, 2), &quot;2112&quot;);
    println!(&quot;Success!&quot;);
}</code></pre></pre>
<h2 id="å…·åå‚æ•°"><a class="header" href="#å…·åå‚æ•°">å…·åå‚æ•°</a></h2>
<p>2.ğŸŒŸğŸŒŸ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;{argument}&quot;, argument = &quot;test&quot;); // =&gt; &quot;test&quot;

    /* å¡«ç©º */
    assert_eq!(format!(&quot;{name}{}&quot;, 1, __), &quot;21&quot;);
    assert_eq!(format!(__,a = &quot;a&quot;, b = 'b', c = 3 ), &quot;a 3 b&quot;);
    
    /* ä¿®å¤é”™è¯¯ */
    // å…·åå‚æ•°å¿…é¡»æ”¾åœ¨å…¶å®ƒå‚æ•°åé¢
    println!(&quot;{abc} {1}&quot;, abc = &quot;def&quot;, 2);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h2 id="å­—ç¬¦ä¸²å¯¹é½"><a class="header" href="#å­—ç¬¦ä¸²å¯¹é½">å­—ç¬¦ä¸²å¯¹é½</a></h2>
<p>3.ğŸŒŸğŸŒŸ é»˜è®¤æƒ…å†µä¸‹ï¼Œé€šè¿‡ç©ºæ ¼æ¥å¡«å……å­—ç¬¦ä¸²</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // ä¸‹é¢ä¸¤ä¸ªéƒ½æ˜¯é€šè¿‡ 5 ä¸ªç©ºæ ¼æ¥å¡«å……
    println!(&quot;Hello {:5}!&quot;, &quot;x&quot;); // =&gt;  &quot;Hello x    !&quot;  
    println!(&quot;Hello {:1$}!&quot;, &quot;x&quot;, 5); // =&gt;  &quot;Hello x    !&quot;

    /* å¡«ç©º */
    assert_eq!(format!(&quot;Hello __!&quot;, 5, &quot;x&quot;), &quot;Hello x    !&quot;);
    assert_eq!(format!(&quot;Hello __!&quot;, &quot;x&quot;, width = 5), &quot;Hello x    !&quot;);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<p>4.ğŸŒŸğŸŒŸğŸŒŸ å·¦å¯¹é½, å³å¯¹é½, ä½¿ç”¨æŒ‡å®šçš„å­—ç¬¦å¡«å……</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // å·¦å¯¹é½
    println!(&quot;Hello {:&lt;5}!&quot;, &quot;x&quot;); // =&gt; Hello x    !
    // å³å¯¹é½
    assert_eq!(format!(&quot;Hello __!&quot;, &quot;x&quot;), &quot;Hello     x!&quot;);
    // å±…ä¸­å¯¹é½
    assert_eq!(format!(&quot;Hello __!&quot;, &quot;x&quot;), &quot;Hello   x  !&quot;);

    // å·¦å¯¹é½ï¼Œå¹¶ä½¿ç”¨ `&amp;` å¡«å……
    assert_eq!(format!(&quot;Hello {:&amp;&lt;5}!&quot;, &quot;x&quot;), __);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<p>5.ğŸŒŸğŸŒŸ æˆ‘ä»¬è¿˜èƒ½ä½¿ç”¨ 0 æ¥å¡«å……æ•°å­—</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;Hello {:5}!&quot;, 5); // =&gt; Hello     5!
    println!(&quot;Hello {:+}!&quot;, 5); // =&gt;  Hello +5!
    println!(&quot;Hello {:05}!&quot;, 5); // =&gt; Hello 00005!
    println!(&quot;Hello {:05}!&quot;, -5); // =&gt; Hello -0005!

    /* å¡«ç©º */
    assert!(format!(&quot;{number:0&gt;width$}&quot;, number=1, width=6) == __);
    
    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h2 id="ç²¾åº¦"><a class="header" href="#ç²¾åº¦">ç²¾åº¦</a></h2>
<p>6.ğŸŒŸğŸŒŸ æµ®ç‚¹æ•°ç²¾åº¦</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
/* å¡«ç©º */
fn main() {
    let v = 3.1415926;

    println!(&quot;{:.1$}&quot;, v, 4); // same as {:.4} =&gt; 3.1416 

    assert_eq!(format!(&quot;__&quot;, v), &quot;3.14&quot;);
    assert_eq!(format!(&quot;__&quot;, v), &quot;+3.14&quot;);
    assert_eq!(format!(&quot;__&quot;, v), &quot;3&quot;);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<p>7.ğŸŒŸğŸŒŸğŸŒŸ å­—ç¬¦ä¸²é•¿åº¦</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = &quot;Hello, world!&quot;;

    println!(&quot;{0:.5}&quot;, s); // =&gt; Hello

    assert_eq!(format!(&quot;Hello __!&quot;, 3, &quot;abcdefg&quot;), &quot;Hello abc!&quot;);

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h2 id="äºŒè¿›åˆ¶-å…«è¿›åˆ¶-åå…­è¿›åˆ¶"><a class="header" href="#äºŒè¿›åˆ¶-å…«è¿›åˆ¶-åå…­è¿›åˆ¶">äºŒè¿›åˆ¶, å…«è¿›åˆ¶, åå…­è¿›åˆ¶</a></h2>
<ul>
<li>format!(&quot;{}&quot;, foo) -&gt; &quot;3735928559&quot;</li>
<li>format!(&quot;0x{:X}&quot;, foo) -&gt; &quot;0xDEADBEEF&quot;</li>
<li>format!(&quot;0o{:o}&quot;, foo) -&gt; &quot;0o33653337357&quot;</li>
</ul>
<p>8.ğŸŒŸğŸŒŸ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(format!(&quot;__&quot;, 27), &quot;0b11011&quot;);
    assert_eq!(format!(&quot;__&quot;, 27), &quot;0o33&quot;);
    assert_eq!(format!(&quot;__&quot;, 27), &quot;0x1b&quot;);
    assert_eq!(format!(&quot;__&quot;, 27), &quot;0x1B&quot;);

    println!(&quot;{:x}!&quot;, 27); // æ²¡æœ‰å‰ç¼€çš„åå…­è¿›åˆ¶ =&gt; 1b

    println!(&quot;{:#010b}&quot;, 27); // ä½¿ç”¨ 0 æ¥å¡«å……äºŒè¿›åˆ¶ï¼Œå®½åº¦ä¸º 10 =&gt; 0b00011011

    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h2 id="æ•è·ç¯å¢ƒä¸­çš„å€¼"><a class="header" href="#æ•è·ç¯å¢ƒä¸­çš„å€¼">æ•è·ç¯å¢ƒä¸­çš„å€¼</a></h2>
<p>9.ğŸŒŸğŸŒŸğŸŒŸ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn get_person() -&gt; String {
    String::from(&quot;sunface&quot;)
}

fn get_format() -&gt; (usize, usize) {
    (4, 1)
}


fn main() {
    let person = get_person();
    println!(&quot;Hello, {person}!&quot;);

    let (width, precision) = get_format();
    let scores = [(&quot;sunface&quot;, 99.12), (&quot;jack&quot;, 60.34)];
    /* è®©ä¸‹é¢çš„ä»£ç è¾“å‡º:
    sunface: 99.1
    jack: 60.3
    */
    for (name, score) in scores {
        println!(&quot;{name}: __&quot;);
    }
}</code></pre></pre>
<h2 id="others"><a class="header" href="#others">Others</a></h2>
<p><strong>Example</strong></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // æŒ‡æ•°
    println!(&quot;{:2e}&quot;, 1000000000); // =&gt; 1e9
    println!(&quot;{:2E}&quot;, 1000000000); // =&gt; 1E9

    // æŒ‡é’ˆåœ°å€
    let v= vec![1, 2, 3];
    println!(&quot;{:p}&quot;, v.as_ptr()); // =&gt; 0x600002324050

    // è½¬ä¹‰
    println!(&quot;Hello {{}}&quot;); // =&gt; Hello {}
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç”Ÿå‘½å‘¨æœŸ"><a class="header" href="#ç”Ÿå‘½å‘¨æœŸ">ç”Ÿå‘½å‘¨æœŸ</a></h1>
<p>å­¦ä¹ èµ„æ–™: </p>
<ul>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/advance/lifetime/intro.html">Rustè¯­è¨€åœ£ç» - ç”Ÿå‘½å‘¨æœŸ</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç”Ÿå‘½å‘¨æœŸåŸºç¡€"><a class="header" href="#ç”Ÿå‘½å‘¨æœŸåŸºç¡€">ç”Ÿå‘½å‘¨æœŸåŸºç¡€</a></h2>
<p>ç¼–è¯‘å™¨é€šè¿‡ç”Ÿå‘½å‘¨æœŸæ¥ç¡®ä¿æ‰€æœ‰çš„å€Ÿç”¨éƒ½æ˜¯åˆæ³•çš„ï¼Œå…¸å‹çš„ï¼Œä¸€ä¸ªå˜é‡åœ¨åˆ›å»ºæ—¶ç”Ÿå‘½å‘¨æœŸéšä¹‹å¼€å§‹ï¼Œé”€æ¯æ—¶ç”Ÿå‘½å‘¨æœŸä¹Ÿéšä¹‹ç»“æŸã€‚</p>
<h2 id="ç”Ÿå‘½å‘¨æœŸçš„èŒƒå›´"><a class="header" href="#ç”Ÿå‘½å‘¨æœŸçš„èŒƒå›´">ç”Ÿå‘½å‘¨æœŸçš„èŒƒå›´</a></h2>
<ol>
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* ä¸º `i` å’Œ `borrow2` æ ‡æ³¨åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸèŒƒå›´ */


// `i` æ‹¥æœ‰æœ€é•¿çš„ç”Ÿå‘½å‘¨æœŸï¼Œå› ä¸ºå®ƒçš„ä½œç”¨åŸŸå®Œæ•´çš„åŒ…å«äº† `borrow1` å’Œ `borrow2` ã€‚
// è€Œ `borrow1` å’Œ `borrow2` çš„ç”Ÿå‘½å‘¨æœŸå¹¶æ— å…³è”ï¼Œå› ä¸ºå®ƒä»¬çš„ä½œç”¨åŸŸæ²¡æœ‰é‡å 
fn main() {
    let i = 3;                                             
    {                                                    
        let borrow1 = &amp;i; // `borrow1` ç”Ÿå‘½å‘¨æœŸå¼€å§‹. â”€â”€â”
        //                                                â”‚
        println!(&quot;borrow1: {}&quot;, borrow1); //              â”‚
    } // `borrow1` ç”Ÿå‘½å‘¨æœŸç»“æŸ. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    {                                                    
        let borrow2 = &amp;i; 
                                                        
        println!(&quot;borrow2: {}&quot;, borrow2);               
    }                                                   
}   </code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<p><strong>ç¤ºä¾‹</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* åƒä¸Šé¢çš„ç¤ºä¾‹ä¸€æ ·ï¼Œä¸º `r` å’Œ `x` æ ‡å‡†ç”Ÿå‘½å‘¨æœŸï¼Œç„¶åä»ç”Ÿå‘½å‘¨æœŸçš„è§’åº¦. */

fn main() {  
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
}</code></pre></pre>
<h2 id="ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨"><a class="header" href="#ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨">ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨</a></h2>
<p>Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨ä½¿ç”¨æ˜¾å¼çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨æ¥ç¡®å®šä¸€ä¸ªå¼•ç”¨çš„åˆæ³•èŒƒå›´ã€‚ä½†æ˜¯å¯¹äºç”¨æˆ·æ¥è¯´ï¼Œæˆ‘ä»¬åœ¨å¤§å¤šæ•°åœºæ™¯ä¸‹ï¼Œéƒ½æ— éœ€æ‰‹åŠ¨å»æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼ŒåŸå› æ˜¯ç¼–è¯‘å™¨ä¼šåœ¨æŸäº›æƒ…å†µä¸‹è‡ªåŠ¨åº”ç”¨ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™ã€‚</p>
<p>åœ¨äº†è§£ç¼–è¯‘å™¨ä½¿ç”¨å“ªäº›è§„åˆ™å¸®æˆ‘ä»¬æ¶ˆé™¤ç”Ÿå‘½å‘¨æœŸä¹‹å‰ï¼Œé¦–å…ˆè¿˜æ˜¯éœ€è¦çŸ¥é“è¯¥å¦‚ä½•æ‰‹åŠ¨æ ‡è®°ç”Ÿå‘½å‘¨æœŸã€‚</p>
<h4 id="å‡½æ•°-2"><a class="header" href="#å‡½æ•°-2">å‡½æ•°</a></h4>
<p><strong>å¤§å®¶å…ˆå¿½ç•¥ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™</strong>ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ï¼Œå‡½æ•°ç­¾åä¸­çš„ç”Ÿå‘½å‘¨æœŸæœ‰å“ªäº›é™åˆ¶:</p>
<ul>
<li>éœ€è¦ä¸ºæ¯ä¸ªå¼•ç”¨æ ‡æ³¨ä¸Šåˆé€‚çš„ç”Ÿå‘½å‘¨æœŸ</li>
<li>è¿”å›å€¼ä¸­çš„å¼•ç”¨ï¼Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸè¦ä¹ˆè·ŸæŸä¸ªå¼•ç”¨å‚æ•°ç›¸åŒï¼Œè¦ä¹ˆæ˜¯ <code>'static</code></li>
</ul>
<p><strong>ç¤ºä¾‹</strong></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// å¼•ç”¨å‚æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ 'a è‡³å°‘è¦è·Ÿå‡½æ•°æ´»å¾—ä¸€æ ·ä¹…
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`print_one`: x is {}&quot;, x);
}

// å¯å˜å¼•ç”¨ä¾ç„¶éœ€è¦æ ‡å‡†ç”Ÿå‘½å‘¨æœŸ
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// ä¸‹é¢ä»£ç ä¸­ï¼Œæ¯ä¸ªå‚æ•°éƒ½æ‹¥æœ‰è‡ªå·±ç‹¬ç«‹çš„ç”Ÿå‘½å‘¨æœŸï¼Œäº‹å®ä¸Šï¼Œè¿™ä¸ªä¾‹å­è¶³å¤Ÿç®€å•ï¼Œå› æ­¤å®ƒä»¬åº”è¯¥è¢«æ ‡è®°ä¸Šç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸ `'a`ï¼Œä½†æ˜¯å¯¹äºå¤æ‚çš„ä¾‹å­è€Œè¨€ï¼Œç‹¬ç«‹çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨æ˜¯å¯èƒ½å­˜åœ¨çš„
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;`print_multi`: x is {}, y is {}&quot;, x, y);
}

// è¿”å›ä¸€ä¸ªé€šè¿‡å‚æ•°ä¼ å…¥çš„å¼•ç”¨æ˜¯å¾ˆå¸¸è§çš„ï¼Œä½†æ˜¯è¿™ç§æƒ…å†µä¸‹éœ€è¦æ ‡æ³¨ä¸Šæ­£ç¡®çš„ç”Ÿå‘½å‘¨æœŸ
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 7;
    let y = 9;
    
    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);
    
    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* æ·»åŠ åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œè®©ä¸‹é¢çš„ä»£ç å·¥ä½œ */
fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {}</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* ä½¿ç”¨ä¸‰ç§æ–¹æ³•ä¿®å¤ä¸‹é¢çš„é”™è¯¯  */
fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String { 
    &amp;String::from(&quot;foo&quot;) 
}

fn main() {
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// `print_refs` æœ‰ä¸¤ä¸ªå¼•ç”¨å‚æ•°ï¼Œå®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸ `'a` å’Œ `'b` è‡³å°‘å¾—è·Ÿå‡½æ•°æ´»å¾—ä¸€æ ·ä¹…
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;x is {} and y is {}&quot;, x, y);
}

/* è®©ä¸‹é¢çš„ä»£ç å·¥ä½œ */
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // ERROR: `_x` æ´»å¾—ä¸å¤Ÿä¹…does not live long enough
    let y: &amp;'a i32 = &amp;_x;

    // åœ¨å‡½æ•°å†…ä½¿ç”¨ `'a` å°†ä¼šæŠ¥é”™ï¼ŒåŸå› æ˜¯ `&amp;_x` çš„ç”Ÿå‘½å‘¨æœŸæ˜¾ç„¶æ¯” `'a` è¦å°
    // ä½ ä¸èƒ½å°†ä¸€ä¸ªå°çš„ç”Ÿå‘½å‘¨æœŸå¼ºè½¬æˆå¤§çš„
}

fn main() {
    let (four, nine) = (4, 9);
    

    print_refs(&amp;four, &amp;nine);
    // è¿™é‡Œï¼Œfour å’Œ nice çš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»è¦æ¯”å‡½æ•° print_refs é•¿
    
    failed_borrow();
    // `failed_borrow`  æ²¡æœ‰ä¼ å…¥ä»»ä½•å¼•ç”¨å»é™åˆ¶ç”Ÿå‘½å‘¨æœŸ `'a`ï¼Œå› æ­¤ï¼Œæ­¤æ—¶çš„ `'a` ç”Ÿå‘½å‘¨æœŸæ˜¯æ²¡æœ‰ä»»ä½•é™åˆ¶çš„ï¼Œå®ƒé»˜è®¤æ˜¯ `'static`
}</code></pre></pre>
<h4 id="structs"><a class="header" href="#structs">Structs</a></h4>
<ol start="6">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* å¢åŠ åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸæ ‡å‡†ï¼Œè®©ä»£ç å·¥ä½œ */

// `i32` çš„å¼•ç”¨å¿…é¡»æ¯” `Borrowed` æ´»å¾—æ›´ä¹…
#[derive(Debug)]
struct Borrowed(&amp;i32);

// ç±»ä¼¼çš„ï¼Œä¸‹é¢ä¸¤ä¸ªå¼•ç”¨ä¹Ÿå¿…é¡»æ¯”ç»“æ„ä½“ `NamedBorrowed` æ´»å¾—æ›´ä¹…
#[derive(Debug)]
struct NamedBorrowed {
    x: &amp;i32,
    y: &amp;i32,
}

#[derive(Debug)]
enum Either {
    Num(i32),
    Ref(&amp;i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number    = Either::Num(y);

    println!(&quot;x is borrowed in {:?}&quot;, single);
    println!(&quot;x and y are borrowed in {:?}&quot;, double);
    println!(&quot;x is borrowed in {:?}&quot;, reference);
    println!(&quot;y is *not* borrowed in {:?}&quot;, number);
}</code></pre></pre>
<ol start="7">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* è®©ä»£ç å·¥ä½œ */

#[derive(Debug)]
struct NoCopyType {}

#[derive(Debug)]
struct Example&lt;'a, 'b&gt; {
    a: &amp;'a u32,
    b: &amp;'b NoCopyType
}

fn main()
{ 
  let var_a = 35;
  let example: Example;
  
  {
    let var_b = NoCopyType {};
    
    /* ä¿®å¤é”™è¯¯ */
    example = Example { a: &amp;var_a, b: &amp;var_b };
  }
  
  println!(&quot;(Success!) {:?}&quot;, example);
}</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
struct NoCopyType {}

#[derive(Debug)]
#[allow(dead_code)]
struct Example&lt;'a, 'b&gt; {
    a: &amp;'a u32,
    b: &amp;'b NoCopyType
}

/* ä¿®å¤å‡½æ•°çš„ç­¾å */
fn fix_me(foo: &amp;Example) -&gt; &amp;NoCopyType
{ foo.b }

fn main()
{
    let no_copy = NoCopyType {};
    let example = Example { a: &amp;1, b: &amp;no_copy };
    fix_me(&amp;example);
    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h2 id="æ–¹æ³•-1"><a class="header" href="#æ–¹æ³•-1">æ–¹æ³•</a></h2>
<p>æ–¹æ³•çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è·Ÿå‡½æ•°ç±»ä¼¼ã€‚</p>
<p><strong>ç¤ºä¾‹</strong></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Owner(i32);

impl Owner {
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!(&quot;`print`: {}&quot;, self.0);
    }
}

fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}</code></pre></pre>
<ol start="9">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* æ·»åŠ åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸè®©ä¸‹é¢ä»£ç å·¥ä½œ */
struct ImportantExcerpt {
    part: &amp;str,
}

impl ImportantExcerpt {
    fn level(&amp;'a self) -&gt; i32 {
        3
    }
}

fn main() {}</code></pre></pre>
<h2 id="ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤-elision-"><a class="header" href="#ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤-elision-">ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤( Elision )</a></h2>
<p>æœ‰ä¸€äº›ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨æ–¹å¼å¾ˆå¸¸è§ï¼Œå› æ­¤ç¼–è¯‘å™¨æä¾›äº†ä¸€äº›è§„åˆ™ï¼Œå¯ä»¥è®©æˆ‘ä»¬åœ¨ä¸€äº›åœºæ™¯ä¸‹æ— éœ€å»æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼Œæ—¢èŠ‚çœäº†æ•²å‡»é”®ç›˜çš„ç¹çï¼Œåˆèƒ½æå‡å¯è¯»æ€§ã€‚</p>
<p>è¿™ç§è§„åˆ™è¢«ç§°ä¸ºç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™( Elision )ï¼Œè¯¥è§„åˆ™ä¹‹æ‰€ä»¥å­˜åœ¨ï¼Œä»…ä»…æ˜¯å› ä¸ºè¿™äº›åœºæ™¯å¤ªé€šç”¨äº†ï¼Œä¸ºäº†æ–¹ä¾¿ç”¨æˆ·è€Œå·²ã€‚äº‹å®ä¸Šå¯¹äºå€Ÿç”¨æ£€æŸ¥å™¨è€Œè¨€ï¼Œè¯¥æœ‰çš„ç”Ÿå‘½å‘¨æœŸä¸€ä¸ªéƒ½ä¸èƒ½å°‘ï¼Œåªä¸è¿‡å¯¹äºç”¨æˆ·è€Œè¨€ï¼Œå¯ä»¥çœå»ä¸€äº›ã€‚</p>
<ol start="10">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* ç§»é™¤æ‰€æœ‰å¯ä»¥æ¶ˆé™¤çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ */

fn nput&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`annotated_input`: {}&quot;, x);
}

fn pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
    x
}

struct Owner(i32);

impl Owner {
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!(&quot;`print`: {}&quot;, self.0);
    }
}

struct Person&lt;'a&gt; {
    age: u8,
    name: &amp;'a str,
}

enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/lifetime/basic.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-and-t-static"><a class="header" href="#static-and-t-static">&amp;'static and T: 'static</a></h1>
<p><code>'static</code> æ˜¯ä¸€ä¸ª Rust ä¿ç•™çš„ç”Ÿå‘½å‘¨æœŸåç§°ï¼Œåœ¨ä¹‹å‰æˆ‘ä»¬å¯èƒ½å·²ç»è§è¿‡å¥½å‡ æ¬¡äº†:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ 'static :
let s: &amp;'static str = &quot;hello world&quot;;

// 'static ä¹Ÿå¯ä»¥ç”¨äºç‰¹å¾çº¦æŸä¸­:
fn generic&lt;T&gt;(x: T) where T: 'static {}
<span class="boring">}</span></code></pre></pre>
<p>è™½ç„¶å®ƒä»¬éƒ½æ˜¯ <code>'static</code>ï¼Œä½†æ˜¯ä¹Ÿç¨æœ‰ä¸åŒã€‚</p>
<h2 id="static"><a class="header" href="#static">&amp;'static</a></h2>
<p>ä½œä¸ºä¸€ä¸ªå¼•ç”¨ç”Ÿå‘½å‘¨æœŸï¼Œ<code>&amp;'static</code> è¯´æ˜è¯¥å¼•ç”¨æŒ‡å‘çš„æ•°æ®å¯ä»¥è·Ÿç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ï¼Œä½†æ˜¯è¯¥å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¾ç„¶æœ‰å¯èƒ½è¢«å¼ºè½¬ä¸ºä¸€ä¸ªæ›´çŸ­çš„ç”Ÿå‘½å‘¨æœŸã€‚</p>
<ol>
<li>ğŸŒŸğŸŒŸ æœ‰å¥½å‡ ç§æ–¹æ³•å¯ä»¥å°†ä¸€ä¸ªå˜é‡æ ‡è®°ä¸º  <code>'static</code> ç”Ÿå‘½å‘¨æœŸ, å…¶ä¸­ä¸¤ç§éƒ½æ˜¯å’Œä¿å­˜åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ç›¸å…³( ä¾‹å¦‚å­—ç¬¦ä¸²å­—é¢é‡å°±æ˜¯ä¿å­˜åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸæ˜¯ <code>'static</code> )ã€‚</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
/* ä½¿ç”¨ä¸¤ç§æ–¹æ³•å¡«ç©º */
fn main() {
    __;
    need_static(v);

    println!(&quot;Success!&quot;)
}

fn need_static(r : &amp;'static str) {
    assert_eq!(r, &quot;hello&quot;);
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ ä½¿ç”¨ <code>Box::leak</code> ä¹Ÿå¯ä»¥äº§ç”Ÿ <code>'static</code> ç”Ÿå‘½å‘¨æœŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut config: Option&lt;&amp;mut Config&gt; = None;

/* è®©ä»£ç å·¥ä½œï¼Œä½†ä¸è¦ä¿®æ”¹å‡½æ•°çš„ç­¾å */
fn init() -&gt; Option&lt;&amp;'static mut Config&gt; {
    Some(&amp;mut Config {
        a: &quot;A&quot;.to_string(),
        b: &quot;B&quot;.to_string(),
    })
}


fn main() {
    unsafe {
        config = init();

        println!(&quot;{:?}&quot;,config)
    }
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ <code>&amp;'static</code> åªèƒ½è¯´æ˜å¼•ç”¨æŒ‡å‘çš„æ•°æ®æ˜¯èƒ½ä¸€ç›´å­˜æ´»çš„ï¼Œä½†æ˜¯å¼•ç”¨æœ¬èº«ä¾ç„¶å—é™äºå®ƒçš„ä½œç”¨åŸŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    {
        // å­—ç¬¦ä¸²å­—é¢é‡èƒ½è·Ÿç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ï¼Œå› æ­¤ `static_string` çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ `'static`
        let static_string = &quot;I'm in read-only memory&quot;;
        println!(&quot;static_string: {}&quot;, static_string);

        // å½“ `static_string` è¶…å‡ºä½œç”¨åŸŸæ—¶ï¼Œè¯¥å¼•ç”¨å°±æ— æ³•å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯å¼•ç”¨æŒ‡å‘çš„æ•°æ®( å­—ç¬¦ä¸²å­—é¢é‡ ) ä¾ç„¶ä¿å­˜åœ¨äºŒè¿›åˆ¶ binary æ‰€å ç”¨çš„å†…å­˜ä¸­
    }

    println!(&quot;static_string reference remains alive: {}&quot;, static_string);
}</code></pre></pre>
<ol start="4">
<li><code>&amp;'static</code> å¯ä»¥è¢«å¼ºè½¬æˆä¸€ä¸ªè¾ƒçŸ­çš„ç”Ÿå‘½å‘¨æœŸ</li>
</ol>
<p><strong>Example</strong></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// å£°æ˜ä¸€ä¸ª static å¸¸é‡ï¼Œå®ƒæ‹¥æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸ.
static NUM: i32 = 18;

// è¿”å›å¸¸é‡ `Num` çš„å¼•ç”¨ï¼Œæ³¨æ„ï¼Œè¿™é‡Œçš„ç”Ÿå‘½å‘¨æœŸä» `'static` å¼ºè½¬ä¸º `'a`
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        let lifetime_num = 9;

        let coerced_static = coerce_static(&amp;lifetime_num);

        println!(&quot;coerced_static: {}&quot;, coerced_static);
    }

    println!(&quot;NUM: {} stays accessible!&quot;, NUM);
}</code></pre></pre>
<h2 id="t-static"><a class="header" href="#t-static">T: 'static</a></h2>
<p>å…³äº <code>'static</code> çš„ç‰¹å¾çº¦æŸè¯¦ç»†è§£é‡Šï¼Œè¯·å‚è§ <a href="https://course.rs/advance/lifetime/static.html#t-static">Rust è¯­è¨€åœ£ç»</a>ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚</p>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* è®©ä»£ç å·¥ä½œ */
use std::fmt::Debug;

fn print_it&lt;T: Debug + 'static&gt;( input: T) {
    println!( &quot;'static value passed in is: {:?}&quot;, input );
}

fn print_it1( input: impl Debug + 'static ) {
    println!( &quot;'static value passed in is: {:?}&quot;, input );
}


fn print_it2&lt;T: Debug + 'static&gt;( input: &amp;T) {
    println!( &quot;'static value passed in is: {:?}&quot;, input );
}

fn main() {
    // i æ˜¯æœ‰æ‰€æœ‰æƒçš„æ•°æ®ï¼Œå¹¶æ²¡æœ‰åŒ…å«ä»»ä½•å¼•ç”¨ï¼Œå› æ­¤å®ƒæ˜¯ 'static
    let i = 5;
    print_it(i);

    // ä½†æ˜¯ &amp;i æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œç”Ÿå‘½å‘¨æœŸå—é™äºä½œç”¨åŸŸï¼Œå› æ­¤å®ƒä¸æ˜¯ 'static
    print_it(&amp;i);

    print_it1(&amp;i);

    // ä½†æ˜¯ä¸‹é¢çš„ä»£ç å¯ä»¥æ­£å¸¸è¿è¡Œ !
    print_it2(&amp;i);
}</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

fn main() {
  let mut string = &quot;First&quot;.to_owned();

  string.push_str(string.to_uppercase().as_str());
  print_a(&amp;string);
  print_b(&amp;string);
  print_c(&amp;string); // Compilation error
  print_d(&amp;string); // Compilation error
  print_e(&amp;string);
  print_f(&amp;string);
  print_g(&amp;string); // Compilation error
}

fn print_a&lt;T: Display + 'static&gt;(t: &amp;T) {
  println!(&quot;{}&quot;, t);
}

fn print_b&lt;T&gt;(t: &amp;T)
where
  T: Display + 'static,
{
  println!(&quot;{}&quot;, t);
}

fn print_c(t: &amp;'static dyn Display) {
  println!(&quot;{}&quot;, t)
}

fn print_d(t: &amp;'static impl Display) {
  println!(&quot;{}&quot;, t)
}

fn print_e(t: &amp;(dyn Display + 'static)) {
  println!(&quot;{}&quot;, t)
}

fn print_f(t: &amp;(impl Display + 'static)) {
  println!(&quot;{}&quot;, t)
}

fn print_g(t: &amp;'static String) {
  println!(&quot;{}&quot;, t);
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/lifetime/static.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ·±å…¥ç”Ÿå‘½å‘¨æœŸ"><a class="header" href="#æ·±å…¥ç”Ÿå‘½å‘¨æœŸ">æ·±å…¥ç”Ÿå‘½å‘¨æœŸ</a></h1>
<h2 id="ç‰¹å¾çº¦æŸ-1"><a class="header" href="#ç‰¹å¾çº¦æŸ-1">ç‰¹å¾çº¦æŸ</a></h2>
<p>å°±åƒæ³›å‹ç±»å‹å¯ä»¥æœ‰çº¦æŸä¸€æ ·ï¼Œç”Ÿå‘½å‘¨æœŸä¹Ÿå¯ä»¥æœ‰çº¦æŸ ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<ul>
<li><code>T: 'a</code>ï¼Œæ‰€æœ‰å¼•ç”¨åœ¨ <code>T</code> å¿…é¡»è¶…è¿‡ç”Ÿå‘½å‘¨æœŸ <code>'a</code></li>
<li><code>T: Trait + 'a</code>: <code>T</code> å¿…é¡»å®ç°ç‰¹å¾ <code>Trait</code> å¹¶ä¸”æ‰€æœ‰å¼•ç”¨åœ¨ <code>T</code> å¿…é¡»è¶…è¿‡ç”Ÿå‘½å‘¨æœŸ <code>'a</code></li>
</ul>
<p><strong>ç¤ºä¾‹</strong></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Debug; // ç‰¹å¾çº¦æŸä½¿ç”¨

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref` åŒ…å«å¯¹æ³›å‹ç±»å‹ `T` çš„å¼•ç”¨ï¼Œè¯¥æ³›å‹ç±»å‹å…·æœ‰
// æœªçŸ¥çš„ç”Ÿå‘½å‘¨æœŸ `'a`. `T` æ˜¯çº¦å®šä»»ä½•
// å¼•ç”¨åœ¨ `T` å¿…é¡»å¤§äº `'a` ã€‚æ­¤å¤–ï¼Œåœ¨ç”Ÿå‘½å‘¨æœŸ
// é‡Œ `Ref` ä¸èƒ½è¶…è¿‡ `'a`ã€‚

// ä½¿ç”¨ `Debug` ç‰¹å¾æ‰“å°çš„é€šç”¨å‡½æ•°ã€‚
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!(&quot;`print`: t is {:?}&quot;, t);
}

// è¿™é‡Œå¼•ç”¨ `T` ä½¿ç”¨ where `T` å®ç°
// `Debug` å’Œæ‰€æœ‰å¼•ç”¨ `T` éƒ½è¦æ¯” `'a` é•¿
// æ­¤å¤–ï¼Œ`'a`å¿…é¡»è¦æ¯”å‡½æ•°å£°æ˜å‘¨æœŸé•¿
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!(&quot;`print_ref`: t is {:?}&quot;, t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}</code></pre></pre>
<ol>
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šç»“æ„ä½“
1. `r` å’Œ `s` å¿…é¡»æ˜¯ä¸åŒç”Ÿå‘½å‘¨æœŸ
2. `s` çš„ç”Ÿå‘½å‘¨æœŸéœ€è¦å¤§äº 'r'
*/
struct DoubleRef&lt;T&gt; {
    r: &amp;T,
    s: &amp;T
}
fn main() {
    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* æ·»åŠ ç±»å‹çº¦æŸä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œ */
struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

impl&lt;'a, 'b&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;'a self, announcement: &amp;'b str) -&gt; &amp;'b str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}

fn main() {
    println!(&quot;Success!&quot;)
}</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* æ·»åŠ ç±»å‹çº¦æŸä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œ */
fn f&lt;'a, 'b&gt;(x: &amp;'a i32, mut y: &amp;'b i32) {
    y = x;                      
    let r: &amp;'b &amp;'a i32 = &amp;&amp;0;   
}

fn main() {
    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h2 id="hrtbæ›´é«˜ç­‰çº§ç‰¹å¾çº¦æŸhigher-ranked-trait-bounds"><a class="header" href="#hrtbæ›´é«˜ç­‰çº§ç‰¹å¾çº¦æŸhigher-ranked-trait-bounds">HRTBï¼ˆæ›´é«˜ç­‰çº§ç‰¹å¾çº¦æŸï¼‰(Higher-ranked trait bounds)</a></h2>
<p>ç±»å‹çº¦æŸå¯èƒ½åœ¨ç”Ÿå‘½å‘¨æœŸä¸­æ’åæ›´é«˜ã€‚è¿™äº›çº¦æŸæŒ‡å®šäº†ä¸€ä¸ªçº¦æŸå¯¹äºæ‰€æœ‰ç”Ÿå‘½å‘¨æœŸéƒ½ä¸ºçœŸã€‚ä¾‹å¦‚ï¼Œè¯¸å¦‚æ­¤ç±»çš„çº¦æŸ <code>for&lt;'a&gt; &amp;'a T: PartialEq&lt;i32&gt;</code> éœ€è¦å¦‚ä¸‹å®ç°ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; PartialEq&lt;i32&gt; for &amp;'a T {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>ç„¶åå¯ä»¥ç”¨äºå°†ä¸€ä¸ª <code>&amp;'a T</code> ä¸ä»»ä½•ç”Ÿå‘½å‘¨æœŸè¿›è¡Œæ¯”è¾ƒ <code>i32</code> ã€‚</p>
<p>è¿™é‡Œåªèƒ½ä½¿ç”¨æ›´é«˜çº§åˆ«çš„çº¦æŸï¼Œå› ä¸ºå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸæ¯”å‡½æ•°ä¸Šä»»ä½•å¯èƒ½çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°éƒ½çŸ­ã€‚</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">/* æ·»åŠ  HRTB ä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œï¼ */
fn call_on_ref_zero&lt;'a, F&gt;(f: F) where F: Fn(&amp;'a i32) {
    let zero = 0;
    f(&amp;zero);
}

fn main() {
    println!(&quot;Success!&quot;)
}</code></pre></pre>
<h2 id="nlléè¯æ±‡ç”Ÿå‘½å‘¨æœŸnon-lexical-lifetime"><a class="header" href="#nlléè¯æ±‡ç”Ÿå‘½å‘¨æœŸnon-lexical-lifetime">NLLï¼ˆéè¯æ±‡ç”Ÿå‘½å‘¨æœŸï¼‰(Non-Lexical Lifetime)</a></h2>
<p>åœ¨è§£é‡Š NLL ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸€æ®µä»£ç ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s;
    let r2 = &amp;s;
    println!(&quot;{} and {}&quot;, r1, r2);

    let r3 = &amp;mut s;
    println!(&quot;{}&quot;, r3);
}</code></pre></pre>
<p>æ ¹æ®æˆ‘ä»¬ç›®å‰çš„çŸ¥è¯†ï¼Œè¿™æ®µä»£ç ä¼šå› ä¸ºè¿å Rust ä¸­çš„å€Ÿç”¨è§„åˆ™è€Œå¯¼è‡´é”™è¯¯ã€‚</p>
<p>ä½†æ˜¯ï¼Œå¦‚æœæ‚¨æ‰§è¡Œ <code>cargo run</code> ï¼Œé‚£ä¹ˆä¸€åˆ‡éƒ½æ²¡é—®é¢˜ï¼Œé‚£ä¹ˆè¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ</p>
<p>ç¼–è¯‘å™¨åœ¨ä½œç”¨åŸŸç»“æŸä¹‹å‰åˆ¤æ–­ä¸å†ä½¿ç”¨å¼•ç”¨çš„èƒ½åŠ›ç§°ä¸º <strong>éè¯æ³•ç”Ÿå‘½å‘¨æœŸ</strong>ï¼ˆç®€ç§° <strong>NLL</strong> ï¼‰ã€‚</p>
<p>æœ‰äº†è¿™ç§èƒ½åŠ›ï¼Œç¼–è¯‘å™¨å°±çŸ¥é“æœ€åä¸€æ¬¡ä½¿ç”¨å¼•ç”¨æ˜¯ä»€ä¹ˆæ—¶å€™ï¼Œå¹¶æ ¹æ®è¿™äº›çŸ¥è¯†ä¼˜åŒ–å€Ÿç”¨è§„åˆ™ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut u = 0i32;
let mut v = 1i32;
let mut w = 2i32;

// lifetime of `a` = Î± âˆª Î² âˆª Î³
let mut a = &amp;mut u;     // --+ Î±. lifetime of `&amp;mut u`  --+ lexical &quot;lifetime&quot; of `&amp;mut u`,`&amp;mut u`, `&amp;mut w` and `a`
use(a);                 //   |                            |
*a = 3; // &lt;-----------------+                            |
...                     //                                |
a = &amp;mut v;             // --+ Î². lifetime of `&amp;mut v`    |
use(a);                 //   |                            |
*a = 4; // &lt;-----------------+                            |
...                     //                                |
a = &amp;mut w;             // --+ Î³. lifetime of `&amp;mut w`    |
use(a);                 //   |                            |
*a = 5; // &lt;-----------------+ &lt;--------------------------+
<span class="boring">}</span></code></pre></pre>
<h2 id="å†å€Ÿç”¨"><a class="header" href="#å†å€Ÿç”¨">å†å€Ÿç”¨</a></h2>
<p>å­¦ä¹ äº† NLL ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å¾ˆå®¹æ˜“åœ°ç†è§£å†å€Ÿç”¨äº†ã€‚</p>
<p><strong>ç¤ºä¾‹</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn move_to(&amp;mut self, x: i32, y: i32) {
        self.x = x;
        self.y = y;
    }
}

fn main() {
    let mut p = Point { x: 0, y: 0 };
    let r = &amp;mut p;
    // è¿™é‡Œæ˜¯å†å€Ÿç”¨
    let rr: &amp;Point = &amp;*r;

    println!(&quot;{:?}&quot;, rr); // è¿™é‡Œç»“æŸå†å€Ÿç”¨

    // å†å€Ÿç”¨ç»“æŸï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥ç»§ç»­ä½¿ç”¨ `r`
    r.move_to(10, 10);
    println!(&quot;{:?}&quot;, r);
}</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* é€šè¿‡é‡æ–°æ’åºä¸€äº›ä»£ç ä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œ */
fn main() {
    let mut data = 10;
    let ref1 = &amp;mut data;
    let ref2 = &amp;mut *ref1;

    *ref1 += 1;
    *ref2 += 2;

    println!(&quot;{}&quot;, data);
}</code></pre></pre>
<h2 id="æœªçº¦æŸçš„ç”Ÿå‘½å‘¨æœŸ"><a class="header" href="#æœªçº¦æŸçš„ç”Ÿå‘½å‘¨æœŸ">æœªçº¦æŸçš„ç”Ÿå‘½å‘¨æœŸ</a></h2>
<p>åœ¨ <a href="https://doc.rust-lang.org/nomicon/unbounded-lifetimes.html">Nomicon - Unbounded Lifetimes</a> ä¸­æŸ¥çœ‹æ›´å¤šä¿¡æ¯ã€‚</p>
<h2 id="æ›´å¤šçœç•¥è§„åˆ™"><a class="header" href="#æ›´å¤šçœç•¥è§„åˆ™">æ›´å¤šçœç•¥è§„åˆ™</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Reader for BufReader&lt;'a&gt; {
    // 'a åœ¨ä»¥ä¸‹æ–¹æ³•ä¸­ä¸ä½¿ç”¨
}

// å¯ä»¥å†™ä¸ºï¼š
impl Reader for BufReader&lt;'_&gt; {
    
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 2015
struct Ref&lt;'a, T: 'a&gt; {
    field: &amp;'a T
}

// Rust 2018
struct Ref&lt;'a, T&gt; {
    field: &amp;'a T
}
<span class="boring">}</span></code></pre></pre>
<h2 id="è‰°éš¾çš„ç»ƒä¹ "><a class="header" href="#è‰°éš¾çš„ç»ƒä¹ ">è‰°éš¾çš„ç»ƒä¹ </a></h2>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">/* ä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œ */
struct Interface&lt;'a&gt; {
    manager: &amp;'a mut Manager&lt;'a&gt;
}

impl&lt;'a&gt; Interface&lt;'a&gt; {
    pub fn noop(self) {
        println!(&quot;interface consumed&quot;);
    }
}

struct Manager&lt;'a&gt; {
    text: &amp;'a str
}

struct List&lt;'a&gt; {
    manager: Manager&lt;'a&gt;,
}

impl&lt;'a&gt; List&lt;'a&gt; {
    pub fn get_interface(&amp;'a mut self) -&gt; Interface {
        Interface {
            manager: &amp;mut self.manager
        }
    }
}

fn main() {
    let mut list = List {
        manager: Manager {
            text: &quot;hello&quot;
        }
    };

    list.get_interface().noop();

    println!(&quot;Interface should be dropped here and the borrow released&quot;);

    use_list(&amp;list);
}

fn use_list(list: &amp;List) {
    println!(&quot;{}&quot;, list.manager.text);
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/lifetime/advance.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-programing"><a class="header" href="#functional-programing">Functional programing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closure"><a class="header" href="#closure">Closure</a></h1>
<p>ä¸‹é¢ä»£ç æ˜¯Ruståœ£ç»è¯¾ç¨‹ä¸­<a href="http://course.rs/advance/functional-programing/closure.html#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85">é—­åŒ…</a>ç« èŠ‚çš„è¯¾å†…ç»ƒä¹ é¢˜ç­”æ¡ˆï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Cacher&lt;T,E&gt;
where
    T: Fn(E) -&gt; E,
    E: Copy
{
    query: T,
    value: Option&lt;E&gt;,
}

impl&lt;T,E&gt; Cacher&lt;T,E&gt;
where
    T: Fn(E) -&gt; E,
    E: Copy
{
    fn new(query: T) -&gt; Cacher&lt;T,E&gt; {
        Cacher {
            query,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: E) -&gt; E {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.query)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
fn main() {
  
}

#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 1);
}</code></pre></pre>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/functional-programing/closure.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<blockquote>
<p>ä½ å¯ä»¥åœ¨<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/functional-programing/iterator.md">è¿™é‡Œ</a>æ‰¾åˆ°ç­”æ¡ˆ(åœ¨ solutions è·¯å¾„ä¸‹)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="newtype-and-sized"><a class="header" href="#newtype-and-sized">newtype and Sized</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart pointers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box">Box</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref"><a class="header" href="#deref">Deref</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop"><a class="header" href="#drop">Drop</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rc-and-arc"><a class="header" href="#rc-and-arc">Rc and Arc</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cell-and-refcell"><a class="header" href="#cell-and-refcell">Cell and RefCell</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weak-and-circle-reference"><a class="header" href="#weak-and-circle-reference">Weak and Circle reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-referential"><a class="header" href="#self-referential">Self referential</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-using"><a class="header" href="#basic-using">Basic using</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-passing"><a class="header" href="#message-passing">Message passing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync"><a class="header" href="#sync">Sync</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic"><a class="header" href="#atomic">Atomic</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-and-sync"><a class="header" href="#send-and-sync">Send and Sync</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-variables"><a class="header" href="#global-variables">Global variables</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-doing"><a class="header" href="#unsafe-doing">Unsafe doing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å†…è”æ±‡ç¼–"><a class="header" href="#å†…è”æ±‡ç¼–">å†…è”æ±‡ç¼–</a></h1>
<p>Rust provides support for inline assembly via the <code>asm!</code> macro.
It can be used to embed handwritten assembly in the assembly output generated by the compiler.
Generally this should not be necessary, but might be where the required performance or timing
cannot be otherwise achieved. Accessing low level hardware primitives, e.g. in kernel code, may also demand this functionality.</p>
<blockquote>
<p><strong>Note</strong>: the examples here are given in x86/x86-64 assembly, but other architectures are also supported.</p>
</blockquote>
<p>Inline assembly is currently supported on the following architectures:</p>
<ul>
<li>x86 and x86-64</li>
<li>ARM</li>
<li>AArch64</li>
<li>RISC-V</li>
</ul>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h2>
<p>Let us start with the simplest possible example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

unsafe {
    asm!(&quot;nop&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>This will insert a NOP (no operation) instruction into the assembly generated by the compiler.
Note that all <code>asm!</code> invocations have to be inside an <code>unsafe</code> block, as they could insert
arbitrary instructions and break various invariants. The instructions to be inserted are listed
in the first argument of the <code>asm!</code> macro as a string literal.</p>
<h2 id="inputs-and-outputs"><a class="header" href="#inputs-and-outputs">Inputs and outputs</a></h2>
<p>Now inserting an instruction that does nothing is rather boring. Let us do something that
actually acts on data:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let x: u64;
unsafe {
    asm!(&quot;mov {}, 5&quot;, out(reg) x);
}
assert_eq!(x, 5);
<span class="boring">}</span></code></pre></pre>
<p>This will write the value <code>5</code> into the <code>u64</code> variable <code>x</code>.
You can see that the string literal we use to specify instructions is actually a template string.
It is governed by the same rules as Rust <a href="https://doc.rust-lang.org/std/fmt/#syntax">format strings</a>.
The arguments that are inserted into the template however look a bit different than you may
be familiar with. First we need to specify if the variable is an input or an output of the
inline assembly. In this case it is an output. We declared this by writing <code>out</code>.
We also need to specify in what kind of register the assembly expects the variable.
In this case we put it in an arbitrary general purpose register by specifying <code>reg</code>.
The compiler will choose an appropriate register to insert into
the template and will read the variable from there after the inline assembly finishes executing.</p>
<p>Let us see another example that also uses an input:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let i: u64 = 3;
let o: u64;
unsafe {
    asm!(
        &quot;mov {0}, {1}&quot;,
        &quot;add {0}, 5&quot;,
        out(reg) o,
        in(reg) i,
    );
}
assert_eq!(o, 8);
<span class="boring">}</span></code></pre></pre>
<p>This will add <code>5</code> to the input in variable <code>i</code> and write the result to variable <code>o</code>.
The particular way this assembly does this is first copying the value from <code>i</code> to the output,
and then adding <code>5</code> to it.</p>
<p>The example shows a few things:</p>
<p>First, we can see that <code>asm!</code> allows multiple template string arguments; each
one is treated as a separate line of assembly code, as if they were all joined
together with newlines between them. This makes it easy to format assembly
code.</p>
<p>Second, we can see that inputs are declared by writing <code>in</code> instead of <code>out</code>.</p>
<p>Third, we can see that we can specify an argument number, or name as in any format string.
For inline assembly templates this is particularly useful as arguments are often used more than once.
For more complex inline assembly using this facility is generally recommended, as it improves
readability, and allows reordering instructions without changing the argument order.</p>
<p>We can further refine the above example to avoid the <code>mov</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut x: u64 = 3;
unsafe {
    asm!(&quot;add {0}, 5&quot;, inout(reg) x);
}
assert_eq!(x, 8);
<span class="boring">}</span></code></pre></pre>
<p>We can see that <code>inout</code> is used to specify an argument that is both input and output.
This is different from specifying an input and output separately in that it is guaranteed to assign both to the same register.</p>
<p>It is also possible to specify different variables for the input and output parts of an <code>inout</code> operand:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let x: u64 = 3;
let y: u64;
unsafe {
    asm!(&quot;add {0}, 5&quot;, inout(reg) x =&gt; y);
}
assert_eq!(y, 8);
<span class="boring">}</span></code></pre></pre>
<h2 id="late-output-operands"><a class="header" href="#late-output-operands">Late output operands</a></h2>
<p>The Rust compiler is conservative with its allocation of operands. It is assumed that an <code>out</code>
can be written at any time, and can therefore not share its location with any other argument.
However, to guarantee optimal performance it is important to use as few registers as possible,
so they won't have to be saved and reloaded around the inline assembly block.
To achieve this Rust provides a <code>lateout</code> specifier. This can be used on any output that is
written only after all inputs have been consumed.
There is also a <code>inlateout</code> variant of this specifier.</p>
<p>Here is an example where <code>inlateout</code> <em>cannot</em> be used:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
let c: u64 = 4;
unsafe {
    asm!(
        &quot;add {0}, {1}&quot;,
        &quot;add {0}, {2}&quot;,
        inout(reg) a,
        in(reg) b,
        in(reg) c,
    );
}
assert_eq!(a, 12);
<span class="boring">}</span></code></pre></pre>
<p>Here the compiler is free to allocate the same register for inputs <code>b</code> and <code>c</code> since it knows they have the same value. However it must allocate a separate register for <code>a</code> since it uses <code>inout</code> and not <code>inlateout</code>. If <code>inlateout</code> was used, then <code>a</code> and <code>c</code> could be allocated to the same register, in which case the first instruction to overwrite the value of <code>c</code> and cause the assembly code to produce the wrong result.</p>
<p>However the following example can use <code>inlateout</code> since the output is only modified after all input registers have been read:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!(&quot;add {0}, {1}&quot;, inlateout(reg) a, in(reg) b);
}
assert_eq!(a, 8);
<span class="boring">}</span></code></pre></pre>
<p>As you can see, this assembly fragment will still work correctly if <code>a</code> and <code>b</code> are assigned to the same register.</p>
<h2 id="explicit-register-operands"><a class="header" href="#explicit-register-operands">Explicit register operands</a></h2>
<p>Some instructions require that the operands be in a specific register.
Therefore, Rust inline assembly provides some more specific constraint specifiers.
While <code>reg</code> is generally available on any architecture, explicit registers are highly architecture specific. E.g. for x86 the general purpose registers <code>eax</code>, <code>ebx</code>, <code>ecx</code>, <code>edx</code>, <code>ebp</code>, <code>esi</code>, and <code>edi</code> among others can be addressed by their name.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let cmd = 0xd1;
unsafe {
    asm!(&quot;out 0x64, eax&quot;, in(&quot;eax&quot;) cmd);
}
<span class="boring">}</span></code></pre></pre>
<p>In this example we call the <code>out</code> instruction to output the content of the <code>cmd</code> variable to port <code>0x64</code>. Since the <code>out</code> instruction only accepts <code>eax</code> (and its sub registers) as operand we had to use the <code>eax</code> constraint specifier.</p>
<blockquote>
<p><strong>Note</strong>: unlike other operand types, explicit register operands cannot be used in the template string: you can't use <code>{}</code> and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.</p>
</blockquote>
<p>Consider this example which uses the x86 <code>mul</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

fn mul(a: u64, b: u64) -&gt; u128 {
    let lo: u64;
    let hi: u64;

    unsafe {
        asm!(
            // The x86 mul instruction takes rax as an implicit input and writes
            // the 128-bit result of the multiplication to rax:rdx.
            &quot;mul {}&quot;,
            in(reg) a,
            inlateout(&quot;rax&quot;) b =&gt; lo,
            lateout(&quot;rdx&quot;) hi
        );
    }

    ((hi as u128) &lt;&lt; 64) + lo as u128
}
<span class="boring">}</span></code></pre></pre>
<p>This uses the <code>mul</code> instruction to multiply two 64-bit inputs with a 128-bit result.
The only explicit operand is a register, that we fill from the variable <code>a</code>.
The second operand is implicit, and must be the <code>rax</code> register, which we fill from the variable <code>b</code>.
The lower 64 bits of the result are stored in <code>rax</code> from which we fill the variable <code>lo</code>.
The higher 64 bits are stored in <code>rdx</code> from which we fill the variable <code>hi</code>.</p>
<h2 id="clobbered-registers"><a class="header" href="#clobbered-registers">Clobbered registers</a></h2>
<p>In many cases inline assembly will modify state that is not needed as an output.
Usually this is either because we have to use a scratch register in the assembly or because instructions modify state that we don't need to further examine.
This state is generally referred to as being &quot;clobbered&quot;.
We need to tell the compiler about this since it may need to save and restore this state around the inline assembly block.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use core::arch::asm;

fn main() {
    // three entries of four bytes each
    let mut name_buf = [0_u8; 12];
    // String is stored as ascii in ebx, edx, ecx in order
    // Because ebx is reserved, we get a scratch register and move from
    // ebx into it in the asm.  The asm needs to preserve the value of
    // that register though, so it is pushed and popped around the main asm
    // (in 64 bit mode for 64 bit processors, 32 bit processors would use ebx)

    unsafe {
        asm!(
            &quot;push rbx&quot;,
            &quot;cpuid&quot;,
            &quot;mov [{0}], ebx&quot;,
            &quot;mov [{0} + 4], edx&quot;,
            &quot;mov [{0} + 8], ecx&quot;,
            &quot;pop rbx&quot;,
            // We use a pointer to an array for storing the values to simplify
            // the Rust code at the cost of a couple more asm instructions
            // This is more explicit with how the asm works however, as opposed
            // to explicit register outputs such as `out(&quot;ecx&quot;) val`
            // The *pointer itself* is only an input even though it's written behind
            in(reg) name_buf.as_mut_ptr(),
            // select cpuid 0, also specify eax as clobbered
            inout(&quot;eax&quot;) 0 =&gt; _,
            // cpuid clobbers these registers too
            out(&quot;ecx&quot;) _,
            out(&quot;edx&quot;) _,
        );
    }

    let name = core::str::from_utf8(&amp;name_buf).unwrap();
    println!(&quot;CPU Manufacturer ID: {}&quot;, name);
}</code></pre></pre>
<p>In the example above we use the <code>cpuid</code> instruction to read the CPU manufacturer ID.
This instruction writes to <code>eax</code> with the maximum supported <code>cpuid</code> argument and <code>ebx</code>, <code>esx</code>, and <code>ecx</code> with the CPU manufacturer ID as ASCII bytes in that order.</p>
<p>Even though <code>eax</code> is never read we still need to tell the compiler that the register has been modified so that the compiler can save any values that were in these registers before the asm. This is done by declaring it as an output but with <code>_</code> instead of a variable name, which indicates that the output value is to be discarded.</p>
<p>This code also works around the limitation that <code>ebx</code> is a reserved register by LLVM. That means that LLVM assumes that it has full control over the register and it must be restored to its original state before exiting the asm block, so it cannot be used as an output. To work around this we save the register via <code>push</code>, read from <code>ebx</code> inside the asm block into a temporary register allocated with <code>out(reg)</code> and then restoring <code>ebx</code> to its original state via <code>pop</code>. The <code>push</code> and <code>pop</code> use the full 64-bit <code>rbx</code> version of the register to ensure that the entire register is saved. On 32 bit targets the code would instead use <code>ebx</code> in the <code>push</code>/<code>pop</code>.</p>
<p>This can also be used with a general register class (e.g. <code>reg</code>) to obtain a scratch register for use inside the asm code:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

// Multiply x by 6 using shifts and adds
let mut x: u64 = 4;
unsafe {
    asm!(
        &quot;mov {tmp}, {x}&quot;,
        &quot;shl {tmp}, 1&quot;,
        &quot;shl {x}, 2&quot;,
        &quot;add {x}, {tmp}&quot;,
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
<span class="boring">}</span></code></pre></pre>
<h2 id="symbol-operands-and-abi-clobbers"><a class="header" href="#symbol-operands-and-abi-clobbers">Symbol operands and ABI clobbers</a></h2>
<p>By default, <code>asm!</code> assumes that any register not specified as an output will have its contents preserved by the assembly code. The <a href="unsafe/../../reference/inline-assembly.html#abi-clobbers"><code>clobber_abi</code></a> argument to <code>asm!</code> tells the compiler to automatically insert the necessary clobber operands according to the given calling convention ABI: any register which is not fully preserved in that ABI will be treated as clobbered.  Multiple <code>clobber_abi</code> arguments may be provided and all clobbers from all specified ABIs will be inserted.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

extern &quot;C&quot; fn foo(arg: i32) -&gt; i32 {
    println!(&quot;arg = {}&quot;, arg);
    arg * 2
}

fn call_foo(arg: i32) -&gt; i32 {
    unsafe {
        let result;
        asm!(
            &quot;call *{}&quot;,
            // Function pointer to call
            in(reg) foo,
            // 1st argument in rdi
            in(&quot;rdi&quot;) arg,
            // Return value in rax
            out(&quot;rax&quot;) result,
            // Mark all registers which are not preserved by the &quot;C&quot; calling
            // convention as clobbered.
            clobber_abi(&quot;C&quot;),
        );
        result
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="register-template-modifiers"><a class="header" href="#register-template-modifiers">Register template modifiers</a></h2>
<p>In some cases, fine control is needed over the way a register name is formatted when inserted into the template string. This is needed when an architecture's assembly language has several names for the same register, each typically being a &quot;view&quot; over a subset of the register (e.g. the low 32 bits of a 64-bit register).</p>
<p>By default the compiler will always choose the name that refers to the full register size (e.g. <code>rax</code> on x86-64, <code>eax</code> on x86, etc).</p>
<p>This default can be overridden by using modifiers on the template string operands, just like you would with format strings:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut x: u16 = 0xab;

unsafe {
    asm!(&quot;mov {0:h}, {0:l}&quot;, inout(reg_abcd) x);
}

assert_eq!(x, 0xabab);
<span class="boring">}</span></code></pre></pre>
<p>In this example, we use the <code>reg_abcd</code> register class to restrict the register allocator to the 4 legacy x86 registers (<code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code>) of which the first two bytes can be addressed independently.</p>
<p>Let us assume that the register allocator has chosen to allocate <code>x</code> in the <code>ax</code> register.
The <code>h</code> modifier will emit the register name for the high byte of that register and the <code>l</code> modifier will emit the register name for the low byte. The asm code will therefore be expanded as <code>mov ah, al</code> which copies the low byte of the value into the high byte.</p>
<p>If you use a smaller data type (e.g. <code>u16</code>) with an operand and forget the use template modifiers, the compiler will emit a warning and suggest the correct modifier to use.</p>
<h2 id="memory-address-operands"><a class="header" href="#memory-address-operands">Memory address operands</a></h2>
<p>Sometimes assembly instructions require operands passed via memory addresses/memory locations.
You have to manually use the memory address syntax specified by the target architecture.
For example, on x86/x86_64 using Intel assembly syntax, you should wrap inputs/outputs in <code>[]</code> to indicate they are memory operands:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

fn load_fpu_control_word(control: u16) {
    unsafe {
        asm!(&quot;fldcw [{}]&quot;, in(reg) &amp;control, options(nostack));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="labels"><a class="header" href="#labels">Labels</a></h2>
<p>Any reuse of a named label, local or otherwise, can result in an assembler or linker error or may cause other strange behavior. Reuse of a named label can happen in a variety of ways including:</p>
<ul>
<li>explicitly: using a label more than once in one <code>asm!</code> block, or multiple times across blocks.</li>
<li>implicitly via inlining: the compiler is allowed to instantiate multiple copies of an <code>asm!</code> block, for example when the function containing it is inlined in multiple places.</li>
<li>implicitly via LTO: LTO can cause code from <em>other crates</em> to be placed in the same codegen unit, and so could bring in arbitrary labels.</li>
</ul>
<p>As a consequence, you should only use GNU assembler <strong>numeric</strong> <a href="https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels">local labels</a> inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.</p>
<p>Moreover, on x86 when using the default Intel syntax, due to <a href="https://bugs.llvm.org/show_bug.cgi?id=36144">an LLVM bug</a>, you shouldn't use labels exclusively made of <code>0</code> and <code>1</code> digits, e.g. <code>0</code>, <code>11</code> or <code>101010</code>, as they may end up being interpreted as binary values. Using <code>options(att_syntax)</code> will avoid any ambiguity, but that affects the syntax of the <em>entire</em> <code>asm!</code> block. (See <a href="unsafe/inline-asm.html#options">Options</a>, below, for more on <code>options</code>.)</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a = 0;
unsafe {
    asm!(
        &quot;mov {0}, 10&quot;,
        &quot;2:&quot;,
        &quot;sub {0}, 1&quot;,
        &quot;cmp {0}, 3&quot;,
        &quot;jle 2f&quot;,
        &quot;jmp 2b&quot;,
        &quot;2:&quot;,
        &quot;add {0}, 2&quot;,
        out(reg) a
    );
}
assert_eq!(a, 5);
<span class="boring">}</span></code></pre></pre>
<p>This will decrement the <code>{0}</code> register value from 10 to 3, then add 2 and store it in <code>a</code>.</p>
<p>This example shows a few things:</p>
<ul>
<li>First, that the same number can be used as a label multiple times in the same inline block.</li>
<li>Second, that when a numeric label is used as a reference (as an instruction operand, for example), the suffixes â€œbâ€ (â€œbackwardâ€) or â€fâ€ (â€œforwardâ€) should be added to the numeric label. It will then refer to the nearest label defined by this number in this direction.</li>
</ul>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p>By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However, in many cases it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.</p>
<p>Let's take our previous example of an <code>add</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!(
        &quot;add {0}, {1}&quot;,
        inlateout(reg) a, in(reg) b,
        options(pure, nomem, nostack),
    );
}
assert_eq!(a, 8);
<span class="boring">}</span></code></pre></pre>
<p>Options can be provided as an optional final argument to the <code>asm!</code> macro. We specified three options here:</p>
<ul>
<li><code>pure</code> means that the asm code has no observable side effects and that its output depends only on its inputs. This allows the compiler optimizer to call the inline asm fewer times or even eliminate it entirely.</li>
<li><code>nomem</code> means that the asm code does not read or write to memory. By default the compiler will assume that inline assembly can read or write any memory address that is accessible to it (e.g. through a pointer passed as an operand, or a global).</li>
<li><code>nostack</code> means that the asm code does not push any data onto the stack. This allows the compiler to use optimizations such as the stack red zone on x86-64 to avoid stack pointer adjustments.</li>
</ul>
<p>These allow the compiler to better optimize code using <code>asm!</code>, for example by eliminating pure <code>asm!</code> blocks whose outputs are not needed.</p>
<p>See the <a href="unsafe/../../reference/inline-assembly.html">reference</a> for the full list of available options and their effects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro"><a class="header" href="#macro">macro</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-tests"><a class="header" href="#write-tests">Write Tests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h1>
<p>https://doc.rust-lang.org/unstable-book/library-features/test.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-and-integration"><a class="header" href="#unit-and-integration">Unit and Integration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assertions"><a class="header" href="#assertions">Assertions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait"><a class="header" href="#asyncawait">Async/Await</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-and-await"><a class="header" href="#async-and-await">async and await!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future"><a class="header" href="#future">Future</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pin-and-unpin"><a class="header" href="#pin-and-unpin">Pin and Unpin</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stream"><a class="header" href="#stream">Stream</a></h1>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <script type="text/javascript" charset="utf-8">
        var pagePath = "print.md"
        </script>


        <!-- Custom JS scripts -->
        <script src="assets/custom3.js"></script>
        <script src="assets/lang1.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>